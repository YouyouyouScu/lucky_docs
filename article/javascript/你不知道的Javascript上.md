# 你不知道的JavaScript 上卷

## 第一部分 作用域和闭包

### 第1章 作用域是什么

* 问题1：变量储存在哪里？
* 问题2：程序需要时如何找到它们？



#### 1.1 编译原理

JavaScript语言是“动态”或“解释执行”语言，但事实上是一门编译语言。但它不是提前编译的，编译结果也不能在分布式系统中移植。

传统编译语言流程中，程序在执行之前会经历三个步骤，统称为“编译”。

* 分词/词法分析（Tokenizing/Lexing）

  将由字符组成的字符串分解成（对编程语言来说）有意义的代码块。

  ```Js
  var a = 2;
  ```

  上面这段程序会被分解成以下词法单元：var、a、=、2、;。

  空格是否会被当做词法单元，取决于空格在这门语言中是否有意义。

  

* 解析/语法分析（Parsing）

  将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的数。这个数被称作`抽象语法树`（Abstract Syntax Tree, AST）。

  ```Js
  var a = 2;
  ```

  以上代码的抽象语法树如下所示：

  * VariableDeclaration 顶级节点
    * Identifier 子节点，值为a
    * AssignmentExpression 子节点
      * NumericLiteral 子节点，字为2

  

* 代码生成

  将`AST`转换成可执行代码的过程。过程与语言、目标平台等相关。

  简单来说就是可以通过某种方法将`var a = 2;`的AST转化为一组机器指令。用来创建一个叫做a的变量（包括分配内存等），并将一个值存储在a中。

  

#### 1.2 理解作用域

##### 1.2.1 演员表

* 引擎：从头到尾负责整个JavaScript程序的编译和执行。
* 编译器：负责语法分析和代码生成等
* 作用域：负责收集并维护由所有声明的标识符（变量、函数）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

##### 1.2.2 对话

`var a = 2;`存在2个不同的声明。

* 1、编译器在编译时处理（`var a`）：在当前作用域中声明一个变量（如果之前没有声明过）。

  ```Flow
  st=>start: Start
  e=>end: End
  op1=>operation: 分解成词法单元
  op2=>operation: 解析成树结构AST
  cond=>condition: 当前作用域存在变量a?
  op3=>operation: 忽略此声明，继续编译
  op4=>operation: 在当前作用域集合中声明新变量a
  op5=>operation: 生成代码
  st->op1->op2->cond
  cond(yes)->op3->op5->e
  cond(no)->op4->op5->e
  ```

* 2、引擎在运行时处理（`a = 2`）：在作用域中查找该变量，如果找到就对变量赋值。

```Flow
st=>start: Start
e=>end: End
cond=>condition: 当前作用域存在变量a?
cond2=>condition: 全局作用域?
op1=>operation: 引擎使用这个变量a
op2=>operation: 引擎向上一级作用域查找变量a
op3=>operation: 引擎把2赋值给变量a
op4=>operation: 举手示意，抛出异常
st->cond
cond(yes)->op1->op3->e
cond(no)->cond2(no)->op2(right)->cond
cond2(yes)->op4->e
```

##### 1.2.3 LHS和RHS查询 

`L`和`R`分别代表一个赋值操作的左侧和右侧，当变量出现在赋值操作的左侧时进行`LHS`查询，出现在赋值操作的**`非左侧`**时进行`RHS`查询。

* LHS查询（左侧）：找到变量的容器本身，然后对其赋值

* RHS查询（非左侧）：查找某个变量的值，可以理解为 `retrieve his source value`，即取到它的源值

```Js
function foo(a) {
    console.log( a ); // 2
}

foo(2);
```

上述代码共有1处LHS查询，3处RHS查询。

* LHS查询有：
  * 隐式的`a = 2`中，在`2`被当做参数传递给`foo(…)`函数时，需要对参数`a`进行LHS查询

* RHS查询有：

  * 最后一行`foo(...)`函数的调用需要对foo进行RHS查询

  * `console.log( a );`中对`a`进行RHS查询

  * `console.log(...)`本身对`console`对象进行RHS查询

    

#### 1.3 作用域嵌套

遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止。



#### 1.4 异常

`ReferenceError`和作用域判别失败相关，`TypeError`表示作用域判别成功了，但是对结果的操作是非法或不合理的。

* RHS查询在作用域链中搜索不到所需的变量，引擎会抛出`ReferenceError`异常。
* 非严格模式下，LHS查询在作用域链中搜索不到所需的变量，全局作用域中会创建一个具有该名称的变量并返还给引擎。
* 严格模式下（ES5开始，禁止自动或隐式地创建全局变量），LHS查询失败会抛出`ReferenceError`异常
* 在RHS查询成功情况下，对变量进行不合理的操作，引擎会抛出`TypeError`异常。（比如对非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性）



#### 1.5 小结

`var a = 2`被分解成2个独立的步骤。

* 1、`var a`在其作用域中声明新变量
* 2、`a = 2`会LHS查询a，然后对其进行赋值

#####  

### 第2章 词法作用域

#### 2.1 词法阶段

词法作用域是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，所以在词法分析器处理代码时会保持作用域不变。（不考虑欺骗词法作用域情况下）

##### 2.1.1 查找

* 作用域查找会在找到第一个匹配的标识符时停止。

* 遮蔽效应：在多层嵌套作用域中可以定义同名的标识符，内部的标识符会“遮蔽”外部的标识符。

* 全局变量会自动变成全局对象的属性，可以间接的通过对全局对象属性的引用来访问。通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但是非全局的变量如果被遮蔽了，无论如何都无法被访问到。

  ```js
  window.a
  ```

* 词法作用域只由函数被声明时所处的位置决定。

* 词法作用域查找只会查找一级标识符，比如a、b、c。对于`foo.bar.baz`，词法作用域只会查找`foo`标识符,找到之后，**对象属性访问规则**会分别接管对`bar`和`baz`属性的访问。



#### 2.2 欺骗词法

欺骗词法作用域会导致性能下降。以下两种方法**不推荐使用**

##### 2.2.1 eval

`eval(..)`函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。

```Js
function foo (str, a) {
    eval( str ); // 欺骗！
    console.log( a, b );
}

var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

`eval('var b = 3')`会被当做本来就在那里一样来处理。

* 非严格模式下，如果`eval(..)`中所执行的代码包含一个或多个声明，会在运行期修改书写期的词法作用域。上述代码中在`foo(..)`内部创建了一个变量b，并遮蔽了外部作用域中的同名变量。
* 严格模式下，`eval(..)`在运行时有自己的词法作用域，其中的声明无法修改作用域。

```Js
function foo (str) {
    "use strict"; 
    eval( str ); 
    console.log( a ); // ReferenceError: a is not defined
}

foo( "var a = 2;" ); 
```

* `setTimeout(..)`和`setInterval(..)`的第一个参数可以是字符串，会被解释为一段动态生成的函数代码。**已过时，不要使用**
* `new Function(..) `的最后一个参数可以接受代码字符串（前面的参数是新生成的函数的形参）。**避免使用**



##### 2.2.2 with

`with`通常被当做重复引用同一个对象中的多个属性的快捷方式，可以**不需要重复引用对象本身**。

```Js
var obj = {
    a: 1,
    b: 2,
    c: 3
};

// 单调乏味的重复“obj”
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 简单的快捷方式
with (obj) {
	a = 3;
    b = 4;
    c = 5;
}
```

with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，这个对象的属性会被处理为定义在这个作用域中的词法标识符。

这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。

```Js
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b : 3
}

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 -- 不好，a被泄露到全局作用域上了！
```

上面例子中，创建了`o1`和`o2`两个对象。其中一个有`a`属性，另一个没有。在`with(obj){..}`内部是一个LHS引用，并将2赋值给它。

* `o1`传递进去后，with声明的作用域是`o1`,`a = 2`赋值操作找到`o1.a`并将2赋值给它。
* `o2`传递进去后，作用域`o2`中并没有`a`属性，因此进行正常的LHS标识符查找，o2的作用域、`foo(..)`的作用域和全局作用域都没有找到标识符a，因此当`a = 2`执行时，自动创建了一个全局变量（非严格模式），所以`o2.a`保持undefined。



##### 2.2.3 性能

* JavaScript引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
* 引擎在代码中发现`eval(..)`或`with`，它只能简单的**假设**关于标识符位置的判断都是无效的。因为无法在词法分析阶段明确知道`eval(..)`会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给`with`用来创建词法作用域的对象的内容到底是什么。
* 悲观情况下如果出现了`eval(..)`或with，所有的优化**可能**都是无意义的，最简单的做法就是**完全不做**任何优化。代码运行起来一定会变得非常慢。



#### 2.3 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。

编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

有以下两个机制可以“欺骗”词法作用域：

* `eval(..)`：对一段包含一个或多个声明的”代码“字符串进行演算，借此来修改已经存在的词法作用域（**运行时**）。
* `with`：将一个对象的引用**当做**作用域来处理，将对象的属性当做作用域中的标识符来处理，创建一个新的词法作用域（**运行时**）。

副作用是引擎无法在编译时对作用域查找进行优化。因为引擎只能谨慎地认为这样的优化是无效的，使用任何一个都将导致代码运行变慢。**不要使用它们**

