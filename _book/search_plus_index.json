{"./":{"url":"./","title":"简介","keywords":"","body":"JavaScript学习心得 是否感谢大家来到我的个人博客，俗话说“好记性不如烂笔头”，在互联网高速发展的今天，主动学习成为一个必备技能。个人主要从事Mendix，Vue，Android开发的相关工作，由于最近工作的原因Android接触较少，请大家见谅。 此文主要分为六大板块，分别介绍了个人的一些开源项目，以及Vue,Javascript,Mendix等开发；同时提供了一些常用插件开发技巧和开发中资源的收集和整理。 我的开源项目(欢迎star) 1. luckly_recyclerview 2. luckly_popup_window 3. Vue+iView开发基础包 4. 个人Github移动客户端 Vue开发 1. Vue父组件使用scoped无法修改子组件样式 2. Vue使用render函数渲染组件 3. Vue中插件开发的四种方式 JavaScript学习心得 轻量化平台Mendix 1. Mendix环境搭建 2. Mendix使用Java 3. 组件开发 1) 环境准备 2) 开发组件之注意事项 3) Vue开发Mendix组件 4) 组件进阶-详细API 5) 组件进阶-常用API 4. Mendix后台程序环境搭建 5. 如何使用Mendix创建REST服务 6. Mendix后台程序环境搭建 7. Mendix教程（11篇文章） Android开发 其他及工具 VsCode插件开发 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-05-06 23:02:50 "},"article/open/luckly_recyclerview.html":{"url":"article/open/luckly_recyclerview.html","title":"1. luckly_recyclerview","keywords":"","body":"一、部分方法介绍9、设置上拉加载和下拉刷新在不同的状态10、设置是否空白视图和错误视图点击刷新11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦)12、 局部刷新二、如何实现分组1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP);2、重写Adapter继承基类BaseGroupAdapter3、常用的几个方法三、具体如何使用请看例子 简介：使用RecyclerView封装headerview,footerView,并实现上拉加载更多，下拉刷新，分组功能(添加上拉加载和下拉刷新设置背景) 界面可能有点丑，&#x1F601;，但是是为了展示所有效果，请大家见谅。（所有东西都是可自己设置的哦）&#x1F60A; 效果图： 如何获取: 第一步：在项目的build.gradle中添加 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 第二步：添加依赖 dependencies { compile 'com.github.mrgaogang:luckly_recyclerview:v2.3.0' } 目录 一、部分方法介绍 1、设置加载更多的监听事件 2、设置下拉刷新监听事件 3、添加分割线 4、添加错误视图 5、添加空视图 6、添加headerView 7、设置下拉刷新进度条的颜色和字体的颜色 8、设置监听事件 9、设置上拉加载和下拉刷新在不同的状态 10、设置是否空白视图和错误视图点击刷新 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 12、 局部刷新 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 3、常用的几个方法 三、具体如何使用请看例子 一、部分方法介绍 1、设置加载更多的监听事件 mLRecyclerView.setLoadMoreListener(this); 并重写onLoadMore()方法。 2、设置下拉刷新监听事件 mLRecyclerView.setOnRefreshListener(this); 并重写onRefresh()方法。 3、添加分割线 已经封装好了线性布局的分割线和网格式布局的分割线、流式布局的分割线。 //线性布局 mLRecyclerView.addLinearDivider(LRecyclerView.VERTICAL_LIST); //网格式布局 mLRecyclerView.addGridDivider(); //可以指定颜色和宽度 addGridDivider(int color, int dividerHeight) addLinearDivider(int oritation, int color, int lineWidth) 4、添加错误视图 当网络连接失败等情况的时候，需要显示错误视图。 //添加错误的View mLRecyclerView.setErrorView(R.layout.error_view); //添加错误的View View error = LayoutInflater.from(this).inflate(R.layout.view_error, null, false); mLRecyclerView.setErrorView(error); 使用getErrorView()得到错误视图。 5、添加空视图 当数据为空的时候，需要显示。 //添加空的View mLRecyclerView.setEmptyView(R.layout.empty_view); //添加空的View View empty = LayoutInflater.from(this).inflate(R.layout.view_empty, null, false); mLRecyclerView.setEmptyView(error); 使用getErrorView()得到空视图。 6、添加headerView //添加headerView mLRecyclerView.addHeaderView(R.layout.header_view); //添加headerView，需要设置父类为mLRecyclerView View headerView = LayoutInflater.from(this).inflate(R.layout.header_view, mLRecyclerView, false); mLRecyclerView.addHeaderView(headerView); //得到所有headerView视图。 List getHeaderViews(); //得到所有headerView的个数。 int getHeaderViewCount(); 7、设置下拉刷新进度条的颜色和字体的颜色 //改变下方加载进度的字体颜色 mLRecyclerView.setLoadingTextColor(Color.BLUE); //改变下方加载进度条的颜色 mLRecyclerView.setLoadingProgressColor(Color.BLUE); //修改下拉刷新颜色 mLRecyclerView.setRefreshColor(getResources().getColor(R.color.colorAccent)); 8、设置监听事件 //设置点击事件，注意此处返回的position是不包括headerView和不包括下拉加载的视图的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(int position) { //position为数据的位置 Log.i(TAG,\"点击--->\"+position); } @Override public void onItemLongClick(int position) { Log.i(TAG,\"长按--->\"+position); } }); 9、设置上拉加载和下拉刷新在不同的状态 @Override public void onLoadMore() { //设置处于正在加载状态 mLRecyclerView.setLoading(); new Handler().postDelayed(new Runnable() { @Override public void run() { int count = dataAdapter.getItemCount() + 1; if (count strings = new ArrayList<>(); for (int i = count - 1; i @Override public void onRefresh() { mLRecyclerView.setRefreshEnable(true); new Handler().postDelayed(new Runnable() { @Override public void run() { dataAdapter.clearAll(); List strings = new ArrayList<>(); for (int i = 0; i 10、设置是否空白视图和错误视图点击刷新 mLRecyclerView.setOnClickEmptyOrErrorToRefresh(true); 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 注意: 如果在初始化的时候 直接设置了背景图片可不用刷新adapter。 如果通过网络获取到背景图片之后可以使用如下方法设置背景，但是需要添加一步：notifyItemChanged() //设置下拉刷新的背景图片（可放广告图片哦） mLRecyclerView.setRefreshBackground(getResources().getDrawable(R.drawable.headerback)); //设置上拉加载部分设置背景图片（也可放广告哦） mLRecyclerView.setFooterBackground(getResources().getDrawable(R.drawable.footerback)); //如果通过网络获取的footer图片，则需要调用以下：（如果是设置刷新部分的背景直接调用setRefreshBackground） mLRecyclerView.getOriginalRecyclerView().getAdapter() .notifyItemChanged(mLRecyclerView.getOriginalRecyclerView().getAdapter().getItemCount() - 1); 12、 局部刷新 注意：使用局部刷新时要加上offset /* * 关于position: * 1、在自定义Adapter的时候 position是自己定义的数据0-length-1 * * * */ //设置点击事件，注意此处返回的position是不包括headerView 不包括下拉刷新的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //此处返回的position为数据的position，不包括 添加的头部和下拉刷新 Log.i(TAG, \"点击--->\" + position); //在进行局部刷新的时候 一定要记得加上offsetcount,偏移量；使用局部刷新记得notifyItemChanged第二个参数不要为空 dataAdapter.notifyItemChanged(position+mLRecyclerView.getOffsetCount(), \">>>>>>刷新\"); } @Override public void onItemLongClick(View view, int position) { TextView textView = (TextView) view.findViewById(R.id.item); textView.setText(\"长按\" + position); Log.i(TAG, \"长按--->\" + position); } }); 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 需要重写的几个方法： /** * 第一层的数量 * * @return */ public abstract int getParentCount(); /** * 每一个parent下的child的数量 * * @param parentPosition * @return */ public abstract int getChildCountForParent(int parentPosition); public abstract A onCreateParentViewHolder(ViewGroup parent, int viewType); public abstract B onCreateChildViewHolder(ViewGroup parent, int viewType); public abstract void onBindParentViewHolder(A holder, int position); /** * 分别是hoder,parent的位置（全局的位置） * child在parent中的index(不是position) * * @param holder * @param parentPosition * @param childIndexForParent */ public abstract void onBindChildViewHolder(B holder, int parentPosition, int childIndexForParent); 在使用点击事件的时候要注意判断是否为Parent： luckRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View rootView, int position) { if (mGroupAdapter.isParentView(position)){ mGroupAdapter.showChild(rootView); }else { Toast.makeText(getApplicationContext(),\"点击了第\"+mGroupAdapter.getParentIndexFromChild(position)+\"个parent的\"+mGroupAdapter.getChildIndexForParent(position),Toast.LENGTH_SHORT).show(); } } @Override public void onItemLongClick(View rootView, int position) { } }); 3、常用的几个方法 1、获取child在parent下的index mGroupAdapter.getChildIndexForParent(position); 2、获取parent的index mGroupAdapter.getParentIndexFromChild(position); 3、判断当前position是否为parentView mGroupAdapter.isParentView(position); 三、具体如何使用请看例子 LucklyRecyclerView 欢迎关注我的微信公众号： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/open/luckly_popup_window.html":{"url":"article/open/luckly_popup_window.html","title":"2. luckly_popup_window","keywords":"","body":"引用包 常用的方法1、添加数据2、设置LucklyPopupWindow的宽度（必须设置）3、给每一个Item添加分割线4、设置背景颜色5、设置PopupWindow显示时Activity其余部分显示灰色程度6、设置字体的颜色和大小7、设置图片不显示以及设置图片大小8、添加监听事件9、设置箭头的宽,高,圆角矩形的半径10、在某个View下/上显示（自动判断上下）11、模仿ios底部弹窗LucklyPopouWindow的使用方法。 简介：Android开发使用PupopWindow在指定View的上下左右动态显示菜单列表，模仿IOS底部弹窗列表。 欢迎大家Star&#x1F62F; Github地址 PupopWindow动态获取显示的位置，并添加指示箭头 效果图 目录: 1、添加数据 2、设置LucklyPopupWindow的宽度（必须设置） 3、给每一个Item添加分割线 4、设置背景颜色 5、设置PopupWindow显示时Activity其余部分显示灰色程度 6、设置字体的颜色和大小 7、设置图片不显示以及设置图片大小 8、添加监听事件 9、设置箭头的宽,高,圆角矩形的半径 10、在某个View下/上显示（自动判断上下） 11、模仿ios底部弹窗 引用包 Step 1.在根 build.gradle中添加如下依赖 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Step 2. 在build.gradle中添加如下依赖 dependencies { compile 'com.github.mrgaogang:luckly_popup_window:v1.4.1' } 常用的方法 1、添加数据 添加数据的时候，内容和图片的个数应该相同；如果不需要添加图片的话，那么使用第一个和第四个方法，传递的Bitmap=null即可。 void setData(DataBeans[] strings); void setData(String[] data, int[] images); void setData(String[] data, Bitmap[] images); void setData(List list); 2、设置LucklyPopupWindow的宽度（必须设置） LucklyPopupWindow的宽度（必须设置);设置的单位是dp。 void setWidth(int widthDp); 3、给每一个Item添加分割线 默认的情况是没有分割线的。需要调用以下方法。 //可以自己添加RecyclerView的分割线 addItemDecoration(RecyclerView.ItemDecoration itemDecoration); //使用内部封装好了的分割线，传入的参数分别是：方向，颜色，分割线的宽 addItemDecoration(int oritation, int color, int lineHeight); 4、设置背景颜色 也就是设置三角形和矩形框的背景颜色 setBackgroundColor(int backgroundColor); 5、设置PopupWindow显示时Activity其余部分显示灰色程度 取值范围0.0 setDarkBackgroundDegree(float darkBackgroundDegree); 6、设置字体的颜色和大小 setTextColor(int textColor); setTextSize(int textSize)； 7、设置图片不显示以及设置图片大小 setImageDisable(boolean imageDisable); setImageSize(int widthDp,int heightDp); 8、添加监听事件 void setOnItemClickListener(LucklyPopopWindow.OnItemClickListener onItemClickListener); 9、设置箭头的宽,高,圆角矩形的半径 void setTriangleWidth(int triangleWidth); void setTrianleHeight(int trianleHeight); void setRadius(int radius); 10、在某个View下/上显示（自动判断上下） 注意：这个方法必须最后调用。 void showAtLocation(View parentView, View positionView); 11、模仿ios底部弹窗 mLucklyPopopWindow.showInBottom(getWindow().getDecorView()); LucklyPopouWindow的使用方法。 请见: https://github.com/MrGaoGang/luckly_popup_window 欢迎Star mLucklyPopopWindow = new LucklyPopopWindow(this); //给popupWindow添加数据 mLucklyPopopWindow.setData(getResources().getStringArray(R.array.popupArray), new int[]{R.mipmap.add, R.mipmap.delete, R.mipmap.modify, R.mipmap.update}); mAdapter.setOnItemClickListener(new RecyclerAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //必须设置宽度 mLucklyPopopWindow.setWidth(150); //监听事件 mLucklyPopopWindow.setOnItemClickListener(new LucklyPopopWindow.OnItemClickListener() { @Override public void onItemClick(int position) { Toast.makeText(MainActivity.this, \"点击的位置\" + position, Toast.LENGTH_SHORT).show(); mLucklyPopopWindow.dismiss(); } }); //添加分割线(可选) mLucklyPopopWindow.addItemDecoration(LucklyPopopWindow.VERTICAL,Color.GRAY,1); //设置image不显示(可选) // mLucklyPopopWindow.setImageDisable(true); //设置image的大小(可选) mLucklyPopopWindow.setImageSize(20,20); //显示popopWindow mLucklyPopopWindow.showAtLocation(getWindow().getDecorView(), view); } }); Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/open/vue_template.html":{"url":"article/open/vue_template.html","title":"3. Vue+iView开发基础包","keywords":"","body":"如何使用此lucky_vue_template模板？目录结构 简介:由Vue2.0+Webpack4.0+iView3.0+Vuex+Router搭建的Vue开发模板 如何使用此lucky_vue_template模板？ Github地址(lucky_vue_template) $ npm install -g vue-cli $ vue init mrgaogang/lucky_vue_template my-project $ cd my-project $ npm install $ npm run dev 此脚手架配套vscode插件: 查看插件 项目地址:https://github.com/MrGaoGang/lucky_vue_template 目录结构 |-- lucky_vue |-- babel.config.js//babel配置 |-- index.css//全局css样式 |-- index.html |-- package-lock.json |-- package.json |-- webpack.base.config.js//webpack打包基础配置 |-- webpack.dev.config.js//本地环境打包配置 |-- webpack.prod.config.js//生产打包配置 |-- dist//打包生产目录 | |-- index.html | |-- css | |-- fonts | |-- img | |-- js |-- src |-- App.vue |-- main.js//单页面入口 |-- modules.js |-- components//子组件 | |-- Home.vue |-- plugins//一些插件 | |-- iview.js |-- router//页面路由统一配置 | |-- index.js |-- server//所有服务请求 | |-- fetch.js//封装的网络请求 | |-- index.js | |-- api | | |-- index.js//一些api常量 | |-- modules//请求模块化 | |-- home.js |-- store//状态管理 |-- index.js |-- modules//状态管理模块化 |-- home.js Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/vue/":{"url":"article/vue/","title":"一、Vue","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/vue/Vue父组件使用scoped无法修改子组件样式.html":{"url":"article/vue/Vue父组件使用scoped无法修改子组件样式.html","title":"1. Vue父组件使用scoped无法修改子组件样式","keywords":"","body":"1、部分全局方法2、深选择器 在Vue开发中我们难免会引用各种组件和样式；有时候样式不符合业务需求；则需要对指定的dom进行样式的修改；如果我们在vue中使用了scoped， 则无法在父组件中修改子组件的样式。下面介绍几种修改样式的方法 1、部分全局方法 /**在全局样式中修改要覆盖的样式**/ /**本地样式**/ 2、深选择器 .parentclass >>> .childClass{ } /**或者使用**/ .parentclass /deep/ .childClass{ } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/vue/Vue使用render函数渲染组件.html":{"url":"article/vue/Vue使用render函数渲染组件.html","title":"2. Vue使用render函数渲染组件","keywords":"","body":"一、Render 函数参数详解二、样例：如何给表格组件添加表头筛选此文源码案例:欢迎Star 目录 一、Render 函数参数详解 二、样例：如何给表格组件添加表头筛选 Vue 组件的开发有几种方式：单文件组件，使用 render 函数渲染，使用 template。 在大多数的情况下，Vue 可以使用单文件/template 的方式来创建页面；然而在有一些情况我们需要使用 JavaScript 的编程能力，比如使用第三方框架时，想要自定义某个功能；这个时候就可以使用到 render 函数。 本文将使用 iView table 为例，通过 render 函数添加可搜索的表头筛选。 一、Render 函数参数详解 //一个简单的例子：渲染一个p标签，内容为 '我是p标签的内容' new Vue({ render: createElement => createElement(\"p\", \"我是p标签的内容\") }); 其实 createElement()还有更强大的参数: // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 \"div\", // {Object} // 一个包含模板相关属性的数据对象, // 你可以在 template 中使用这些特性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ \"先写一些文字\", createElement(\"h1\", \"一则头条\"), createElement(MyComponent, { props: { someProp: \"foobar\" } }) ] ); createElement(obj,{},[]) 参数详解: 第一个参数为渲染成哪个节点，接受 String,Object,Function 三种类型； 如果是 String,比如是 div，那么表示此标签将会渲染成 div 标签；String 渲染成普通的 html 标签 如果是 Object，比如是一个 Vue 的组件:TableFilter，那么表示此标签将会渲染一个组件。通常我们在单文件组件中使用的时候是 import {Table} from \"iview\";然后在 template 中引用此标签；而使用 render 则需要使用 createElement 方式创建一个。 如果是 Function，则可以根据自己的业务逻辑动态觉得是渲染成普通的 html 标签还是 Vue 组件。 2) 第二个参数接受 一个对象{}类型的数据。其主要作用类似于组件中对某一个节点设置各种 bind 属性：设置样式 style，设置事件 on，设置类 class，设置自定义的命令，设置普通的 html 属性，设置传递参数 props 等等。 有一点要注意：正如在模板语法中，v-bind:class 和 v-bind:style，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。 { // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: { color: 'red', fontSize: '14px' }, // 普通的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on`，当子组件使用$emit()方式发生，使用on接收 // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // 作用域插槽格式 // { name: props => VNode | Array } scopedSlots: { default: props => createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true } 你会发现使用 render 函数没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：比如 props: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } 第三个参数为列表类型的数据，表示当前渲染组件的有哪些子组件。 render(createElement=> return createElement( 'div', { }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [// '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] )) 注意：子组件中的每一项（VNodes）都必须是唯一的;意味着，下面的 render function 是无效的： render: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 二、样例：如何给表格组件添加表头筛选 效果图: iview的默认table组件不支持 表头输入框筛选，官方地址 此处默认您有了一定的vue开发基础。 套用iview官方的例子： //显示表格的例子 import { Table ,Button,Icon,Modal} from \"iview\"; import Vue from \"vue\"; export default { components: { Table }, data() { return { columns7: [ { title: \"Name\", key: \"name\", //使用render函数自定义列显示效果：文本加粗 render: (h, params) => { return h(\"div\", [//使用render渲染一个div标签 h(Icon, {//使用render渲染一个iview的组件 props: {//传递参数 type: \"person\" } }), h(\"strong\", params.row.name)//文字加粗 ]); } }, { title: \"Age\", key: \"age\" }, { title: \"Address\", key: \"address\" }, { title: \"Action\", key: \"action\", width: 150, align: \"center\", render: (h, params) => { return h(\"div\", [//渲染一个div标签 h( Button,//在div标签下渲染一个iview组件 { props: {//传递参数 type: \"primary\", size: \"small\" }, style: {//设置样式 marginRight: \"5px\" }, on: {//监听$emit事件 click: () => { this.show(params.index); } } }, \"View\" ), h( Button, { props: { type: \"error\", size: \"small\" }, on: { click: () => { this.remove(params.index); } } }, \"Delete\" ) ]); } } ], data6: [ { name: \"John Brown\", age: 18, address: \"New York No. 1 Lake Park\" }, { name: \"Jim Green\", age: 24, address: \"London No. 1 Lake Park\" }, { name: \"Joe Black\", age: 30, address: \"Sydney No. 1 Lake Park\" }, { name: \"Jon Snow\", age: 26, address: \"Ottawa No. 2 Lake Park\" } ] }; }, methods: { show(index) { this.$Modal.info({ title: \"User Info\", content: `Name：${this.data6[index].name}Age：${ this.data6[index].age }Address：${this.data6[index].address}` }); }, remove(index) { this.data6.splice(index, 1); } }, mounted(){ //modal注入 Vue.prototype.$Modal=Modal; } }; 由于table组件表头筛选不支持输入框筛选，那么我们就必须的自己绘制。 思路如下： 找到表头所在的节点 在表头节点后添加一个自定义筛选的div节点； 使用render函数渲染一个下拉输入的单文件组件 mounted(){ //modal注入 Vue.prototype.$Modal=Modal; //等dom元素渲染完成之后渲染筛选 this.$nextTick(()=>{ this.renderHeaderFilter(); }) } methods:{ //添加头部筛选 renderHeaderFilter(){ let allHeader =document.querySelectorAll(\".ivu-table-header .ivu-table-cell\"); console.log(allHeader); allHeader.forEach((element)=>{ let createNew=document.createElement(\"div\"); createNew.classList.add(\"vue-header-filter\"); element.appendChild(createNew); new Vue({ render(h){ return h(TableHeaderFilter,{ props:{} }) } }).$mount(createNew); }) } } 最后实现的效果为: 此文源码案例:欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "},"article/vue/Vue中插件开发的四种方式.html":{"url":"article/vue/Vue中插件开发的四种方式.html","title":"3. Vue中插件开发的四种方式","keywords":"","body":"阅读前必读一、添加全局方法和属性二、给Vue实例添加方法和属性三、通过混入 mixin 方法添加一些组件选项;四、添加全局资源：指令，过滤器等为什么要开发插件？ 插件是对Vue功能上的补充，比如可以设置页面全局共享属性，方法等。 目录 阅读前必读 一、添加全局方法和属性 二、给Vue实例添加方法和属性 三、通过混入 mixin 方法添加一些组件选项; 1. 局部混入 2. 全局混入 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 2. 添加过滤器 依据官方文档插件开发说明，插件开发有四种方式。 添加全局方法或者属性; 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 通过全局 mixin 方法添加一些组件选项; 添加全局资源：指令/过滤器/过渡等; 一个库，提供自己的 API，同时提供上面提到的一个或多个功能， 阅读前必读 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象. 比如： export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } 开发插件时，给Vue/Vue实例添加方法或者属性时，建议命名方式使用$开头，这样就不会存在和插件命名冲突。如果冲突了则优先使用组件属性/方法。 一、添加全局方法和属性 作用: 添加全局方法和属性，所有组件都可共享方法和属性，当某个组件更新了共享属性，那么其他组件也会同步更新。并非是组件实例之间的数据共享。 //1:编写组件 export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } //2:声明组件，注入组件 import install from \"./plugins/demo.js\"; Vue.use(install); //3：组件样例 {{ formatNumber }} import Vue from \"vue\"; export default { data() { return { gloablFunc: \"\" }; }, computed: { formatNumber: function() { //调用全局共享方法 return Vue.$globalFunction(this.gloablFunc); } } }; 二、给Vue实例添加方法和属性 方式:使用Vue.prototype的方式给Vue实例添加方法和属性 注意点：使用Vue.prototype的方式添加的属性是不会在各个实例之间数据共享的。 比如A实例修改了某属性，则B实例使用此属性时不会是A修改的值。 //1：组件编写 demo.js export default { install: function(Vue, options) { Vue.prototype.$instanceFunction = function(num) { return 3 * num; }; Vue.prototype.$instanceVar=\"我是实例变量\"; } }; //2：组件声明 main.js import install from \"./plugins/demo.js\"; Vue.use(install); //3:组件使用 Plugins.vue ...省略部分 添加实例方法/属性测试 {{ instanceVar }} mounted(){ console.log(this.$instanceVar); this.instanceVar=this.$instanceVar; //this.instanceVar=this.$instanceFunction(20); } 三、通过混入 mixin 方法添加一些组件选项; 混入mixin作用： 将混入对象的方法/数据对象合并到改组件本身的方法/数据上；若存在同名的方法，则首先调用混入对象，再调用组件本身方法，若存在同名数据对象，则使用组件的数据对象 混入分为局部混入和全局混入，一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。请谨慎使用全局混入，尽可能使用局部混入。 1. 局部混入 此处借用官方的例子选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 若存在同名方法则优先调用混入对象的方法。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { data: function() { return { message: \"hello\", foo: \"abc\" }; }, created: function() { console.log(\"混入对象的钩子被调用\"); }, methods:{ demo1(){ console.log(\"混入demo1\"); }, demo2(){ console.log(\"混入demo2\"); } } }; export default { mixins: [mixin], data: function() { return { message: \"goodbye\", bar: \"def\" }; }, created: function() { console.log('组件钩子被调用') console.log(this.$data); //混入对象的钩子被调用 //组件钩子被调用 // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } }, methods:{ demo1(){ console.log(\"组件demo1\"); } } }; 2. 全局混入 为全局Vue实例混入一个created方法，在每一个实例调用本身的created之前都会首先调用混入的created。 通常我们可以使用全局混入对Vue实例注入统一处理统计。 // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({ created: function () { //console.log(\"相信我，这个Log会在每一个Vue实例created之前调用\"); var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: 'hello! mrgao' }) // => \"hello!\" 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show等)，Vue 也允许注册自定义指令。 参考官方文档：自定义指令 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 //D.vue export default { data() { return { message: \"我是demo\" }; } }; //main.js Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) 结果为： name: \"demo\" value: \"我是demo\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 2. 添加过滤器 //1：编写过滤器 currency.js const digitsRE = /(\\d{3})(?=\\d)/g export function currency (value, currency, decimals) { value = parseFloat(value) if (!isFinite(value) || (!value && value !== 0)) return '' currency = currency != null ? currency : '$' decimals = decimals != null ? decimals : 2 var stringified = Math.abs(value).toFixed(decimals) var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified var i = _int.length % 3 var head = i > 0 ? (_int.slice(0, i) + (_int.length > 3 ? ',' : '')) : '' var _float = decimals ? stringified.slice(-1 - decimals) : '' var sign = value 单价:{{ product.price | currency }} 上述已经简单讲解了Vue插件开发的四种方式，最后一种方式，也就是将上述四种组合在一个install方法中即可。 文章实例请见：examples目录。 欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 23:43:41 "},"article/vue/Vue路由变化页面没有刷新解决办法.html":{"url":"article/vue/Vue路由变化页面没有刷新解决办法.html","title":"4. Vue路由变化页面没有刷新","keywords":"","body":" 在Vue使用router开发单页面过程中，我们会遇到多次进入同一页面，页面没有刷新的情况。 一个例子： 有一个列表页面和详情页面，当点击列表的每一项，显示详情。你会发现，如果我们单纯的使用this.$router.push({path:\"/detail\",query:{id:\"your id\",another:\"asasaas\"}})，跳转到详情页面，详情页面的数据并没有发生变化。 解决办法: 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象： export default{ ... watch: { '$route' (to, from) { // 对路由变化作出响应... if(to.path==\"/detail\"){ this.initData(); } } } } 或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫： {{id}} {{another}} export default { data() { return { id: \"\", another: \"\" }; }, methods: { initData(to) { let query = to.query; console.log(\"传递过来的数据\", query,to); this.id = query.id; this.another = query.another; } }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` this.initData(to); next(); }, mounted(){ this.initData(this.$route); } }; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-05-11 08:38:40 "},"article/mendix/":{"url":"article/mendix/","title":"三、轻量化平台Mendix","keywords":"","body":"一、什么是Mendix二、Mendix可以做什么三、Mendix的优点四、Mendix的缺点五、部分学习资料 以下所有文件均是原创，如需转载请注明作者和链接地址。 一、什么是Mendix Mendix是一个轻量化开发工具，我们可以写较少的代码来快速构建一个应用（网站/app）；其实所谓的构建一个APP，其原理也是一个h5界面，也是运行在安全浏览器中。 使用Mendix之后，我们不需要太多的去关心前端和后台代码如何实现，而更多的是关系系统的业务和逻辑。 使用Mendix，不需要你自己写后台程序，不需要你写h5界面，一切只需要托拉拽即可。（构建应用从未如此之快）； 二、Mendix可以做什么 “大部分的网站都可以做”。 也许上面这句话说的优点夸张，但是mendix的底层是使用Java编写，也会使用h5；所以h5能做的它都能做。 当然啦，前提是大家要对其有一定的熟悉度哦！ 三、Mendix的优点 写少量的代码 快速构建并上线一个应用（目前我所在的项目：1周上线一个应用） Mendix适合做公司内部各自权限管理系统（Mendix有非常完善的权限管理机制）； Mendix适合不太懂编程的同学 Mendix构建一个网站只需要托拉拽，当然也可自己写样式或者写h5。 可自己编写java/h5到mendix中，甚至将其他的js库引入直接使用。 Mendix组件开发可以使用Vue/React等框架 代码编写流程化，清晰化。（举个例子） （ if判断（菱形），查询数据库数据（retrieve lis of ）） 等等..... 四、Mendix的缺点 不太适合高并发网站（但是可将前后台分离，Mendix只负责前端界面展示，） 对性能要求非常高的同学，可能mendix做稍有欠缺； 五、部分学习资料 由于mendix目前只在国外流行，故学习资料大部分都是英文文档； 1. Mendix官网 https://gettingstarted.mendixcloud.com/index3.html 里面有100多个module，如果你学习完了，你就是大牛了。 2. mendix组件中关于mx.data的api:https://apidocs.mendix.com/7/client/mx.data.html 一些api文档，我希望大家鞥看看。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:32:53 "},"article/mendix/env.html":{"url":"article/mendix/env.html","title":"1. Mendix环境搭建","keywords":"","body":"一、Mendix安装教程二、新建一个项目 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、主要内容：介绍Mendix的安装教程和如何简单构建一个应用 2、适用人群：初学者； 3、浏览时间：有点点长哦； Mendix开发主要有两种方式，一种为网页版，一种是客户端；本文推荐使用客户端安装并开发。 一、Mendix安装教程 在安装Mendix之前，最好使用公司的账号在mendix官网注册一个账号，否则在启动客户端时需要验证邮箱；官网注册地址：https://signup.mendix.com/link/signup/?source=direct 1、Mendix安装额外的文件 mendix的安装主要有以下几个文件： Microsoft .NET Framework 4.6.2 地址：https://www.microsoft.com/net/download/thank-you/net462 Microsoft Visual C++ 2010 SP1 Redistributable Package Microsoft Visual C++ 2013 Redistributable Package Java Development Kit 1.8 地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mendix客户端 地址：https://appstore.home.mendix.com/link/modelers/ （最好下载最新的哦，访问可能有点慢） 记得在安装mendix客户端前安装上述四个文件，并将Java路径设置到系统变量中去哦。 2、安装客户端 在开始构建应用程序之前，需要在计算机上安装Mendix Desktop Modeler。请按照以下步骤安装Mendix Desktop Modeler： 打开下载的Mendix Modeler可执行文件。它的名字如下：Mendix-7.XX-Setup。 单击下一步。 选择我接受许可协议中的条款，然后单击下一步。 选择要安装到的文件夹，然后单击“ 下一步”。 输入要使用的开始菜单快捷方式文件夹，然后单击“ 下一步”。 选中“ 桌面”选项以在桌面上创建Modeler的快捷方式，然后单击“ 下一步”。 单击“ 安装”以在计算机上安装Modeler。 选中Launch Mendix 7.XX并单击Finish完成安装并启动Modeler。 以上是有关安装Mendix Desktop Modeler的方法。 二、新建一个项目 1、创建空项目 2、一些简单概念的介绍 在mendix中简单的界面构建以及数据库的创建只是需要简单的拖拽即可。但是又几个概念得提前缕清一下。 微流（Microflow）：类似于Java中的方法，又入参，出参，可在里面做循环，判断等等； 界面（Page）:页面的实现；使用客户端右侧，已经写好的组件拖拽到Page中即可迅速构建h5界面。 实体（在Domin Model中）：在mendix中有两种实体。持久化实体也就是数据库中的表；非持久化实体：Java中的类。 持久化实体： 非持久化实体： 3、一个视频教程 由于无法上传较长视频，所以请需要观看的同学点击以下链接观看： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:32:41 "},"article/mendix/javaaction.html":{"url":"article/mendix/javaaction.html","title":"2. Mendix使用Java","keywords":"","body":"JavaAction使用注意事项一、数据的添加 以下所有文件均是原创，如需转载请注明作者和链接地址。 此文demo地址：https://github.com/mrgaogang/mendix 日常开发中我们难免会有一些情况是无法使用微流实现的，此时需要我们使用Java原生的能力:JavaAction；此文主要介绍如何JavaAction对数据库的数据进行增删改查和使用action执行微流。 目录: 数据添加； 数据删除； 数据修改； 数据查询； 使用Action执行微流； JavaAction使用注意事项 JavaAction使用有几个注意点： executeAction()是mendix默认调用的方法，且我们只能在//BEGIN 和//END之间编写Java代码。 public java.util.List executeAction() throws Exception { // BEGIN USER CODE //此处是你的代码 // END USER CODE } 如果你有大量的代码需要编写请在类的末尾以下两个分隔符之间编写 // BEGIN EXTRA CODE // END EXTRA CODE 一、数据的添加 数据的创建可以使用Core.instantiate创建一个空的对象，也可直接new 出空对象；数据的提交可以使用obj.commit()可以使用Core.commit() public IMendixObject executeAction() throws Exception { // BEGIN USER CODE //第一种方式使用 IMendxObject创建数据 // IMendixObject ob= Core.instantiate(getContext(),\"Demo.User\"); // ob.setValue(getContext(),\"UserName\",UserName); // ob.setValue(getContext(),\"Password\",Password); // ob.setValue(getContext(),\"Age\",Age); // Core.commit(getContext(),ob); //第二种方式直接创建对象 User us=new User(getContext()); us.setUserName(UserName); us.setPassword(Password); us.setAge(Age); //提交数据到数据库 us.commit(getContext()); //也可以使用以下方式 //Core.commit(getContext(),us.getMendixObject()); return us.getMendixObject(); // END USER CODE } 二、数据的删除 数据的删除可以使用obj.delete()也可使用Core.delete() public java.lang.Boolean executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE //可以直接使用obj.delete ParameterParameter1.delete(getContext()); return true; // 也可以使用Core.delete的方式删除数据 //return Core.delete(getContext(),ParameterParameter1.getMendixObject()); // END USER CODE } 三、数据的修改 数据的修改和数据的提交类似，只是在action将数据修改后重新提交。 @Override public IMendixObject executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE ParameterParameter1.setUserName(\"===>我修改啦\"); ParameterParameter1.setPassword(\"我修改了密码\"); ParameterParameter1.setAge(200L); Core.commit(getContext(),ParameterParameter1.getMendixObject()); return ParameterParameter1.getMendixObject(); // END USER CODE } 四、查询数据 数据的查询主要使用以下几种方式 Core.retrieveXPathQuery() Core.retrieveXPathQueryAggregate() Core. retrieveId() Core. retrieveIdAsync() 其中XPath查询数据需要在前方加上// ；但是在mendix客户端编写xpath（比如在datagrid查询数据使用xpath）时 不需要加上//。 //Demo.User 检索所有用户。 //Demo.User[UserName='mrgao'] 检索名为'mrgao'的所有用户。 avg(//Demo.User[Age >10 ]/Age) 检索所有用户年龄大于10岁的 年龄平均数。 其中XPath可用的函数有： avg、count、max、min、sum、contains、starts-with、ends-with、not、true、false @Override public java.util.List executeAction() throws Exception { // BEGIN USER CODE List list=Core.retrieveXPathQuery(getContext(),\"//Demo.User\"); return list; // END USER CODE } 五、执行微流 微流的执行科分为同步执行execute()和异步执行executeAsyn()；此例子主要以同步执行为例； 微流执行时参数的传递主要使用Map的方式，且Key必须要和参数入参名称相同； 如果传入的是Object类型，则需要转化成mendixobject； 微流执行完成可获取到其返回的参数； public java.lang.String executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE Map map=new HashMap<>(); //记得转换成mendixobject,且Map的key需要和微流入参的名称一样 map.put(\"User\",ParameterParameter1.getMendixObject()); map.put(\"other\",other); //执行微流，mf为微流，map则为需要执行微流的入参 String result=Core.execute(getContext(),mf,map); return result; // END USER CODE } 如果还想了解更多相关Core的知识，请访问官方API ：Mendix官方CoreAPI 以及IMendixObject的API :IMendixObject官方API Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:32:39 "},"article/mendix/widget.html":{"url":"article/mendix/widget.html","title":"3. 组件开发","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 21:41:59 "},"article/mendix/widgets/开发组件前工具的准备.html":{"url":"article/mendix/widgets/开发组件前工具的准备.html","title":"1) 环境准备","keywords":"","body":"环境依赖Mendix组件开发打包工具gulp和grunt的比较：环境依赖 一、设置npm镜像为淘宝镜像 npm config set registry https://registry.npm.taobao.org 二、 安装Node.js到本地，然后执行以下命令 npm install yo grunt-cli generator-mendix -g 三、执行jshint进行grunt语法检查插件 npm install grunt-contrib-jshint --save-dev 四、在任意地方建一个目录，并进入此文件夹，执行 Yo mendix //注意在安装的时候要记得选择Grunt方式不要选择Gulp；接下来的选择AppStoreWidgetBiolerplate,from Github的方式 // 执行完之后会在目录中创建一个Gruntfile.js文件；打开JS文件，将里面的mpks->files->dest->TEST_WIDGETS_FOLDER替换成自己的mendix 工程目录的widgets目录即可。 然后在当前组件目录(有Gruntfile.js的目录)执行 grunt watch //该命令会自动的监听组件工程文件的修改，会自动打包到mendix工程目录下 Mendix组件开发打包工具gulp和grunt的比较： gulp优点： 不需要设置项目目录，在test目录下即可测试。 若只更新了组件的js代码，可直接在浏览器强制刷新界面，不需要重启mendix工程。 编译速度更快。 grunt优缺点： 虽说可直接打包到项目工程目录widgets下，但是尽可能不要直接在业务工程下测试组件（因为项目大之后启动会慢）； 每次测试都需要重启Mendix工程。 一、下载并安装Node.js 下载地址：https://nodejs.org/en/ 二、设置npm镜像 npm config set registry https://registry.npm.taobao.org 三、运行yo命令 运行 npm install -g yo generator-mendix命令 检查yo是否安装成功:yo --version 四、安装gulp npm install -g gulp-cli 五、请在空目录下运行 yo mendix 并设置组件的名称，选择Gulp编译，并创建一个AppStoreWidgetBoilerplate。 六、如何使用Gulp测试组件 1、使用VsCode编辑器打开组件根目录 2、在VSCode中新建终端并运行 gulp命令，每次保存，gulp会自动将组件打包 并在dist目录下生成.mpk文件； mpk文件是组件最终的文件，如果您已经开发完成组件， 可以将.mpk文件复制到项目工程目录下的widgets目录下， 并在mendix客户端中按F4刷新项目目录。 3、如果想测试组件的功能，可以将项目根目录下的mpr文件拷贝到组件test目录下， 并且删除Test.mpr文件，如果项目中使用到了其他组件，请一并拷贝到test/widgets目录下。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:00:03 "},"article/mendix/widgets/Vue_Mendix.html":{"url":"article/mendix/widgets/Vue_Mendix.html","title":"3) Vue开发Mendix组件","keywords":"","body":" 组件开发有很多中方式，比如使用React/Vue或者使用符合AMD规范的库；其实mendix官网开发的组件是使用的dojo开发。 如果有同学没有学习过Vue/React开发，但是对原生Javascript有一定了解的话，请移步开发一个简单组件需要的步骤和组件开发引入外部符合AMD规范的库存在的问题。我想在以上可以找到答案。 本文不详细解释如何使用Vue开发一个页面，如果您有使用Vue开发Mendix组件的需求， 那么请直接点击下载Mendix组件开发之Vue基础包。 使用基础包开发会减少您的开发周期，如果基础包有什么问题请联系我gaogangwork@qq.com。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:35:25 "},"article/mendix/widgets/详细API.html":{"url":"article/mendix/widgets/详细API.html","title":"4) 组件进阶-详细API","keywords":"","body":"一、组件开发mx.ui 界面设计二、组件开发mx.session获取三、组件开发数据获取mx.data四、组件开发mx.sever服务调用五、组件开发解析器mx.parse 首先对大家说一声抱歉，最近工作任务较为繁重，所以文章没有及时的更新；以下是最近几天加班总结和翻译出来的mendix，组件开发api文档。希望有同学能理解每一个对应API的作用。 一、组件开发mx.ui 界面设计 主要内容： 页面回退； 弹出框显示； 进度条显示与隐藏； 异常/信息/警告等显示； 组件重新加载； 表单打开； 微流操作中进度条显示； 文章地址： http://note.youdao.com/noteshare?id=1a91eb6560f8de4b0ffc9033b6c147d8 二、组件开发mx.session获取 主要内容： 组件中获取当前用户； 获取当前用户的GUID; 获取当前用户名； 获取当前用户的角色； 文章地址： http://note.youdao.com/noteshare?id=fe4218dce9aa1c7a1a4765e44f07c13c 三、组件开发数据获取mx.data 主要内容： 数据的创建； 数据的删除； 数据的查询； 数据的修改； 数据的监听； 文件保存 文章地址： http://note.youdao.com/noteshare?id=ab8c90ea1e44ffa6509c44568e0df8d5 四、组件开发mx.sever服务调用 主要内容： 服务的调用； 缓存查询 文章地址： http://note.youdao.com/noteshare?id=af24d16c2b8ff7229a368ffa1f69d318 五、组件开发解析器mx.parse 主要内容： 属性格式化； 值格式化； 值解析； 文章地址： http://note.youdao.com/noteshare?id=9e5210978d7789439e79f3c8bbffbc88 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 21:58:02 "},"article/mendix/widgets/常用API.html":{"url":"article/mendix/widgets/常用API.html","title":"5) 组件进阶-常用API","keywords":"","body":"一、常用的API（五）查询管理关系的数据（六）创建一个上下文二、组件开发XML文档（一）property配置（二）两个例子 原生前端API主要有一下几个： 1、mx.ui/mx.data/mx.server/mx.session : 链接 2、mendix ：链接 3、mxui : 链接 一、常用的API (一) 从实体中获取/创建/删除数据 mx.data.get({ xpath: \"//System.User\", filter: { sort: [[\"Name\", \"asc\"]], offset: 0, amount: 10 }, callback: function(objs) { console.log(\"Received \" + objs.length + \" MxObjects\"); } }); mx.data.create({ entity: \"MyFirstModule.Cat\", callback: function(obj) { console.log(\"Object created on server\"); }, error: function(e) { console.error(\"Could not commit object:\", e); } }) mx.data.remove({ guids: [ \"123456\", \"45678\" ], callback: function() { console.log(\"Objects removed\"); }, error: function(e) { console.log(\"Could not remove objects:\", e); } }); （二）执行微流 mx.ui.action(\"微流的名称\",{ context:上下文, progress: \"modal\", progressMsg:\"进度条消息\", callback: function(result) { console.log(\"Engine started: \" + result); } }) mx.data.action({ params: { applyto: \"selection\" actionname: \"微流\", guids: [ \"281530811285515\", \"281530811285506\"]//需要传递的参数 }, callback: function(obj) { // expect single MxObject alert(obj.get(\"manufacturer\")); }, error: function(error) { alert(error.message); } }); （三）打开页面 /** 请见：https://apidocs.mendix.com/7/client/mendix_lib_MxContext.html */ //上下文如何获取? var _context=mendix.lib.MxContext(); _context.setTrackEntity(你需要传递的实体) //或者使用_context.setTrackId(你需要传递的guid) mx.ui.openForm(\"页面\",{ location: \"content/popup/modal\", context:_context, callback: function(form) { console.log(form.id); } }) （四）监听实体值得变化 //监听某个实体的变化 var subscription = mx.data.subscribe({ guid: \"123213\", callback: function(guid) { console.log(\"Object with guid \" + guid + \" changed\"); } }); mx.data.unsubscribe(subscription); //监听实体某个属性的变化 var subscription = mx.data.subscribe({ guid: \"123213\", attr: \"Name\", callback: function(guid, attr, value) { console.log(\"Object with guid \" + guid + \" had its attribute \" + attr + \" change to \" + value); } }); mx.data.unsubscribe(subscription); //监听整个实体的变化 // Subscribe to changes in a class var subscription = mx.data.subscribe({ entity: \"System.User\", callback: function(entity) { console.log(\"Update on entity \" + entity); } }); mx.data.unsubscribe(subscription); （五）查询管理关系的数据 //多对一关系，路径要指定到关联关系实体的字段 obj.fetch(\"Demo.Test/Test_Test2/test2Attr\",function(data){ //成功回调数据，返回的是一条数据 },function(){ }); //多对对一关系，路径要指定到关联关系实体，不能是字段 obj.fetch(\"Demo.Test/Test_Test3\",function(data){ //成功回调数据，返回的是一个列表数据 },function(){ }); （六）创建一个上下文 详情请见:组件开发上下文 var context=mendix.lib.MxContext(); context.setTrackEntity(你的obj) 二、组件开发XML文档 （一）property配置 1、配置的类型有： //页面 //微流 2、其他配置项 isList=\"\" //是否为列表配置，只有当type=\"object\"的时候有效 entityProperty=\"配置实体的key\" //执行微流时入参的实体，注意此处的Key为相对位置； //也即是如果这个key所在的property和你配置的property在同一层级， //那么就直接使用实体的key，要是此propery比实体的property深一层， //那么此处就要写: ../实体的key allowNonPersistableEntities=\"false\"//是否允许非持久化实体 isPath=\"no\"//是否可通过关联取数据 parameterIsList=\"false/true\"//微流的入参是否为List的形式 multiline=\"false\"//当type=\"string\"的时候是否支持多行 defaultValue=\"\"//默认值 required=\"false/true\"//此配置项是否必须配置 isDefault=\"false\"//是否默认 （二）两个例子 1、枚举选择，实际在读取的时候是按照key 名称 分类 描述 弹窗 当前页面 2、实体配置 名称 分类 描述 3、微流配置（接受list方式的入参） 名称 分类 描述 或者 //上述的returnType的type可以有 4、选择实体的属性 名称 分类 描述 //所有可能的类型有: 5、选择实体的属性 //所选择的属性为某个实体下面的属性 名称 分类 描述 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 21:54:32 "},"article/mendix/Mendix后台程序环境搭建.html":{"url":"article/mendix/Mendix后台程序环境搭建.html","title":"4. Mendix后台程序环境搭建","keywords":"","body":"一、Docker的安装二、Docker Compose安装三、Mendix环境搭建四、启动成功五、Mendix后台环境搭建注意事项 以下所有文件均是原创，如需转载请注明作者和链接地址。 目录： 一、Docker的安装 二、Docker Compose安装 三、Mendix环境搭建 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 2、登录时为何使用Administor无法登录 3、docker-compose-mysql字段简要介绍 4 、访问地址为何过总是报错502 当在Mendix Desktop上编写完成项目，此时需要打包发布；首先请在客户端 -->Project-->Create Deployement Project； Mendix后台程序需要运行在Docker环境下，此文主要介绍mendix如何在centos下运行。 打包环境必须为生产环境： Mendix程序需要运行需要的环境限制： 在Centos7.3及以上版本,且Docker 要求 CentOS 系统的内核版本高于 3.10； 由于Mendix运行的Docker compose版本为1.22,所以请安装Docker 17.06.2。 一、Docker的安装 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce-17.06.2 #安装的是最新稳定版17.06.2 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version 二、Docker Compose安装 在安装Docker Compose之前请确定已经安装了python-pip。 python-pip安装教程请见此文 https://blog.csdn.net/yulei_qq/article/details/52984334 安装好pip之后，就可以安装Docker-Compose了. 在linunx终端执行：pip install docker-compose. 检查docker-compose是否安装成功： 三、Mendix环境搭建 Mendix运行在docker中，其开源环境请见:https://github.com/mendix/docker-mendix-buildpack。 开源地址的Readme.md文件有如下介绍： 简单介绍： get-sample：得到一个Mendix应用程序，并将其解压到build目录下； buid-image：创建Mendix运行，需要的镜像； run-container：启动容器。 1、请将您之前打包好的mda文件上传到服务器 scp xxx.mda root@ip地址:/usr/local/mendix/app (xxx：自己的工程名；mendix/app是自己创建的目录) 2、复制项目并切换目录 git clone https://github.com/mendix/docker-mendix-buildpack cd docker-mendix-buildpack 3、将sample的apk替换成自己的apk 替换成： 4、启动容器 运行make run-container 正常情况下容器会被启动，这样就可以通过url地址访问自己的应用程序。但是在启动时总会遇到各种问题。 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 由于在配置文件中配置了docker的8080映射到服务器的80端口，以及8090映射到81端口；所以请确认服务器的这两个端口是否已被占用（如果已经被占用：可修改此处的配置文件） 如果修改成其他的端口，请记修改Dockerfile配置文件中的nginx端口：否则程序不会允许 3、登录时为何使用Administor无法登录 mendix客户端的administor账户是在测试环境使用的； 如果程序发布到服务器， 则需要登录的账户为：MxAdmin 密码为：docker-compose-mysql中的ADMIN_PASSWORD字段 4、docker-compose-mysql字段简要介绍 mendixapp: image:为docker镜像； ADMIN_PASSWORLD:使用MxAdmin账户登录系统的密码； DATABASE_ENDPOINT：应用的数据库地址，最后一个mendix为创建的mendix数据库； ports：docker端口和服务器端口的映射关系，如果服务器的端口已被占用，则需要修改映射的端口； db： MYSQL_DATABASE=mendix //mendix数据库名 MYSQL_USER：mendix数据库的用户 MYSQL_PASSWORD：mendix数据库的密码 MYSQL_ROOT_PASSWORD=root //数据库最高权限密码（当然账号也为root） ports：docker中数据库端口和服务器端口的映射关系。 5、访问地址为何过总是报错502 哪些情况出现502: 访问次数过多； 3个小时左右会自动停止； 之所以一直报错502的最根本原因是没有向Mendix购买license；没有license 最多只能在线10个用户，且系统每隔3小时左右关闭。所以需要向Mendix购买License。 停止了，可重启容器 重新部署包，则需要先关闭mysql容器，再使用make run-container。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:32:46 "},"article/mendix/获取配置信息,使用java创建Rest服务.html":{"url":"article/mendix/获取配置信息,使用java创建Rest服务.html","title":"6. Mendix后台程序环境搭建","keywords":"","body":" 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、如何读取resource下的配置文件信息 假设resource目录下的文明为properties文件； //第一步：获取配置文件目录: File resourcePath=Core.getConfiguration().getResourcesPath(); //第二步：读取对应配置文件，此处可以根据环境的不同读取不同的配置文件 File configFile=new File(resourcePath,\"config.properties\"); Properties prop = new Properties(); //第三步：读取属性文件到Properties中 InputStream in = new BufferedInputStream (new FileInputStream(configFile)); prop.load(in); ///加载属性列表 Iterator it=prop.stringPropertyNames().iterator(); while(it.hasNext()){ String key=it.next(); System.out.println(key+\":\"+prop.getProperty(key)); } in.close(); 2、如何获取Cookie String cookies=\"\"; Cookie[] cook=this.context().getRuntimeRequest().get().getHttpServletRequest().getCookies(); for(Cookie c:cook){ cookies+=c.getName()+\"=\"+c.getValue()+\";\"; } 3、如何在java中打Log private static ILogNode log=Core.getLogger(\"mylogname\"); 4、如何在mendix启动之前做一下预处理？ 只需要在Project》Settings》Runtime》After Startup中调用即可。 5、自定义Rest服务 常常使用mendix自带的Rest服务无法满足我们的需求，那么怎么自定义Rest服务呢？自定义Rest服务只需要继承RequestHandler即可。 //第一步：继承RequestHandler，并实现processRequest方法 public class ArticleService extends RequestHandler { @Override protected void processRequest(IMxRuntimeRequest iMxRuntimeRequest, IMxRuntimeResponse iMxRuntimeResponse, String path) throws Exception { } } //第二步：在启动整个mendix的时候，调用一个Javaaction，在此Action中进行Rest服务注册。 public java.lang.Boolean executeAction() throws Exception { // BEGIN USER CODE //throw new com.mendix.systemwideinterfaces.MendixRuntimeException(\"Java action was not implemented\"); // 注册自定义服务 Core.addRequestHandler(\"my/rest\",new ArticleService()); return true; // END USER CODE } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 22:33:03 "},"article/mendix/一些功能的实现.html":{"url":"article/mendix/一些功能的实现.html","title":"7. Mendix教程（11篇文章）","keywords":"","body":" 由于文章较多，此处列举一些常实现的mendix功能和大家分享。以下所有文件均是原创，如需转载请注明作者和链接地址。 一、基础公共包功能一览 基础公共包功能一览 二、使用dojo开发mendix组件你必须知道的 dijit.register你必须知道的 dojo.aspect模块你必须知道的 dom-construct 三、开发者与非开发者如何定制化datagrid的样式 定制化datagrid 四、Excel中大量字段如何高效构建Entity Excel中大量字段如何高效构建Entity 五、Mendix实现级联选择 Mendix实现级联选择 六、Mendix导出数据到Excel（基础使用） Mendix导出数据到Excel（基础使用) 七、Mendix如何一键导出数据到Excel的多个Sheet Mendix如何一键导出数据到Excel的多个Sheet 八、Mendix监控实现方案（使用自带端口） Mendix监控实现方案（使用自带端口） 九、Mendix使用队列异步处理大量数据 Mendix使用队列异步处理大量数据 十、Mendix使用Excel导入数据 Mendix使用Excel导入数据 十一、DataGrid数据从微流获取，并实现自定义Search DataGrid数据从微流获取，并实现自定义Search Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-28 23:42:20 "},"article/other/vscode.html":{"url":"article/other/vscode.html","title":"VsCode插件开发","keywords":"","body":"一、环境搭建二、package.json 配置三、contributes介绍四、常用 API五、环境 简介：本文将会教会大家如何一步步开发Vscode插件。 插件地址 luck_npm 欢迎star 此插件的主要功能是方面使用 npm install,npm run dev,npm run build 命令；搭配 vue 脚手架 Vue+webpack+vuex+router更加舒适哦 效果图： 一、环境搭建 1、npm install -g yo generator-code 安装脚手架; 2、yo code 创建项目 本人选择的是：javascript 创建好之后系统会自动生成一个 package.json 和 extension.js 文件； 二、package.json 配置 { \"name\": \"lucky-npm\", //插件名称 \"displayName\": \"lucky npm\", \"description\": \"\", \"version\": \"1.0.1\", \"publisher\": \"mrgao\", \"engines\": { \"vscode\": \"^1.32.0\" }, \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/MrGaoGang/lucky_start.git\" }, \"categories\": [ //分类 \"Other\" ], \"icon\": \"icon/logo.png\", //logo \"activationEvents\": [ //激活方式 \"workspaceContains:package.json\", \"onCommand:lucky.gao.extension.install\", \"onCommand:lucky.gao.extension.start_dev\", \"onCommand:lucky.gao.extension.build_pro\" ], \"main\": \"./extension.js\", //入口文件 \"contributes\": { \"snippets\": [ //自定义一些代码模板（可以尝试输入fetch） { \"language\": \"javascript\", \"path\": \"./src/snippet/snippet.json\" } ], \"views\": { //视图 \"explorer\": [ { //在资源管理器中的视图，id为mrgao_luckys，名字为LUCKY NPM \"id\": \"mrgao_luckys\", \"name\": \"LUCKY NPM\" } ] }, \"commands\": [ //有哪些命令 { \"command\": \"lucky.gao.extension.install\", \"title\": \"安装依赖(install)\" }, { \"command\": \"lucky.gao.extension.start_dev\", \"title\": \"启动测试环境(dev)\" }, { \"command\": \"lucky.gao.extension.build_pro\", \"title\": \"构建生产版本(pro)\" } ], \"menus\": { //菜单，是否右键显示菜单，其中group为分类, \"editor/context\": [ { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.install\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.start_dev\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.build_pro\", \"group\": \"6_luck\" } ] } }, \"scripts\": { \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" }, \"devDependencies\": { \"typescript\": \"^3.3.1\", \"vscode\": \"^1.1.28\", \"eslint\": \"^5.13.0\", \"@types/node\": \"^10.12.21\", \"@types/mocha\": \"^2.2.42\" } } 1. activationEvents 介绍 激活插件的方式 onLanguage 激活 发出此激活事件，只要解析为某种语言的文件被打开，就会激活感兴趣的扩展。 \"activationEvents\"：[ \" onLanguage：python \" ] 可以使用数组中的单独 onLanguage 条目声明多种语言 activationEvents。 \"activationEvents\"：[ \" onLanguage：json \", \" onLanguage：markdown \", \" onLanguage：typescript \" ] onCommand 加载方式 发出此激活事件，并且只要调用命令，就会激活当前扩展： \" activationEvents \"：[ \" onCommand：extension.sayHello \" ] onDebug 加载方式 并在启动调试会话之前激活当前扩展： \" activationEvents \"：[ \" onDebug \" ] onDebugInitialConfigurations onDebugResolve 这是两个更细粒度的 onDebug 激活事件： onDebugInitialConfigurations 在调用 provideDebugConfigurations 方法之前触发 DebugConfigurationProvider。 onDebugResolve:type 在调用指定类型的 resolveDebugConfiguration 方法之前触发 DebugConfigurationProvider。 经验法则：如果调试扩展的激活是轻量级的，请使用 onDebug。如果它是重量级的，则使用 onDebugInitialConfigurations 和/或 onDebugResolve 取决于是否 DebugConfigurationProvider 实施相应的方法 provideDebugConfigurations 和/或 resolveDebugConfiguration。有关这些方法的更多详细信息，请参阅使用 DebugConfigurationProvider。 workspaceContains 激活方式 每当打开文件夹并且文件夹包含至少一个与 模式匹配的文件时，就会激活此激活事件并激活当前扩展。 \" activationEvents \"：[ \" workspaceContains：** /。editorconfig \" ] onFileSystem 激活方式 发出此激活事件，只要读取特定方案中的文件或文件夹，就会激活感兴趣的扩展。这通常是 file-scheme，但是对于自定义文件系统提供程序，有更多的方案可以实现，例如 ftp 或 ssh。 \" activationEvents \"：[ \" onFileSystem：sftp \" ] onView 激活方式 发出此激活事件，只要展开指定 ID 的视图，就会激活当前扩展： \" activationEvents \"：[ \" onView：nodeDependencies \" ] onUri 激活方式 发出此激活事件，只要打开该扩展的系统范围的 Uri，就会激活感兴趣的扩展。Uri 计划固定为 vscode 或 vscode-insiders。Uri 权限必须是扩展的标识符。Uri 的其余部分是任意的。 \" activationEvents \"：[ \" onUri \" ] 如果 vscode.git 扩展名定义 onUri 为激活事件，则会在以下任何一个 Uris 中打开它： vscode://vscode.git/init vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git vscode-insiders://vscode.git/init （对于 VS Code Insiders） onWebviewPanel 激活方式 每当 VS Code 需要使用匹配恢复 webview 时，将发出此激活事件并激活当前扩展 viewType。 例如，onWebviewPanel 的声明如下： \" activationEvents \"：[ \" onWebviewPanel：catCoding \" ] 当 VS Code 需要使用 viewType 恢复 webview 时，将导致扩展被激活：catCoding。viewType 在调用中设置 window.createWebviewPanel，您需要有另一个激活事件（例如，onCommand）来初始激活您的扩展并创建 webview。 * 激活方式 该*激活事件发出后，每当 VS 代码启动感兴趣的扩展将被激活。为确保良好的最终用户体验，请仅在您的用户使用其他激活事件组合时才在扩展中使用此激活事件。 \" activationEvents \"：[ \" * \" ] 三、contributes介绍 详情请见 contributes介绍 四、常用 API 这里主要介绍一下 extension 中的一些常用命令。官方 API 请见: vscode api 1. 命令 命令注册 //注册命令 vscode.commands.registerCommand('lucky.hello', () => { }); //注册之后必须在package.json中配置: { \"contributes\": { \"commands\": [{ \"command\": \"lucky.hello\", \"title\": \"Hello World\" }] } } // 命令执行 //vscode.open为vscode自带命令（也可以使用自己的命令），可以用来打开一个页面 vscode.commands.executeCommand( \"vscode.open\", vscode.Uri.parse(`https://code.visualstudio.com/updates/`) ); 获取所有命令 vscode.commands.getCommands(false); //会返回所有命令 接收一个参数:是否显示系统自带的内部命令,此处Wiefalse 2. 显示 vscode.window.showInformationMessage(\"我是info信息！\"); vscode.window.showErrorMessage(\"我是错误信息！\"); vscode.window.setStatusBarMessage(\"设置状态栏的消息\"); //带回调的提示 vscode.window .showInformationMessage(\"是否要做什么.....？\", \"是\", \"否\", \"不再提示\") .then(result => { if (result === \"是\") { } else if (result === \"不再提示\") { // 其它操作 } }); 3. window 创建一个终端并输入命令 let terminalA = vscode.window.createTerminal({ name: \"我是终端的名字\" }); terminalA.show(true); terminalA.sendText(\"npm start\"); //输入命令 显示一个输入框，让用户输入一个字符串 /** * 打开输入框以询问用户输入。 undefined如果输入框被取消（例如按ESC），则返回值。否则，返回的值将是用户键入的字符串，如果用户没有输入任何内容，则返回值为空，但是单击\"确定\"将输入框解除。 * */ const result = vscode.window.showInputBox({ prompt: \"请输入版本号，\", value: \"默认值\", placeHolder: \"提示\", valueSelection: [len, len] }); result.then(inputValue => { // 是按下ESC键 if (typeof _versionName === \"undefined\") return; //按下enter键 }); 创建树状视图 vscode.window.registerTreeDataProvider('viewId', treeProvider); //viewId对应package.json中id \"contributes\": { \"views\": { \"explorer\": [ { \"id\": \"viewId\", \"name\": \"NPM Tools\" } ] }, } //treeProvider请见此插件源码。 打开文档 vscode.workspace.openTextDocument(vscode.Uri.file(\"文件路径)).then( document => vscode.window.showTextDocument(document) ) 五、环境 vscode.env.appName //当前编辑器的名称 vscode.env.appRoot //打开的根目录 vscode.env.language //用户的语言环境 插件地址 欢迎star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:10:32 "}}