{"./":{"url":"./","title":"Introduction","keywords":"","body":"每日一学JavaScript基础学习Vue开发其他每日一学 常用第三方库 目录： JavaScript基础学习 Vue开发 JavaScript基础学习 ES5和ES6继承机制的设计思想 【转载】 Javascript 代码执行顺序 :+1: 【转载】 Javascript的call和applay方法 【原创】 Javascript深入之创建对象的多种方式以及优缺点 【转载】 Javascript的变量提升和函数提升 【原创】 Javascript原型和原型链 Vue开发 Vue父组件使用scoped无法修改子组件样式 【原创】 Vue插件开发详解 【原创】 Vue使用render函数渲染组件详解 【原创】 其他 常用的github API Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/open/luckly_recyclerview.html":{"url":"article/open/luckly_recyclerview.html","title":"1. luckly_recyclerview","keywords":"","body":"一、部分方法介绍9、设置上拉加载和下拉刷新在不同的状态10、设置是否空白视图和错误视图点击刷新11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦)12、 局部刷新二、如何实现分组1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP);2、重写Adapter继承基类BaseGroupAdapter3、常用的几个方法三、具体如何使用请看例子 简介：使用RecyclerView封装headerview,footerView,并实现上拉加载更多，下拉刷新，分组功能(添加上拉加载和下拉刷新设置背景) 界面可能有点丑，&#x1F601;，但是是为了展示所有效果，请大家见谅。（所有东西都是可自己设置的哦）&#x1F60A; 效果图： 如何获取: 第一步：在项目的build.gradle中添加 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 第二步：添加依赖 dependencies { compile 'com.github.mrgaogang:luckly_recyclerview:v2.3.0' } 目录 一、部分方法介绍 1、设置加载更多的监听事件 2、设置下拉刷新监听事件 3、添加分割线 4、添加错误视图 5、添加空视图 6、添加headerView 7、设置下拉刷新进度条的颜色和字体的颜色 8、设置监听事件 9、设置上拉加载和下拉刷新在不同的状态 10、设置是否空白视图和错误视图点击刷新 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 12、 局部刷新 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 3、常用的几个方法 三、具体如何使用请看例子 一、部分方法介绍 1、设置加载更多的监听事件 mLRecyclerView.setLoadMoreListener(this); 并重写onLoadMore()方法。 2、设置下拉刷新监听事件 mLRecyclerView.setOnRefreshListener(this); 并重写onRefresh()方法。 3、添加分割线 已经封装好了线性布局的分割线和网格式布局的分割线、流式布局的分割线。 //线性布局 mLRecyclerView.addLinearDivider(LRecyclerView.VERTICAL_LIST); //网格式布局 mLRecyclerView.addGridDivider(); //可以指定颜色和宽度 addGridDivider(int color, int dividerHeight) addLinearDivider(int oritation, int color, int lineWidth) 4、添加错误视图 当网络连接失败等情况的时候，需要显示错误视图。 //添加错误的View mLRecyclerView.setErrorView(R.layout.error_view); //添加错误的View View error = LayoutInflater.from(this).inflate(R.layout.view_error, null, false); mLRecyclerView.setErrorView(error); 使用getErrorView()得到错误视图。 5、添加空视图 当数据为空的时候，需要显示。 //添加空的View mLRecyclerView.setEmptyView(R.layout.empty_view); //添加空的View View empty = LayoutInflater.from(this).inflate(R.layout.view_empty, null, false); mLRecyclerView.setEmptyView(error); 使用getErrorView()得到空视图。 6、添加headerView //添加headerView mLRecyclerView.addHeaderView(R.layout.header_view); //添加headerView，需要设置父类为mLRecyclerView View headerView = LayoutInflater.from(this).inflate(R.layout.header_view, mLRecyclerView, false); mLRecyclerView.addHeaderView(headerView); //得到所有headerView视图。 List getHeaderViews(); //得到所有headerView的个数。 int getHeaderViewCount(); 7、设置下拉刷新进度条的颜色和字体的颜色 //改变下方加载进度的字体颜色 mLRecyclerView.setLoadingTextColor(Color.BLUE); //改变下方加载进度条的颜色 mLRecyclerView.setLoadingProgressColor(Color.BLUE); //修改下拉刷新颜色 mLRecyclerView.setRefreshColor(getResources().getColor(R.color.colorAccent)); 8、设置监听事件 //设置点击事件，注意此处返回的position是不包括headerView和不包括下拉加载的视图的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(int position) { //position为数据的位置 Log.i(TAG,\"点击--->\"+position); } @Override public void onItemLongClick(int position) { Log.i(TAG,\"长按--->\"+position); } }); 9、设置上拉加载和下拉刷新在不同的状态 @Override public void onLoadMore() { //设置处于正在加载状态 mLRecyclerView.setLoading(); new Handler().postDelayed(new Runnable() { @Override public void run() { int count = dataAdapter.getItemCount() + 1; if (count strings = new ArrayList<>(); for (int i = count - 1; i @Override public void onRefresh() { mLRecyclerView.setRefreshEnable(true); new Handler().postDelayed(new Runnable() { @Override public void run() { dataAdapter.clearAll(); List strings = new ArrayList<>(); for (int i = 0; i 10、设置是否空白视图和错误视图点击刷新 mLRecyclerView.setOnClickEmptyOrErrorToRefresh(true); 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 注意: 如果在初始化的时候 直接设置了背景图片可不用刷新adapter。 如果通过网络获取到背景图片之后可以使用如下方法设置背景，但是需要添加一步：notifyItemChanged() //设置下拉刷新的背景图片（可放广告图片哦） mLRecyclerView.setRefreshBackground(getResources().getDrawable(R.drawable.headerback)); //设置上拉加载部分设置背景图片（也可放广告哦） mLRecyclerView.setFooterBackground(getResources().getDrawable(R.drawable.footerback)); //如果通过网络获取的footer图片，则需要调用以下：（如果是设置刷新部分的背景直接调用setRefreshBackground） mLRecyclerView.getOriginalRecyclerView().getAdapter() .notifyItemChanged(mLRecyclerView.getOriginalRecyclerView().getAdapter().getItemCount() - 1); 12、 局部刷新 注意：使用局部刷新时要加上offset /* * 关于position: * 1、在自定义Adapter的时候 position是自己定义的数据0-length-1 * * * */ //设置点击事件，注意此处返回的position是不包括headerView 不包括下拉刷新的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //此处返回的position为数据的position，不包括 添加的头部和下拉刷新 Log.i(TAG, \"点击--->\" + position); //在进行局部刷新的时候 一定要记得加上offsetcount,偏移量；使用局部刷新记得notifyItemChanged第二个参数不要为空 dataAdapter.notifyItemChanged(position+mLRecyclerView.getOffsetCount(), \">>>>>>刷新\"); } @Override public void onItemLongClick(View view, int position) { TextView textView = (TextView) view.findViewById(R.id.item); textView.setText(\"长按\" + position); Log.i(TAG, \"长按--->\" + position); } }); 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 需要重写的几个方法： /** * 第一层的数量 * * @return */ public abstract int getParentCount(); /** * 每一个parent下的child的数量 * * @param parentPosition * @return */ public abstract int getChildCountForParent(int parentPosition); public abstract A onCreateParentViewHolder(ViewGroup parent, int viewType); public abstract B onCreateChildViewHolder(ViewGroup parent, int viewType); public abstract void onBindParentViewHolder(A holder, int position); /** * 分别是hoder,parent的位置（全局的位置） * child在parent中的index(不是position) * * @param holder * @param parentPosition * @param childIndexForParent */ public abstract void onBindChildViewHolder(B holder, int parentPosition, int childIndexForParent); 在使用点击事件的时候要注意判断是否为Parent： luckRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View rootView, int position) { if (mGroupAdapter.isParentView(position)){ mGroupAdapter.showChild(rootView); }else { Toast.makeText(getApplicationContext(),\"点击了第\"+mGroupAdapter.getParentIndexFromChild(position)+\"个parent的\"+mGroupAdapter.getChildIndexForParent(position),Toast.LENGTH_SHORT).show(); } } @Override public void onItemLongClick(View rootView, int position) { } }); 3、常用的几个方法 1、获取child在parent下的index mGroupAdapter.getChildIndexForParent(position); 2、获取parent的index mGroupAdapter.getParentIndexFromChild(position); 3、判断当前position是否为parentView mGroupAdapter.isParentView(position); 三、具体如何使用请看例子 LucklyRecyclerView 欢迎关注我的微信公众号： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/open/luckly_popup_window.html":{"url":"article/open/luckly_popup_window.html","title":"2. luckly_popup_window","keywords":"","body":"引用包 常用的方法1、添加数据2、设置LucklyPopupWindow的宽度（必须设置）3、给每一个Item添加分割线4、设置背景颜色5、设置PopupWindow显示时Activity其余部分显示灰色程度6、设置字体的颜色和大小7、设置图片不显示以及设置图片大小8、添加监听事件9、设置箭头的宽,高,圆角矩形的半径10、在某个View下/上显示（自动判断上下）11、模仿ios底部弹窗LucklyPopouWindow的使用方法。 简介：Android开发使用PupopWindow在指定View的上下左右动态显示菜单列表，模仿IOS底部弹窗列表。 欢迎大家Star&#x1F62F; Github地址 PupopWindow动态获取显示的位置，并添加指示箭头 效果图 目录: 1、添加数据 2、设置LucklyPopupWindow的宽度（必须设置） 3、给每一个Item添加分割线 4、设置背景颜色 5、设置PopupWindow显示时Activity其余部分显示灰色程度 6、设置字体的颜色和大小 7、设置图片不显示以及设置图片大小 8、添加监听事件 9、设置箭头的宽,高,圆角矩形的半径 10、在某个View下/上显示（自动判断上下） 11、模仿ios底部弹窗 引用包 Step 1.在根 build.gradle中添加如下依赖 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Step 2. 在build.gradle中添加如下依赖 dependencies { compile 'com.github.mrgaogang:luckly_popup_window:v1.4.1' } 常用的方法 1、添加数据 添加数据的时候，内容和图片的个数应该相同；如果不需要添加图片的话，那么使用第一个和第四个方法，传递的Bitmap=null即可。 void setData(DataBeans[] strings); void setData(String[] data, int[] images); void setData(String[] data, Bitmap[] images); void setData(List list); 2、设置LucklyPopupWindow的宽度（必须设置） LucklyPopupWindow的宽度（必须设置);设置的单位是dp。 void setWidth(int widthDp); 3、给每一个Item添加分割线 默认的情况是没有分割线的。需要调用以下方法。 //可以自己添加RecyclerView的分割线 addItemDecoration(RecyclerView.ItemDecoration itemDecoration); //使用内部封装好了的分割线，传入的参数分别是：方向，颜色，分割线的宽 addItemDecoration(int oritation, int color, int lineHeight); 4、设置背景颜色 也就是设置三角形和矩形框的背景颜色 setBackgroundColor(int backgroundColor); 5、设置PopupWindow显示时Activity其余部分显示灰色程度 取值范围0.0 setDarkBackgroundDegree(float darkBackgroundDegree); 6、设置字体的颜色和大小 setTextColor(int textColor); setTextSize(int textSize)； 7、设置图片不显示以及设置图片大小 setImageDisable(boolean imageDisable); setImageSize(int widthDp,int heightDp); 8、添加监听事件 void setOnItemClickListener(LucklyPopopWindow.OnItemClickListener onItemClickListener); 9、设置箭头的宽,高,圆角矩形的半径 void setTriangleWidth(int triangleWidth); void setTrianleHeight(int trianleHeight); void setRadius(int radius); 10、在某个View下/上显示（自动判断上下） 注意：这个方法必须最后调用。 void showAtLocation(View parentView, View positionView); 11、模仿ios底部弹窗 mLucklyPopopWindow.showInBottom(getWindow().getDecorView()); LucklyPopouWindow的使用方法。 请见: https://github.com/MrGaoGang/luckly_popup_window 欢迎Star mLucklyPopopWindow = new LucklyPopopWindow(this); //给popupWindow添加数据 mLucklyPopopWindow.setData(getResources().getStringArray(R.array.popupArray), new int[]{R.mipmap.add, R.mipmap.delete, R.mipmap.modify, R.mipmap.update}); mAdapter.setOnItemClickListener(new RecyclerAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //必须设置宽度 mLucklyPopopWindow.setWidth(150); //监听事件 mLucklyPopopWindow.setOnItemClickListener(new LucklyPopopWindow.OnItemClickListener() { @Override public void onItemClick(int position) { Toast.makeText(MainActivity.this, \"点击的位置\" + position, Toast.LENGTH_SHORT).show(); mLucklyPopopWindow.dismiss(); } }); //添加分割线(可选) mLucklyPopopWindow.addItemDecoration(LucklyPopopWindow.VERTICAL,Color.GRAY,1); //设置image不显示(可选) // mLucklyPopopWindow.setImageDisable(true); //设置image的大小(可选) mLucklyPopopWindow.setImageSize(20,20); //显示popopWindow mLucklyPopopWindow.showAtLocation(getWindow().getDecorView(), view); } }); Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/open/vue_template.html":{"url":"article/open/vue_template.html","title":"3. Vue+iView开发基础包","keywords":"","body":"如何使用此lucky_vue_template模板？目录结构 简介:由Vue2.0+Webpack4.0+iView3.0+Vuex+Router搭建的Vue开发模板 如何使用此lucky_vue_template模板？ Github地址(lucky_vue_template) $ npm install -g vue-cli $ vue init mrgaogang/lucky_vue_template my-project $ cd my-project $ npm install $ npm run dev 此脚手架配套vscode插件: 查看插件 项目地址:https://github.com/MrGaoGang/lucky_vue_template 目录结构 |-- lucky_vue |-- babel.config.js//babel配置 |-- index.css//全局css样式 |-- index.html |-- package-lock.json |-- package.json |-- webpack.base.config.js//webpack打包基础配置 |-- webpack.dev.config.js//本地环境打包配置 |-- webpack.prod.config.js//生产打包配置 |-- dist//打包生产目录 | |-- index.html | |-- css | |-- fonts | |-- img | |-- js |-- src |-- App.vue |-- main.js//单页面入口 |-- modules.js |-- components//子组件 | |-- Home.vue |-- plugins//一些插件 | |-- iview.js |-- router//页面路由统一配置 | |-- index.js |-- server//所有服务请求 | |-- fetch.js//封装的网络请求 | |-- index.js | |-- api | | |-- index.js//一些api常量 | |-- modules//请求模块化 | |-- home.js |-- store//状态管理 |-- index.js |-- modules//状态管理模块化 |-- home.js Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/vue/":{"url":"article/vue/","title":"一、Vue","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/vue/Vue父组件使用scoped无法修改子组件样式.html":{"url":"article/vue/Vue父组件使用scoped无法修改子组件样式.html","title":"1. Vue父组件使用scoped无法修改子组件样式","keywords":"","body":"1、部分全局方法2、深选择器 在Vue开发中我们难免会引用各种组件和样式；有时候样式不符合业务需求；则需要对指定的dom进行样式的修改；如果我们在vue中使用了scoped， 则无法在父组件中修改子组件的样式。下面介绍几种修改样式的方法 1、部分全局方法 /**在全局样式中修改要覆盖的样式**/ /**本地样式**/ 2、深选择器 .parentclass >>> .childClass{ } /**或者使用**/ .parentclass /deep/ .childClass{ } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/vue/Vue使用render函数渲染组件.html":{"url":"article/vue/Vue使用render函数渲染组件.html","title":"2. Vue使用render函数渲染组件","keywords":"","body":"一、Render 函数参数详解二、样例：如何给表格组件添加表头筛选此文源码案例:欢迎Star 目录 一、Render 函数参数详解 二、样例：如何给表格组件添加表头筛选 Vue 组件的开发有几种方式：单文件组件，使用 render 函数渲染，使用 template。 在大多数的情况下，Vue 可以使用单文件/template 的方式来创建页面；然而在有一些情况我们需要使用 JavaScript 的编程能力，比如使用第三方框架时，想要自定义某个功能；这个时候就可以使用到 render 函数。 本文将使用 iView table 为例，通过 render 函数添加可搜索的表头筛选。 一、Render 函数参数详解 //一个简单的例子：渲染一个p标签，内容为 '我是p标签的内容' new Vue({ render: createElement => createElement(\"p\", \"我是p标签的内容\") }); 其实 createElement()还有更强大的参数: // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 \"div\", // {Object} // 一个包含模板相关属性的数据对象, // 你可以在 template 中使用这些特性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ \"先写一些文字\", createElement(\"h1\", \"一则头条\"), createElement(MyComponent, { props: { someProp: \"foobar\" } }) ] ); createElement(obj,{},[]) 参数详解: 第一个参数为渲染成哪个节点，接受 String,Object,Function 三种类型； 如果是 String,比如是 div，那么表示此标签将会渲染成 div 标签；String 渲染成普通的 html 标签 如果是 Object，比如是一个 Vue 的组件:TableFilter，那么表示此标签将会渲染一个组件。通常我们在单文件组件中使用的时候是 import {Table} from \"iview\";然后在 template 中引用此标签；而使用 render 则需要使用 createElement 方式创建一个。 如果是 Function，则可以根据自己的业务逻辑动态觉得是渲染成普通的 html 标签还是 Vue 组件。 2) 第二个参数接受 一个对象{}类型的数据。其主要作用类似于组件中对某一个节点设置各种 bind 属性：设置样式 style，设置事件 on，设置类 class，设置自定义的命令，设置普通的 html 属性，设置传递参数 props 等等。 有一点要注意：正如在模板语法中，v-bind:class 和 v-bind:style，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。 { // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: { color: 'red', fontSize: '14px' }, // 普通的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on`，当子组件使用$emit()方式发生，使用on接收 // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // 作用域插槽格式 // { name: props => VNode | Array } scopedSlots: { default: props => createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true } 你会发现使用 render 函数没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：比如 props: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } 第三个参数为列表类型的数据，表示当前渲染组件的有哪些子组件。 render(createElement=> return createElement( 'div', { }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [// '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] )) 注意：子组件中的每一项（VNodes）都必须是唯一的;意味着，下面的 render function 是无效的： render: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 二、样例：如何给表格组件添加表头筛选 效果图: iview的默认table组件不支持 表头输入框筛选，官方地址 此处默认您有了一定的vue开发基础。 套用iview官方的例子： //显示表格的例子 import { Table ,Button,Icon,Modal} from \"iview\"; import Vue from \"vue\"; export default { components: { Table }, data() { return { columns7: [ { title: \"Name\", key: \"name\", //使用render函数自定义列显示效果：文本加粗 render: (h, params) => { return h(\"div\", [//使用render渲染一个div标签 h(Icon, {//使用render渲染一个iview的组件 props: {//传递参数 type: \"person\" } }), h(\"strong\", params.row.name)//文字加粗 ]); } }, { title: \"Age\", key: \"age\" }, { title: \"Address\", key: \"address\" }, { title: \"Action\", key: \"action\", width: 150, align: \"center\", render: (h, params) => { return h(\"div\", [//渲染一个div标签 h( Button,//在div标签下渲染一个iview组件 { props: {//传递参数 type: \"primary\", size: \"small\" }, style: {//设置样式 marginRight: \"5px\" }, on: {//监听$emit事件 click: () => { this.show(params.index); } } }, \"View\" ), h( Button, { props: { type: \"error\", size: \"small\" }, on: { click: () => { this.remove(params.index); } } }, \"Delete\" ) ]); } } ], data6: [ { name: \"John Brown\", age: 18, address: \"New York No. 1 Lake Park\" }, { name: \"Jim Green\", age: 24, address: \"London No. 1 Lake Park\" }, { name: \"Joe Black\", age: 30, address: \"Sydney No. 1 Lake Park\" }, { name: \"Jon Snow\", age: 26, address: \"Ottawa No. 2 Lake Park\" } ] }; }, methods: { show(index) { this.$Modal.info({ title: \"User Info\", content: `Name：${this.data6[index].name}Age：${ this.data6[index].age }Address：${this.data6[index].address}` }); }, remove(index) { this.data6.splice(index, 1); } }, mounted(){ //modal注入 Vue.prototype.$Modal=Modal; } }; 由于table组件表头筛选不支持输入框筛选，那么我们就必须的自己绘制。 思路如下： 找到表头所在的节点 在表头节点后添加一个自定义筛选的div节点； 使用render函数渲染一个下拉输入的单文件组件 mounted(){ //modal注入 Vue.prototype.$Modal=Modal; //等dom元素渲染完成之后渲染筛选 this.$nextTick(()=>{ this.renderHeaderFilter(); }) } methods:{ //添加头部筛选 renderHeaderFilter(){ let allHeader =document.querySelectorAll(\".ivu-table-header .ivu-table-cell\"); console.log(allHeader); allHeader.forEach((element)=>{ let createNew=document.createElement(\"div\"); createNew.classList.add(\"vue-header-filter\"); element.appendChild(createNew); new Vue({ render(h){ return h(TableHeaderFilter,{ props:{} }) } }).$mount(createNew); }) } } 最后实现的效果为: 此文源码案例:欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/vue/Vue中插件开发的四种方式.html":{"url":"article/vue/Vue中插件开发的四种方式.html","title":"3. Vue中插件开发的四种方式","keywords":"","body":"阅读前必读一、添加全局方法和属性二、给Vue实例添加方法和属性三、通过混入 mixin 方法添加一些组件选项;四、添加全局资源：指令，过滤器等为什么要开发插件？ 插件是对Vue功能上的补充，比如可以设置页面全局共享属性，方法等。 目录 阅读前必读 一、添加全局方法和属性 二、给Vue实例添加方法和属性 三、通过混入 mixin 方法添加一些组件选项; 1. 局部混入 2. 全局混入 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 2. 添加过滤器 依据官方文档插件开发说明，插件开发有四种方式。 添加全局方法或者属性; 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 通过全局 mixin 方法添加一些组件选项; 添加全局资源：指令/过滤器/过渡等; 一个库，提供自己的 API，同时提供上面提到的一个或多个功能， 阅读前必读 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象. 比如： export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } 开发插件时，给Vue/Vue实例添加方法或者属性时，建议命名方式使用$开头，这样就不会存在和插件命名冲突。如果冲突了则优先使用组件属性/方法。 一、添加全局方法和属性 作用: 添加全局方法和属性，所有组件都可共享方法和属性，当某个组件更新了共享属性，那么其他组件也会同步更新。并非是组件实例之间的数据共享。 //1:编写组件 export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } //2:声明组件，注入组件 import install from \"./plugins/demo.js\"; Vue.use(install); //3：组件样例 {{ formatNumber }} import Vue from \"vue\"; export default { data() { return { gloablFunc: \"\" }; }, computed: { formatNumber: function() { //调用全局共享方法 return Vue.$globalFunction(this.gloablFunc); } } }; 二、给Vue实例添加方法和属性 方式:使用Vue.prototype的方式给Vue实例添加方法和属性 注意点：使用Vue.prototype的方式添加的属性是不会在各个实例之间数据共享的。 比如A实例修改了某属性，则B实例使用此属性时不会是A修改的值。 //1：组件编写 demo.js export default { install: function(Vue, options) { Vue.prototype.$instanceFunction = function(num) { return 3 * num; }; Vue.prototype.$instanceVar=\"我是实例变量\"; } }; //2：组件声明 main.js import install from \"./plugins/demo.js\"; Vue.use(install); //3:组件使用 Plugins.vue ...省略部分 添加实例方法/属性测试 {{ instanceVar }} mounted(){ console.log(this.$instanceVar); this.instanceVar=this.$instanceVar; //this.instanceVar=this.$instanceFunction(20); } 三、通过混入 mixin 方法添加一些组件选项; 混入mixin作用： 将混入对象的方法/数据对象合并到改组件本身的方法/数据上；若存在同名的方法，则首先调用混入对象，再调用组件本身方法，若存在同名数据对象，则使用组件的数据对象 混入分为局部混入和全局混入，一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。请谨慎使用全局混入，尽可能使用局部混入。 1. 局部混入 此处借用官方的例子选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 若存在同名方法则优先调用混入对象的方法。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 ```js var mixin = { data: function() { return { message: \"hello\", foo: \"abc\" }; }, created: function() { console.log(\"混入对象的钩子被调用\"); }, methods:{ demo1(){ console.log(\"混入demo1\"); }, demo2(){ console.log(\"混入demo2\"); } } }; export default { mixins: [mixin], data: function() { return { message: \"goodbye\", bar: \"def\" }; }, created: function() { console.log('组件钩子被调用') console.log(this.$data); //混入对象的钩子被调用 //组件钩子被调用 // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } }, methods:{ demo1(){ console.log(\"组件demo1\"); } } }; #### 2. 全局混入 为全局Vue实例混入一个created方法，在每一个实例调用本身的created之前都会首先调用混入的created。 **通常我们可以使用全局混入对Vue实例注入统一处理统计**。 ```js // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({ created: function () { //console.log(\"相信我，这个Log会在每一个Vue实例created之前调用\"); var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: 'hello! mrgao' }) // => \"hello!\" 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show等)，Vue 也允许注册自定义指令。 参考官方文档：自定义指令 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 //D.vue export default { data() { return { message: \"我是demo\" }; } }; //main.js Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) 结果为： name: \"demo\" value: \"我是demo\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 2. 添加过滤器 //1：编写过滤器 currency.js const digitsRE = /(\\d{3})(?=\\d)/g export function currency (value, currency, decimals) { value = parseFloat(value) if (!isFinite(value) || (!value && value !== 0)) return '' currency = currency != null ? currency : '$' decimals = decimals != null ? decimals : 2 var stringified = Math.abs(value).toFixed(decimals) var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified var i = _int.length % 3 var head = i > 0 ? (_int.slice(0, i) + (_int.length > 3 ? ',' : '')) : '' var _float = decimals ? stringified.slice(-1 - decimals) : '' var sign = value 单价:{{ product.price | currency }} 上述已经简单讲解了Vue插件开发的四种方式，最后一种方式，也就是将上述四种组合在一个install方法中即可。 文章实例请见：examples目录。 欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "},"article/other/vscode.html":{"url":"article/other/vscode.html","title":"VsCode插件开发","keywords":"","body":"一、环境搭建二、package.json 配置三、contributes介绍四、常用 API五、环境 简介：本文将会教会大家如何一步步开发Vscode插件。 插件地址 luck_npm 欢迎star 此插件的主要功能是方面使用 npm install,npm run dev,npm run build 命令；搭配 vue 脚手架 Vue+webpack+vuex+router更加舒适哦 效果图： 一、环境搭建 1、npm install -g yo generator-code 安装脚手架; 2、yo code 创建项目 本人选择的是：javascript 创建好之后系统会自动生成一个 package.json 和 extension.js 文件； 二、package.json 配置 { \"name\": \"lucky-npm\", //插件名称 \"displayName\": \"lucky npm\", \"description\": \"\", \"version\": \"1.0.1\", \"publisher\": \"mrgao\", \"engines\": { \"vscode\": \"^1.32.0\" }, \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/MrGaoGang/lucky_start.git\" }, \"categories\": [ //分类 \"Other\" ], \"icon\": \"icon/logo.png\", //logo \"activationEvents\": [ //激活方式 \"workspaceContains:package.json\", \"onCommand:lucky.gao.extension.install\", \"onCommand:lucky.gao.extension.start_dev\", \"onCommand:lucky.gao.extension.build_pro\" ], \"main\": \"./extension.js\", //入口文件 \"contributes\": { \"snippets\": [ //自定义一些代码模板（可以尝试输入fetch） { \"language\": \"javascript\", \"path\": \"./src/snippet/snippet.json\" } ], \"views\": { //视图 \"explorer\": [ { //在资源管理器中的视图，id为mrgao_luckys，名字为LUCKY NPM \"id\": \"mrgao_luckys\", \"name\": \"LUCKY NPM\" } ] }, \"commands\": [ //有哪些命令 { \"command\": \"lucky.gao.extension.install\", \"title\": \"安装依赖(install)\" }, { \"command\": \"lucky.gao.extension.start_dev\", \"title\": \"启动测试环境(dev)\" }, { \"command\": \"lucky.gao.extension.build_pro\", \"title\": \"构建生产版本(pro)\" } ], \"menus\": { //菜单，是否右键显示菜单，其中group为分类, \"editor/context\": [ { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.install\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.start_dev\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.build_pro\", \"group\": \"6_luck\" } ] } }, \"scripts\": { \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" }, \"devDependencies\": { \"typescript\": \"^3.3.1\", \"vscode\": \"^1.1.28\", \"eslint\": \"^5.13.0\", \"@types/node\": \"^10.12.21\", \"@types/mocha\": \"^2.2.42\" } } 1. activationEvents 介绍 激活插件的方式 onLanguage 激活 发出此激活事件，只要解析为某种语言的文件被打开，就会激活感兴趣的扩展。 \"activationEvents\"：[ \" onLanguage：python \" ] 可以使用数组中的单独 onLanguage 条目声明多种语言 activationEvents。 \"activationEvents\"：[ \" onLanguage：json \", \" onLanguage：markdown \", \" onLanguage：typescript \" ] onCommand 加载方式 发出此激活事件，并且只要调用命令，就会激活当前扩展： \" activationEvents \"：[ \" onCommand：extension.sayHello \" ] onDebug 加载方式 并在启动调试会话之前激活当前扩展： \" activationEvents \"：[ \" onDebug \" ] onDebugInitialConfigurations onDebugResolve 这是两个更细粒度的 onDebug 激活事件： onDebugInitialConfigurations 在调用 provideDebugConfigurations 方法之前触发 DebugConfigurationProvider。 onDebugResolve:type 在调用指定类型的 resolveDebugConfiguration 方法之前触发 DebugConfigurationProvider。 经验法则：如果调试扩展的激活是轻量级的，请使用 onDebug。如果它是重量级的，则使用 onDebugInitialConfigurations 和/或 onDebugResolve 取决于是否 DebugConfigurationProvider 实施相应的方法 provideDebugConfigurations 和/或 resolveDebugConfiguration。有关这些方法的更多详细信息，请参阅使用 DebugConfigurationProvider。 workspaceContains 激活方式 每当打开文件夹并且文件夹包含至少一个与 模式匹配的文件时，就会激活此激活事件并激活当前扩展。 \" activationEvents \"：[ \" workspaceContains：** /。editorconfig \" ] onFileSystem 激活方式 发出此激活事件，只要读取特定方案中的文件或文件夹，就会激活感兴趣的扩展。这通常是 file-scheme，但是对于自定义文件系统提供程序，有更多的方案可以实现，例如 ftp 或 ssh。 \" activationEvents \"：[ \" onFileSystem：sftp \" ] onView 激活方式 发出此激活事件，只要展开指定 ID 的视图，就会激活当前扩展： \" activationEvents \"：[ \" onView：nodeDependencies \" ] onUri 激活方式 发出此激活事件，只要打开该扩展的系统范围的 Uri，就会激活感兴趣的扩展。Uri 计划固定为 vscode 或 vscode-insiders。Uri 权限必须是扩展的标识符。Uri 的其余部分是任意的。 \" activationEvents \"：[ \" onUri \" ] 如果 vscode.git 扩展名定义 onUri 为激活事件，则会在以下任何一个 Uris 中打开它： vscode://vscode.git/init vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git vscode-insiders://vscode.git/init （对于 VS Code Insiders） onWebviewPanel 激活方式 每当 VS Code 需要使用匹配恢复 webview 时，将发出此激活事件并激活当前扩展 viewType。 例如，onWebviewPanel 的声明如下： \" activationEvents \"：[ \" onWebviewPanel：catCoding \" ] 当 VS Code 需要使用 viewType 恢复 webview 时，将导致扩展被激活：catCoding。viewType 在调用中设置 window.createWebviewPanel，您需要有另一个激活事件（例如，onCommand）来初始激活您的扩展并创建 webview。 * 激活方式 该*激活事件发出后，每当 VS 代码启动感兴趣的扩展将被激活。为确保良好的最终用户体验，请仅在您的用户使用其他激活事件组合时才在扩展中使用此激活事件。 \" activationEvents \"：[ \" * \" ] 三、contributes介绍 详情请见 contributes介绍 四、常用 API 这里主要介绍一下 extension 中的一些常用命令。官方 API 请见: vscode api 1. 命令 命令注册 //注册命令 vscode.commands.registerCommand('lucky.hello', () => { }); //注册之后必须在package.json中配置: { \"contributes\": { \"commands\": [{ \"command\": \"lucky.hello\", \"title\": \"Hello World\" }] } } // 命令执行 //vscode.open为vscode自带命令（也可以使用自己的命令），可以用来打开一个页面 vscode.commands.executeCommand( \"vscode.open\", vscode.Uri.parse(`https://code.visualstudio.com/updates/`) ); 获取所有命令 vscode.commands.getCommands(false); //会返回所有命令 接收一个参数:是否显示系统自带的内部命令,此处Wiefalse 2. 显示 vscode.window.showInformationMessage(\"我是info信息！\"); vscode.window.showErrorMessage(\"我是错误信息！\"); vscode.window.setStatusBarMessage(\"设置状态栏的消息\"); //带回调的提示 vscode.window .showInformationMessage(\"是否要做什么.....？\", \"是\", \"否\", \"不再提示\") .then(result => { if (result === \"是\") { } else if (result === \"不再提示\") { // 其它操作 } }); 3. window 创建一个终端并输入命令 let terminalA = vscode.window.createTerminal({ name: \"我是终端的名字\" }); terminalA.show(true); terminalA.sendText(\"npm start\"); //输入命令 显示一个输入框，让用户输入一个字符串 /** * 打开输入框以询问用户输入。 undefined如果输入框被取消（例如按ESC），则返回值。否则，返回的值将是用户键入的字符串，如果用户没有输入任何内容，则返回值为空，但是单击\"确定\"将输入框解除。 * */ const result = vscode.window.showInputBox({ prompt: \"请输入版本号，\", value: \"默认值\", placeHolder: \"提示\", valueSelection: [len, len] }); result.then(inputValue => { // 是按下ESC键 if (typeof _versionName === \"undefined\") return; //按下enter键 }); 创建树状视图 vscode.window.registerTreeDataProvider('viewId', treeProvider); //viewId对应package.json中id \"contributes\": { \"views\": { \"explorer\": [ { \"id\": \"viewId\", \"name\": \"NPM Tools\" } ] }, } //treeProvider请见此插件源码。 打开文档 vscode.workspace.openTextDocument(vscode.Uri.file(\"文件路径)).then( document => vscode.window.showTextDocument(document) ) 五、环境 vscode.env.appName //当前编辑器的名称 vscode.env.appRoot //打开的根目录 vscode.env.language //用户的语言环境 插件地址 欢迎star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-26 22:05:38 "}}