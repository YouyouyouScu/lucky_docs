{"./":{"url":"./","title":"简介","keywords":"","body":"我的开源项目移动图表库oView其他 是否感谢大家来到我的个人博客，俗话说“好记性不如烂笔头”，在互联网高速发展的今天，主动学习成为一个必备技能。个人主要从事Mendix，Vue，Android开发的相关工作，由于最近工作的原因Android接触较少，请大家见谅。 此文主要分为六大板块，分别介绍了个人的一些开源工具，以及Vue,React,Javascript,Mendix等开发；同时提供了一些常用插件开发技巧和开发中资源的收集和整理。 我的开源项目 1. luckly_recyclerview 2. luckly_popup_window 3. Vue+iView开发基础包 4. Vue移动图表库oView 移动图表库oView 1. 快速开始 2. 图表Chart 3. 图表构建 饼状图 柱状图 折线图 雷达图 散点图和气泡图 面积图 图表平移/缩放 一、Vue 1. Vue父组件使用scoped无法修改子组件样式 2. Vue使用render函数渲染组件 3. Vue中插件开发的四种方式 4. Vue路由变化页面没有刷新 二、React 1. React状态管理框架Redux使用 2. Redux中间件详解 3. Redux异步Action方案 4. Mobx异步Action方案 5. React中使用bind函数和箭头函数效率比较 三、JavaScript 1. 读书笔记：你不知道的Javascript上 2. 读书笔记：你不知道的Javascript中 3. 读书笔记：你不知道的Javascript下 4. new A()和A()的区别 5. Javascript的变量提升和函数提升 6. Javascript对闭包的理解 7. 对Object.create和类式继承的理解 8. Object.create()和New的区别 9. Javascript柯里化和偏函数实现 10. Javascript中this绑定详解 11. JavaScript中改变this指向有几种方式 12. Javascript的call和apply和bind方法 13. Javascript的bind的polyfill的理解 14. Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6 15. Javascript寄生式组合继承详解 16. JavaScript我必须知道的系列 四、轻量化平台Mendix 1. Mendix环境搭建 2. Mendix使用Java 3. 组件开发 1) 环境准备 2) 开发组件之注意事项 3) Vue开发Mendix组件模板 4) 组件进阶-详细API 5) 组件进阶-常用API 4. Mendix后台程序环境搭建 5. 如何使用Mendix创建REST服务 6. 使用Java创建Rest服务 7. Mendix教程（11篇文章） 五、Android 其他 VsCode插件开发 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-27 23:03:00 "},"article/open/luckly_recyclerview.html":{"url":"article/open/luckly_recyclerview.html","title":"1. luckly_recyclerview","keywords":"","body":"一、部分方法介绍9、设置上拉加载和下拉刷新在不同的状态10、设置是否空白视图和错误视图点击刷新11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦)12、 局部刷新二、如何实现分组1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP);2、重写Adapter继承基类BaseGroupAdapter3、常用的几个方法三、具体如何使用请看例子 简介：使用RecyclerView封装headerview,footerView,并实现上拉加载更多，下拉刷新，分组功能(添加上拉加载和下拉刷新设置背景) 界面可能有点丑，&#x1F601;，但是是为了展示所有效果，请大家见谅。（所有东西都是可自己设置的哦）&#x1F60A; 效果图： 如何获取: 第一步：在项目的build.gradle中添加 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 第二步：添加依赖 dependencies { compile 'com.github.mrgaogang:luckly_recyclerview:v2.3.0' } 目录 一、部分方法介绍 1、设置加载更多的监听事件 2、设置下拉刷新监听事件 3、添加分割线 4、添加错误视图 5、添加空视图 6、添加headerView 7、设置下拉刷新进度条的颜色和字体的颜色 8、设置监听事件 9、设置上拉加载和下拉刷新在不同的状态 10、设置是否空白视图和错误视图点击刷新 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 12、 局部刷新 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 3、常用的几个方法 三、具体如何使用请看例子 一、部分方法介绍 1、设置加载更多的监听事件 mLRecyclerView.setLoadMoreListener(this); 并重写onLoadMore()方法。 2、设置下拉刷新监听事件 mLRecyclerView.setOnRefreshListener(this); 并重写onRefresh()方法。 3、添加分割线 已经封装好了线性布局的分割线和网格式布局的分割线、流式布局的分割线。 //线性布局 mLRecyclerView.addLinearDivider(LRecyclerView.VERTICAL_LIST); //网格式布局 mLRecyclerView.addGridDivider(); //可以指定颜色和宽度 addGridDivider(int color, int dividerHeight) addLinearDivider(int oritation, int color, int lineWidth) 4、添加错误视图 当网络连接失败等情况的时候，需要显示错误视图。 //添加错误的View mLRecyclerView.setErrorView(R.layout.error_view); //添加错误的View View error = LayoutInflater.from(this).inflate(R.layout.view_error, null, false); mLRecyclerView.setErrorView(error); 使用getErrorView()得到错误视图。 5、添加空视图 当数据为空的时候，需要显示。 //添加空的View mLRecyclerView.setEmptyView(R.layout.empty_view); //添加空的View View empty = LayoutInflater.from(this).inflate(R.layout.view_empty, null, false); mLRecyclerView.setEmptyView(error); 使用getErrorView()得到空视图。 6、添加headerView //添加headerView mLRecyclerView.addHeaderView(R.layout.header_view); //添加headerView，需要设置父类为mLRecyclerView View headerView = LayoutInflater.from(this).inflate(R.layout.header_view, mLRecyclerView, false); mLRecyclerView.addHeaderView(headerView); //得到所有headerView视图。 List getHeaderViews(); //得到所有headerView的个数。 int getHeaderViewCount(); 7、设置下拉刷新进度条的颜色和字体的颜色 //改变下方加载进度的字体颜色 mLRecyclerView.setLoadingTextColor(Color.BLUE); //改变下方加载进度条的颜色 mLRecyclerView.setLoadingProgressColor(Color.BLUE); //修改下拉刷新颜色 mLRecyclerView.setRefreshColor(getResources().getColor(R.color.colorAccent)); 8、设置监听事件 //设置点击事件，注意此处返回的position是不包括headerView和不包括下拉加载的视图的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(int position) { //position为数据的位置 Log.i(TAG,\"点击--->\"+position); } @Override public void onItemLongClick(int position) { Log.i(TAG,\"长按--->\"+position); } }); 9、设置上拉加载和下拉刷新在不同的状态 @Override public void onLoadMore() { //设置处于正在加载状态 mLRecyclerView.setLoading(); new Handler().postDelayed(new Runnable() { @Override public void run() { int count = dataAdapter.getItemCount() + 1; if (count strings = new ArrayList<>(); for (int i = count - 1; i @Override public void onRefresh() { mLRecyclerView.setRefreshEnable(true); new Handler().postDelayed(new Runnable() { @Override public void run() { dataAdapter.clearAll(); List strings = new ArrayList<>(); for (int i = 0; i 10、设置是否空白视图和错误视图点击刷新 mLRecyclerView.setOnClickEmptyOrErrorToRefresh(true); 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 注意: 如果在初始化的时候 直接设置了背景图片可不用刷新adapter。 如果通过网络获取到背景图片之后可以使用如下方法设置背景，但是需要添加一步：notifyItemChanged() //设置下拉刷新的背景图片（可放广告图片哦） mLRecyclerView.setRefreshBackground(getResources().getDrawable(R.drawable.headerback)); //设置上拉加载部分设置背景图片（也可放广告哦） mLRecyclerView.setFooterBackground(getResources().getDrawable(R.drawable.footerback)); //如果通过网络获取的footer图片，则需要调用以下：（如果是设置刷新部分的背景直接调用setRefreshBackground） mLRecyclerView.getOriginalRecyclerView().getAdapter() .notifyItemChanged(mLRecyclerView.getOriginalRecyclerView().getAdapter().getItemCount() - 1); 12、 局部刷新 注意：使用局部刷新时要加上offset /* * 关于position: * 1、在自定义Adapter的时候 position是自己定义的数据0-length-1 * * * */ //设置点击事件，注意此处返回的position是不包括headerView 不包括下拉刷新的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //此处返回的position为数据的position，不包括 添加的头部和下拉刷新 Log.i(TAG, \"点击--->\" + position); //在进行局部刷新的时候 一定要记得加上offsetcount,偏移量；使用局部刷新记得notifyItemChanged第二个参数不要为空 dataAdapter.notifyItemChanged(position+mLRecyclerView.getOffsetCount(), \">>>>>>刷新\"); } @Override public void onItemLongClick(View view, int position) { TextView textView = (TextView) view.findViewById(R.id.item); textView.setText(\"长按\" + position); Log.i(TAG, \"长按--->\" + position); } }); 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 需要重写的几个方法： /** * 第一层的数量 * * @return */ public abstract int getParentCount(); /** * 每一个parent下的child的数量 * * @param parentPosition * @return */ public abstract int getChildCountForParent(int parentPosition); public abstract A onCreateParentViewHolder(ViewGroup parent, int viewType); public abstract B onCreateChildViewHolder(ViewGroup parent, int viewType); public abstract void onBindParentViewHolder(A holder, int position); /** * 分别是hoder,parent的位置（全局的位置） * child在parent中的index(不是position) * * @param holder * @param parentPosition * @param childIndexForParent */ public abstract void onBindChildViewHolder(B holder, int parentPosition, int childIndexForParent); 在使用点击事件的时候要注意判断是否为Parent： luckRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View rootView, int position) { if (mGroupAdapter.isParentView(position)){ mGroupAdapter.showChild(rootView); }else { Toast.makeText(getApplicationContext(),\"点击了第\"+mGroupAdapter.getParentIndexFromChild(position)+\"个parent的\"+mGroupAdapter.getChildIndexForParent(position),Toast.LENGTH_SHORT).show(); } } @Override public void onItemLongClick(View rootView, int position) { } }); 3、常用的几个方法 1、获取child在parent下的index mGroupAdapter.getChildIndexForParent(position); 2、获取parent的index mGroupAdapter.getParentIndexFromChild(position); 3、判断当前position是否为parentView mGroupAdapter.isParentView(position); 三、具体如何使用请看例子 LucklyRecyclerView 欢迎关注我的微信公众号： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/open/luckly_popup_window.html":{"url":"article/open/luckly_popup_window.html","title":"2. luckly_popup_window","keywords":"","body":"引用包 常用的方法1、添加数据2、设置LucklyPopupWindow的宽度（必须设置）3、给每一个Item添加分割线4、设置背景颜色5、设置PopupWindow显示时Activity其余部分显示灰色程度6、设置字体的颜色和大小7、设置图片不显示以及设置图片大小8、添加监听事件9、设置箭头的宽,高,圆角矩形的半径10、在某个View下/上显示（自动判断上下）11、模仿ios底部弹窗LucklyPopouWindow的使用方法。 简介：Android开发使用PupopWindow在指定View的上下左右动态显示菜单列表，模仿IOS底部弹窗列表。 欢迎大家Star&#x1F62F; Github地址 PupopWindow动态获取显示的位置，并添加指示箭头 效果图 目录: 1、添加数据 2、设置LucklyPopupWindow的宽度（必须设置） 3、给每一个Item添加分割线 4、设置背景颜色 5、设置PopupWindow显示时Activity其余部分显示灰色程度 6、设置字体的颜色和大小 7、设置图片不显示以及设置图片大小 8、添加监听事件 9、设置箭头的宽,高,圆角矩形的半径 10、在某个View下/上显示（自动判断上下） 11、模仿ios底部弹窗 引用包 Step 1.在根 build.gradle中添加如下依赖 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Step 2. 在build.gradle中添加如下依赖 dependencies { compile 'com.github.mrgaogang:luckly_popup_window:v1.4.1' } 常用的方法 1、添加数据 添加数据的时候，内容和图片的个数应该相同；如果不需要添加图片的话，那么使用第一个和第四个方法，传递的Bitmap=null即可。 void setData(DataBeans[] strings); void setData(String[] data, int[] images); void setData(String[] data, Bitmap[] images); void setData(List list); 2、设置LucklyPopupWindow的宽度（必须设置） LucklyPopupWindow的宽度（必须设置);设置的单位是dp。 void setWidth(int widthDp); 3、给每一个Item添加分割线 默认的情况是没有分割线的。需要调用以下方法。 //可以自己添加RecyclerView的分割线 addItemDecoration(RecyclerView.ItemDecoration itemDecoration); //使用内部封装好了的分割线，传入的参数分别是：方向，颜色，分割线的宽 addItemDecoration(int oritation, int color, int lineHeight); 4、设置背景颜色 也就是设置三角形和矩形框的背景颜色 setBackgroundColor(int backgroundColor); 5、设置PopupWindow显示时Activity其余部分显示灰色程度 取值范围0.0 setDarkBackgroundDegree(float darkBackgroundDegree); 6、设置字体的颜色和大小 setTextColor(int textColor); setTextSize(int textSize)； 7、设置图片不显示以及设置图片大小 setImageDisable(boolean imageDisable); setImageSize(int widthDp,int heightDp); 8、添加监听事件 void setOnItemClickListener(LucklyPopopWindow.OnItemClickListener onItemClickListener); 9、设置箭头的宽,高,圆角矩形的半径 void setTriangleWidth(int triangleWidth); void setTrianleHeight(int trianleHeight); void setRadius(int radius); 10、在某个View下/上显示（自动判断上下） 注意：这个方法必须最后调用。 void showAtLocation(View parentView, View positionView); 11、模仿ios底部弹窗 mLucklyPopopWindow.showInBottom(getWindow().getDecorView()); LucklyPopouWindow的使用方法。 请见: https://github.com/MrGaoGang/luckly_popup_window 欢迎Star mLucklyPopopWindow = new LucklyPopopWindow(this); //给popupWindow添加数据 mLucklyPopopWindow.setData(getResources().getStringArray(R.array.popupArray), new int[]{R.mipmap.add, R.mipmap.delete, R.mipmap.modify, R.mipmap.update}); mAdapter.setOnItemClickListener(new RecyclerAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //必须设置宽度 mLucklyPopopWindow.setWidth(150); //监听事件 mLucklyPopopWindow.setOnItemClickListener(new LucklyPopopWindow.OnItemClickListener() { @Override public void onItemClick(int position) { Toast.makeText(MainActivity.this, \"点击的位置\" + position, Toast.LENGTH_SHORT).show(); mLucklyPopopWindow.dismiss(); } }); //添加分割线(可选) mLucklyPopopWindow.addItemDecoration(LucklyPopopWindow.VERTICAL,Color.GRAY,1); //设置image不显示(可选) // mLucklyPopopWindow.setImageDisable(true); //设置image的大小(可选) mLucklyPopopWindow.setImageSize(20,20); //显示popopWindow mLucklyPopopWindow.showAtLocation(getWindow().getDecorView(), view); } }); Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/open/vue_template.html":{"url":"article/open/vue_template.html","title":"3. Vue+iView开发基础包","keywords":"","body":"如何使用此lucky_vue_template模板？目录结构 简介:由Vue2.0+Webpack4.0+iView3.0+Vuex+Router搭建的Vue开发模板 如何使用此lucky_vue_template模板？ Github地址(lucky_vue_template) $ npm install -g vue-cli $ vue init mrgaogang/lucky_vue_template my-project $ cd my-project $ npm install $ npm run dev 此脚手架配套vscode插件: 查看插件 项目地址:https://github.com/MrGaoGang/lucky_vue_template 目录结构 |-- lucky_vue |-- babel.config.js//babel配置 |-- index.css//全局css样式 |-- index.html |-- package-lock.json |-- package.json |-- webpack.base.config.js//webpack打包基础配置 |-- webpack.dev.config.js//本地环境打包配置 |-- webpack.prod.config.js//生产打包配置 |-- dist//打包生产目录 | |-- index.html | |-- css | |-- fonts | |-- img | |-- js |-- src |-- App.vue |-- main.js//单页面入口 |-- modules.js |-- components//子组件 | |-- Home.vue |-- plugins//一些插件 | |-- iview.js |-- router//页面路由统一配置 | |-- index.js |-- server//所有服务请求 | |-- fetch.js//封装的网络请求 | |-- index.js | |-- api | | |-- index.js//一些api常量 | |-- modules//请求模块化 | |-- home.js |-- store//状态管理 |-- index.js |-- modules//状态管理模块化 |-- home.js Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/":{"url":"article/oview/","title":"1. 快速开始","keywords":"","body":"NPM安装oView特性 oView Vue.js移动端图表库 oView是基于 蚂蚁金服F2图表库的二次封装，以便于Vue.js开发者在移动端和PC端更好进行图表的展示。 NPM安装 npm install oview --save 推荐使用npm安装，享受安装依赖包带来的便利，同时也建议使用个人开发Vue项目使用的 Vue SPA 模板;当然Vue官方提供的cli模板固然优秀，但是由于加重了学习成本，所以对有webpack开发经验的同学使用此模板，可尽快入手。 oView特性 1、oview支持哪些图？ 目前oview支持：柱状图，饼状图，面积图，散点图，气泡图，面积图，折线图 ，雷达图，自定义图 2、图表配置简单 如果您只需要，配置简单的图形，只需要传递数据，和坐标轴即可。 oview图表色彩鲜艳 色彩主要使用F2官方建议色彩，如需自定义色彩可使用:color=\"yourColors\"传入即可。（后续会详细讲解） Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/Chart.html":{"url":"article/oview/Chart.html","title":"2. 图表Chart","keywords":"","body":"1、oview如何开发一个图表？2、o-chart各个字段介绍data（数据源）col-defs (数据源字段配置)custom-render（自定义渲染图表）legend (图例)tooltip (提示信息)chart-config (图表配置)width/heightbackgroundColorscale 在开发之前，我想您应该知道关于图表的一些简单概念。一般情况下，F2 的图表包含坐标轴（Axis）、几何标记（Geometry）、提示信息（Tooltip）、图例（Legend）等。Axis,Tooltip,Legend等术语作用请见：官方文档 1、oview如何开发一个图表？ 其中由o-chart和o-line/o-pie/等组成。 一个o-chart有且只能有一个图表子节点 2、o-chart各个字段介绍 希望您能静下心来，花5分钟时间简单了解一下，o-chart各个字段的作用。o-chart主要作用是配置图表的公用属性,抽离不同图形公用方法，并根据类型不同，而渲染不同图形。 data（数据源） 是否必须:True 参数类型:Array 描述:图表的数据源 默认：[] col-defs (数据源字段配置) 是否必须:False 参数类型:Object 描述:对上述提供的数据源中每个字段进行配置 默认：{} 一个示例: //以折线图为例 //data部分 normaColConfig: { //对每个字段配置 //正常的折线图每一个字段的配置 value: { tickCount: 5, //坐标点的个数 min: 0 }, date: { type: \"timeCat\", //时间类型 range: [0, 1], tickCount: 3 //坐标点的个数 } }, 详细配置说明 custom-render（自定义渲染图表） 是否必须:False 参数类型:枚举，null, \"prevent\", \"extra\" 选项中的某个 描述:是否自定义渲染图表。 null:不自定义渲染 prevent:完全阻止组件渲染，完全由自己在回调方法中：灌数据，渲染图表等等(一般情况不建议使用此选项); extra: 自己在iview渲染的图表基础上，添加自定义操作。（建议使用此选项） 默认：null 说明：如果 custom-render为prevent或者extra则需要在o-chart部分添加@on-render监听。示例请见：雷达图示例 //onRender的入参为 onRender({ chart }) { } legend (图例) 是否必须:False 参数类型:Object 描述:图例 默认：{disable:true,fieldName:x轴} 说明: 图例分为两个部分 数据字段名称，配置信息, { fieldName:\"\",//数据字段的名称，默认是以X轴显示图例 disable:true,//是否显示图例，如果设置为true，则图例不可显示，若此字段不提供或者为false，则显示图例 ...其他参数 } 其他参数: 图例的配置信息，支持的属性如下： position: String 设置图例的显示位置，可设置的值为：'top'、'right'、'bottom'、'left'，分别表示上、右、下、左。默认为 top。 align: String 当 position 为 'top'，'bottom' 时生效，用于设置水平方向上图例的对齐方式，可设置的值为：'left'、'center'、'right' ，默认为 'left' ，左对齐。 left（默认） center right verticalAlign: String 当 position 为 'left'、'right' 时生效，用于设置垂直方向上图例的对齐方式，可设置的值为：'top'、'middle'、'bottom'，默认为 'middle'，居中对齐。 middle（默认） top bottom itemWidth: Number/'auto' 用于设置每个图例项的宽度，默认为 'auto'，即使用 F2 默认的图例布局计算 itemWidth。如果 itemWidth 为 null，则会根据每个图例项自身的宽度计算，另外用户也可以自己设置 itemWidth 的数值。 showTitle: Boolean 是否显示图例标题，默认值为 false，即不展示。 titleStyle: Object 图例标题的显示样式设置，详见绘图属性。 titleStyle: { textAlign: 'center', // 文本对齐方向，可取值为： start middle end fill: '#404040', // 文本的颜色 fontSize: 12, // 文本大小 fontWeight: 'bold', // 文本粗细 textBaseline: 'top' // 文本基准线，可取 top middle bottom，默认为middle } offsetX: Number 图例 x 方向的整体偏移值，数值类型，数值单位为 'px'，默认值为 0。 offsetY: Number 图例 Y 方向的整体偏移值，数值类型，数值单位为 'px'，默认值为 0。 titleGap: Number 其他详细配置请见:Legend配置 tooltip (提示信息) 是否必须:False 参数类型:Object 描述:提示信息 默认：{disable:true} 说明: 下面列出常用的tooltip配置，在某些情况需要获取到chart实例来进行操作的话，请使用自定义render:custom-render='extra'。tooltip自定义实例 和 tooltip普通使用实例 { disable:true,//是否显示提示信息，如果设置为true，则提示信息不可显示，若此字段不提供或者为false，则显示提示信息 // 其他配置信息 alwaysShow: false, // 当移出触发区域，是否仍显示提示框内容，默认为 false，移出触发区域 tooltip 消失，设置为 true 可以保证一直显示提示框内容 offsetX: 0, // x 方向的偏移 offsetY: 0, // y 方向的偏移 triggerOn: [ 'touchstart', 'touchmove' ], // tooltip 出现的触发行为，可自定义，用法同 legend 的 triggerOn triggerOff: 'touchend', // 消失的触发行为，可自定义 showTitle: false, // 是否展示标题，默认不展示 showCrosshairs: false, // 是否显示辅助线，点图、路径图、线图、面积图默认展示 crosshairsStyle: { stroke: 'rgba(0, 0, 0, 0.25)', lineWidth: 2 }, // 配置辅助线的样式 showTooltipMarker: true, // 是否显示 tooltipMarker tooltipMarkerStyle: { fill: '#fff' // 设置 tooltipMarker 的样式 }, background: { radius: 2, fill: '#1890FF', padding: [ 6, 10 ] }, // tooltip 内容框的背景样式 titleStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'top' }, // tooltip 标题的文本样式配置，showTitle 为 false 时不生效 nameStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'middle' }, // tooltip name 项的文本样式配置 valueStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'middle' }, // tooltip value 项的文本样式配置 showItemMarker: true, // 是否展示每条记录项前面的 marker itemMarkerStyle: { radius: 7, symbol: 'circle', lineWidth: 2, stroke: '#fff' }, // 每条记录项前面的 marker 的样式配置 custom: {Boolean}, // 是否自定义 tooltip 提示框 onShow(obj) { // obj: { x, y, title, items } }, // tooltip 显示时的回调函数 onHide(obj) { // obj: { x, y, title, items } }, // tooltip 隐藏时的回调函数 onChange(obj) { // obj: { x, y, title, items } }, // tooltip 内容发生改变时的回调函数 crosshairsType: {String}, // 辅助线的种类 showXTip: {Boolean}, // 是否展示 X 轴的辅助信息 showYTip: {Boolean}, // 是否展示 Y 轴的辅助信息 xTip: {Object}/{Function}, // X 轴辅助信息的文本样式 yTip: {Object}/{Function, // Y 轴辅助信息的文本样式 xTipBackground: {Object}, // X 轴辅助信息的背景框样式 yTipBackground: {Object}, // Y 轴辅助信息的背景框样式 snap: {Boolean} // 是否将辅助线准确定位至数据点 } chart-config (图表配置) 是否必须:False 参数类型:Object 描述:图表样式的配置，比如给图表添加内外边距(padding: [ 0, 10, 40, 100 ] // 分别设置上、右、下、左边距)，给画布添加边距:appendPadding。所以chart-config应该为:{padding:[ 0, 10, 40, 100 ],appendPadding:[20,10,30,12]} 默认：{} width/height 是否必须:False 参数类型:Integer 描述:图表的宽度和高度 默认：图表宽度，默认为:屏幕宽度；图表高度，默认为:300 backgroundColor 是否必须:False 参数类型:String 描述:图表背景颜色 默认：#ffffff (白色) scale 是否必须:False 参数类型:Object 描述:度量 Scale，是数据空间到图形空间的转换桥梁，负责原始数据到 [0, 1] 区间数值的相互转换工作。针对不同的数据类型对应不同类型的度量。 默认：{} 说明：示例请见面积图 文档详情说明 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart_specific.html":{"url":"article/oview/chart_specific.html","title":"3. 图表构建","keywords":"","body":"position (坐标轴)adjust(数据调整)axis (多个坐标轴具体配置)colors (颜色)colorFieldanimate (动画)chartStyle（图表样式）size（数据图形大小）此文内容：各类图表公用配置属性 阅读此文，大概需要5分钟。相信您已经知晓构建一个图表的基础步骤： 上一篇文章讲述了o-chart的配置，如果您没有查阅图表Chart，请先移步查看。这边文章主要讲述各个图表具体实现配置。目前oview支持的所有图表类型有： 饼状图 柱状图 折线图 雷达图 散点图和气泡图 面积图 下面将对，各类图表公用配置属性进行简单介绍，主要包括:position(坐标轴) , axis(多个坐标轴具体配置) , colors(颜色) , animate(动画),chartStyle(图表样式）, size（数据图形大小） position (坐标轴) 是否必须:True 参数类型:String 说明: 配置x,y坐标轴，示例:position=\"date*value\"，其中date为x轴,value为y轴。饼状图较为特殊，需传position=\"name*percent\"名字和百分比，其中percent为数据结构中必有字段 示例: adjust(数据调整) 是否必须:False 参数类型:Object 默认值:{type:'stack'} 说明:声明几何标记对象的数据调整方式，可用于绘制层叠图、分组图等。支持单一的数据调整方式也支持各种数据调整方式的组合。支持的调整类型包括：'stack', 'dodge' axis (多个坐标轴具体配置) 是否必须:False 参数类型:Array 注意：如使用axis，请必须上fieldName配置项,表示对某个坐标轴的具体配置 说明: 多单个或者多个坐标轴，镜像详细配置,配置坐标轴的文本(label)，轴线(line)，刻度线(tickLine)，网格线(grid)。详细配置文档 示例: //以雷达图具体配置（此例子对两个坐标轴的文本和网格线进行配置） normaAxis: [ { fieldName: \"score\",//注意fieldName为必传项，表示对某个坐标轴的具体配置 label: function label(text, index, total) { if (index === total - 1) { return null; } return { top: true }; }, grid: { lineDash: null, type: \"arc\" // 弧线网格 } }, { fieldName: \"item\", grid: { lineDash: null } } ], colors (颜色) 是否必须:False 参数类型:Array 说明: 默认值为[\"#1890FF\",\"#13C2C2\",\"#2FC25B\",\"#FACC14\",\"#F04864\",\"#8543E0\"]，如需要图表显示为单个颜色，请传入一个值即可 colorField 是否必须:False 参数类型:String 说明: 为哪个坐标轴设置颜色 animate (动画) 是否必须:False 参数类型:Object 说明:给x，y轴设置动画。详细文档 //data部分 animate: { //可以配置动效哦 appear: { animation: \"groupWaveIn\", delay: 500 //延迟500s } }, chartStyle（图表样式） 是否必须:False 参数类型:Object 说明: 为图表设置样式。 示例: size（数据图形大小） 是否必须:False 参数类型:Object 说明:常用于散点图、气泡图。 将数据值映射到图形的大小上的方法。详细文档 注意：fieldName字段为必传项，表示对那个坐标轴的配置。且 不同图形的 size 的含义有所差别： point 图形的 size 影响点的半径大小； line, area, path 中的 size 影响线的粗细； interval 的 size 影响柱状图的宽度。 此处暂时只支持，回调的方式。 示例: { fieldName: \"z\",// callback: function(z) { return [10, 40]; } } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/pie.html":{"url":"article/oview/chart/pie.html","title":"饼状图","keywords":"","body":"一、 饼状图基础构建二、饼状图额外配置coord (坐标系)pieLabel(绘制饼图文本) 饼状图扫码预览 一、 饼状图基础构建 公用配置信息 没错构建一个饼状图就是如此简单，必须提供的数据有:data和position。 如果您需要显示提示信息/图例那么就需要配置:tooltip和:legend。 data的数据结构为:[{name:\"item\",percent:0.3},{name:\"item2\",percent:0.7}] 样例源码 说明: 坐标轴percent为必传项。 公用配置信息已在前文提及，请查阅 二、饼状图额外配置 coord (坐标系) 是否必须:False 参数类型:Object 描述:坐标系 默认：{ coordType: \"polar\",options: {transposed: true // 坐标系翻转}} 说明: 图例分为两个部分 数据字段名称，配置信息, coordType：有两种类型，1：笛卡尔坐标系(rect)；2：极坐标系（polar） options为配置信息，不同的坐标系配置不同。 直角坐标系 属性名 类型 解释 start Object 坐标系的起始点，F2 图表的坐标系原点位于左下角。 end Object 坐标系右上角的画布坐标。 transposed Boolean 是否发生转置，true 表示发生了转置。 isRect Boolean 是否是直角坐标系，直角坐标系下为 true。 极坐标系 属性名 类型 解释 startAngle Number 极坐标的起始角度，弧度制。 endAngle Number 极坐标的结束角度，弧度制。 innerRadius Number 绘制环图时，设置内部空心半径，相对值，0 至 1 范围。 radius Number 设置圆的半径，相对值，0 至 1 范围。 isPolar Boolean 判断是否是极坐标，极坐标下为 true。 transposed Boolean 是否发生转置，true 表示发生了转置。 center Object 极坐标的圆心所在的画布坐标。 circleRadius Number 极坐标的半径值。 pieLabel(绘制饼图文本) 是否必须:False 参数类型:Object 描述:PieLabel 是一个用于绘制饼图文本的插件。详细文档 示例: { sidePadding: 30, activeShape: true, label1: function(data) { //第一个标签 return { text: data.name, fill: \"#343434\", fontWeight: \"bold\" }; }, label2: function(data) { //第二个标签 //如果不需要刻意删除label2 return { text: data.percent * 100 + \"%\", fill: \"#999\" }; }, onClick: function(ev) { //点击之后显示 var data = ev.data; if (data) { ev.chart.guide().clear(); ev.chart.guide().html({ position: [\"50%\", \"50%\"], html: '\\n ' + data.name + '\\n ' + data.percent * 100 + \"%\\n \" }); ev.chart.repaint(); // $('#title').text(data.type); // $('#money').text(data.money); } } }; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/histo.html":{"url":"article/oview/chart/histo.html","title":"柱状图","keywords":"","body":"一、 柱状图基础构建二、柱状图额外配置coord (坐标系) 柱状图扫码预览 一、 柱状图基础构建 普通的柱状图 构建柱状图，必须提供的数据有:data和position。 如果您需要显示提示信息/图例那么就需要配置:tooltip和:legend。 data的数据结构为:[[{ year: \"1951 年\", sales: 38 }, { year: \"1952 年\", sales: 52 }] 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的柱状图，分组柱状图，层叠柱状图，区间柱状图，基础条形图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请查阅样例源码 ，查看具体配置,具体配置信息和作用已在前文和样例中注明，请查阅。 二、柱状图额外配置 公用配置信息 coord (坐标系) 是否必须:False 参数类型:Object 描述:坐标系 默认：{ coordType: \"rect\",options: {transposed: false // 坐标系不翻转}}，默认使用极坐标系的方式 说明: 图例分为两个部分 数据字段名称，配置信息, coordType：有两种类型，1：笛卡尔坐标系(rect)；2：极坐标系（polar） options为配置信息，不同的坐标系配置不同。 直角坐标系 属性名 类型 解释 start Object 坐标系的起始点，F2 图表的坐标系原点位于左下角。 end Object 坐标系右上角的画布坐标。 transposed Boolean 是否发生转置，true 表示发生了转置。 isRect Boolean 是否是直角坐标系，直角坐标系下为 true。 极坐标系 属性名 类型 解释 startAngle Number 极坐标的起始角度，弧度制。 endAngle Number 极坐标的结束角度，弧度制。 innerRadius Number 绘制环图时，设置内部空心半径，相对值，0 至 1 范围。 radius Number 设置圆的半径，相对值，0 至 1 范围。 isPolar Boolean 判断是否是极坐标，极坐标下为 true。 transposed Boolean 是否发生转置，true 表示发生了转置。 center Object 极坐标的圆心所在的画布坐标。 circleRadius Number 极坐标的半径值。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/line.html":{"url":"article/oview/chart/line.html","title":"折线图","keywords":"","body":"一、 折线图基础构建二、折线图额外配置type (显示类型)shape (线段形状)showNulls(是否显示空值)isMutiLine（是否存在多条线段）isArea (区域面积图的配置) 折线图扫码预览 一、 折线图基础构建 光滑的的折线图 这是一个光滑折线图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置，tooltip:显示提示信息, axis:坐标系配置, shape:设置线段类型，shape可选为'line', 'smooth', 'dash' 具体配置，请见下文 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的折线图，光滑的的折线图，带点的折线图，光滑的带点折线图，层叠的带点光滑折线图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请查阅样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、折线图额外配置 公用配置信息 type (显示类型) 是否必须:False 参数类型:枚举['line','point']中的二选一 默认：line 说明:显示类型，以线段显示还是使用带点折线图显示 shape (线段形状) 是否必须:False 参数类型:见下 默认:line 说明:只支持接收一个参数，指定几何图像对象绘制的形状。根据上述设置的type不同，可以设置不同的shape形状 (type)类型 shape 类型 解释 point 'circle', 'hollowCircle', 'rect' 默认为 'circle' line 'line', 'smooth', 'dash' dash：虚线，smooth： 平滑线 showNulls(是否显示空值) 是否必须:False 参数类型:Boolean 默认：False 说明:是否显示空值，如果为True，则折线图遇到空值，则是不连续线段。 isMutiLine（是否存在多条线段） 是否必须:False 参数类型:Boolean 默认：False 说明:是否存在多条线段，如果为True，则是则会显示多条线段，demo请见区域面积图-层叠面积图。 isArea (区域面积图的配置) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示区域面积图 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/radar.html":{"url":"article/oview/chart/radar.html","title":"雷达图","keywords":"","body":"一、 雷达图基础构建二、雷达图额外配置isArea (以区域方式显示)customDefine (是否自定义显示) 雷达图扫码预览 一、 雷达图基础构建 普通的雷达图 这是一个光滑雷达图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置，legend:显示图例, axis:坐标系配置, color-field:对数据中的那个字段显示颜色 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的雷达图，雷达面积图，自定义图标-雷达图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请看样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、雷达图额外配置 公用配置信息 isArea (以区域方式显示) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示为雷达面积图。 customDefine (是否自定义显示) 是否必须:False 参数类型:Boolean 默认：False 说明:是否自定义显示各个图表的logo. Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/point.html":{"url":"article/oview/chart/point.html","title":"散点图和气泡图","keywords":"","body":"一、 散点图基础构建二、散点图额外配置shape(散点图的形状) 散点图扫码预览 一、 散点图基础构建 散点图 这是一个光滑散点图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置， legend:显示图例, axis:坐标系配置, color-field:对数据中的那个字段显示颜色 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有散点图和气泡图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请看样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、散点图额外配置 公用配置信息 shape(散点图的形状) 是否必须:False 参数类型:枚举 ['circle', 'hollowCircle', 'rect' ] 中的一个 默认:circle 说明:只支持接收一个参数，指定几何图像对象绘制的形状 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/area.html":{"url":"article/oview/chart/area.html","title":"面积图","keywords":"","body":"isMutiLine（是否存在多条线段）isArea (区域面积图的配置) 区域面积图扫码预览 如果您仔细查看了，区域面积图和折线图，您会发现，二者其实并无巨大差异，区域面积图是基于折线图进行的改造。主要额外使用到了以下两个属性: isMutiLine（是否存在多条线段） 是否必须:False 参数类型:Boolean 默认：False 说明:是否存在多条线段，如果为True，则是则会显示多条线段，demo请见区域面积图-层叠面积图。 isArea (区域面积图的配置) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示区域面积图 所以，详细配置请见折线图 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/intercation.html":{"url":"article/oview/chart/intercation.html","title":"图表平移/缩放","keywords":"","body":"一、图表是否支持滚动配置(ineraction)二、图表平移滚动条配置 图表交互扫码预览 如果您有图表左右移动端的诉求，请配置 ineraction 和滚动条是否显示 一、图表是否支持滚动配置(ineraction) 散点图平移和缩放 其中重点配置项为:interaction - 接收数据类型: Object或者Array 单个数据格式:{type:'pan',...其他配置} type 所有可取类型值，可以从import {INTERACTION_TYPE} from \"oview\"中获取到（包括以 5 种类型） 饼图选中 柱状图选中 图表平移 图表缩放 图表 swipe 快扫 1. 饼图选中 { \"type\": \"pie-select\", \"startEvent\": { String }, // 触发事件，默认为 tap \"animate\": { Boolean } || { Object }, // 动画配置 \"offset\": { Number }, // 光环偏移距离 \"appendRadius\": { Number }, // 光环大小 \"style\": { Object }, // 光环的样式配置 \"cancelable\": { Boolean }, // 是否允许取消选中，默认值为 true，表示允许 \"onStart\": { Function }, // 事件触发后的回调 \"onEnd\": { Function }, // 事件结束后的回调 \"defaultSelected\": { Object } // 设置默认选中的数据，该属性需要在 chart.render() 之后调用方可生效 } 2. 柱状图选中 { \"type\": \"interval-select\", \"startEvent\": { String }, // 触发事件，默认为 tap 事件 \"selectStyle\": { Object }, // 被选中图形的样式配置 \"unSelectStyle\": { Object }, // 未被选中图形的样式配置 \"selectAxis\": { Boolean }, // 是否高亮坐标轴文本 \"selectAxisStyle\": { Object }, // 坐标轴文本被选中后的样式 \"cancelable\": { Boolean }, // 是否允许取消选中，默认值为 true，表示允许 \"onStart\": { Function }, // 事件触发后的回调 \"onEnd\": { Function }, // 事件结束后的回调 \"mode\": { String }, // 选中策略，默认为 'shape', 即击中柱子才会触发交互 \"defaultSelected\": { Object } // 设置默认选中的数据，该属性需要在 chart.render() 之后调用方可生效 } 3. 图表平移 { \"type\": \"pan\", \"mode\": { String }, // 图表平移的方向，默认为 'x' \"speed\": { number }, // 用于控制分类类型或者 TimeCat 类型数据的平移速度 \"step\": { number }, // 用于控制分类类型或者 TimeCat 类型数据每次平移的数据条数 \"panThreshold\": { Number }, // hammer.js 设置，用于设置触发 pan 事件的最小移动距离 \"pressThreshold\": { Number }, // hammer.js 设置，用于设置触发 press 事件的设置 \"pressTime\": { Number }, // hammer.js 设置，用于设置触发 press 事件的最小时间差 \"limitRange\": { Object }, // 限制范围 \"onStart\": { Function }, // 事件触发后的回调 \"onProcess\": { Function }, // 事件进行中的回调 \"onEnd\": { Function } // 事件结束后的回调 } 3. 图表缩放 { \"type\": \"pinch\", \"mode\": { String }, // 图表平移的方向，默认为 'x' \"sensitivity\": { Number }, // 用于控制分类类型数据的缩放灵敏度 \"minScale\": { Number }, // 缩小的最小倍数 \"maxScale\": { Number }, // 放大的最大倍数 \"onStart\": { Function }, // 事件触发后的回调 \"onProcess\": { Function }, // 事件进行中的回调 \"onEnd\": { Function }, // 事件结束后的回调 \"pressThreshold\": 9, // hammer.js 设置，用于设置触发 press 事件的设置 \"pressTime\": 251 // hammer.js 设置，用于设置触发 press 事件的最小时间差 } 4. 图表快扫 { \"type\": \"swipe\", \"speed\": { number }, // 用于控制分类类型或者 TimeCat 类型数据的平移速度 \"threshold\": { Number }, // hammer.js 设置，用于设置触发 swipe 事件的最小移动距离 \"velocity\": { Number }, // hammer.js 设置，用于设置 swipe 的最小速度 \"limitRange\": { Object }, // 限制范围 \"onStart\": { Function }, // 事件触发后的回调 \"onProcess\": { Function }, // 事件进行中的回调 \"onEnd\": { Function } // 事件结束后的回调 } 详细 Interaction 配置请见 二、图表平移滚动条配置 1、是否显示横向滚动条和纵向滚动条(快捷方式配置) 您可以使用 show-scroll-x 或者 show-scroll-y 快捷方式配置是否显示横向滚动条和纵向滚动条 2、是否显示横向滚动条和纵向滚动条(详细配置) 当快捷方式配置无法满足您的需求时，就需要使用详细配置了 scrollBarConfig 的配置如下 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-27 23:01:58 "},"article/vue/":{"url":"article/vue/","title":"一、Vue","keywords":"","body":"目录 1. Vue父组件使用scoped无法修改子组件样式 2. Vue使用render函数渲染组件 3. Vue中插件开发的四种方式 4. Vue路由变化页面没有刷新 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:37:32 "},"article/vue/Vue父组件使用scoped无法修改子组件样式.html":{"url":"article/vue/Vue父组件使用scoped无法修改子组件样式.html","title":"1. Vue父组件使用scoped无法修改子组件样式","keywords":"","body":"1、部分全局方法2、深选择器 在Vue开发中我们难免会引用各种组件和样式；有时候样式不符合业务需求；则需要对指定的dom进行样式的修改；如果我们在vue中使用了scoped， 则无法在父组件中修改子组件的样式。下面介绍几种修改样式的方法 1、部分全局方法 /**在全局样式中修改要覆盖的样式**/ /**本地样式**/ 2、深选择器 .parentclass >>> .childClass{ } /**或者使用**/ .parentclass /deep/ .childClass{ } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue使用render函数渲染组件.html":{"url":"article/vue/Vue使用render函数渲染组件.html","title":"2. Vue使用render函数渲染组件","keywords":"","body":"一、Render 函数参数详解二、样例：如何给表格组件添加表头筛选此文源码案例:欢迎Star 目录 一、Render 函数参数详解 二、样例：如何给表格组件添加表头筛选 Vue 组件的开发有几种方式：单文件组件，使用 render 函数渲染，使用 template。 在大多数的情况下，Vue 可以使用单文件/template 的方式来创建页面；然而在有一些情况我们需要使用 JavaScript 的编程能力，比如使用第三方框架时，想要自定义某个功能；这个时候就可以使用到 render 函数。 本文将使用 iView table 为例，通过 render 函数添加可搜索的表头筛选。 一、Render 函数参数详解 //一个简单的例子：渲染一个p标签，内容为 '我是p标签的内容' new Vue({ render: createElement => createElement(\"p\", \"我是p标签的内容\") }); 其实 createElement()还有更强大的参数: // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 \"div\", // {Object} // 一个包含模板相关属性的数据对象, // 你可以在 template 中使用这些特性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ \"先写一些文字\", createElement(\"h1\", \"一则头条\"), createElement(MyComponent, { props: { someProp: \"foobar\" } }) ] ); createElement(obj,{},[]) 参数详解: 第一个参数为渲染成哪个节点，接受 String,Object,Function 三种类型； 如果是 String,比如是 div，那么表示此标签将会渲染成 div 标签；String 渲染成普通的 html 标签 如果是 Object，比如是一个 Vue 的组件:TableFilter，那么表示此标签将会渲染一个组件。通常我们在单文件组件中使用的时候是 import {Table} from \"iview\";然后在 template 中引用此标签；而使用 render 则需要使用 createElement 方式创建一个。 如果是 Function，则可以根据自己的业务逻辑动态觉得是渲染成普通的 html 标签还是 Vue 组件。 2) 第二个参数接受 一个对象{}类型的数据。其主要作用类似于组件中对某一个节点设置各种 bind 属性：设置样式 style，设置事件 on，设置类 class，设置自定义的命令，设置普通的 html 属性，设置传递参数 props 等等。 有一点要注意：正如在模板语法中，v-bind:class 和 v-bind:style，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。 { // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: { color: 'red', fontSize: '14px' }, // 普通的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on`，当子组件使用$emit()方式发生，使用on接收 // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // 作用域插槽格式 // { name: props => VNode | Array } scopedSlots: { default: props => createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true } 你会发现使用 render 函数没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：比如 props: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } 第三个参数为列表类型的数据，表示当前渲染组件的有哪些子组件。 render(createElement=> return createElement( 'div', { }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [// '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] )) 注意：子组件中的每一项（VNodes）都必须是唯一的;意味着，下面的 render function 是无效的： render: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 二、样例：如何给表格组件添加表头筛选 效果图: iview的默认table组件不支持 表头输入框筛选，官方地址 此处默认您有了一定的vue开发基础。 套用iview官方的例子： //显示表格的例子 import { Table ,Button,Icon,Modal} from \"iview\"; import Vue from \"vue\"; export default { components: { Table }, data() { return { columns7: [ { title: \"Name\", key: \"name\", //使用render函数自定义列显示效果：文本加粗 render: (h, params) => { return h(\"div\", [//使用render渲染一个div标签 h(Icon, {//使用render渲染一个iview的组件 props: {//传递参数 type: \"person\" } }), h(\"strong\", params.row.name)//文字加粗 ]); } }, { title: \"Age\", key: \"age\" }, { title: \"Address\", key: \"address\" }, { title: \"Action\", key: \"action\", width: 150, align: \"center\", render: (h, params) => { return h(\"div\", [//渲染一个div标签 h( Button,//在div标签下渲染一个iview组件 { props: {//传递参数 type: \"primary\", size: \"small\" }, style: {//设置样式 marginRight: \"5px\" }, on: {//监听$emit事件 click: () => { this.show(params.index); } } }, \"View\" ), h( Button, { props: { type: \"error\", size: \"small\" }, on: { click: () => { this.remove(params.index); } } }, \"Delete\" ) ]); } } ], data6: [ { name: \"John Brown\", age: 18, address: \"New York No. 1 Lake Park\" }, { name: \"Jim Green\", age: 24, address: \"London No. 1 Lake Park\" }, { name: \"Joe Black\", age: 30, address: \"Sydney No. 1 Lake Park\" }, { name: \"Jon Snow\", age: 26, address: \"Ottawa No. 2 Lake Park\" } ] }; }, methods: { show(index) { this.$Modal.info({ title: \"User Info\", content: `Name：${this.data6[index].name}Age：${ this.data6[index].age }Address：${this.data6[index].address}` }); }, remove(index) { this.data6.splice(index, 1); } }, mounted(){ //modal注入 Vue.prototype.$Modal=Modal; } }; 由于table组件表头筛选不支持输入框筛选，那么我们就必须的自己绘制。 思路如下： 找到表头所在的节点 在表头节点后添加一个自定义筛选的div节点； 使用render函数渲染一个下拉输入的单文件组件 mounted(){ //modal注入 Vue.prototype.$Modal=Modal; //等dom元素渲染完成之后渲染筛选 this.$nextTick(()=>{ this.renderHeaderFilter(); }) } methods:{ //添加头部筛选 renderHeaderFilter(){ let allHeader =document.querySelectorAll(\".ivu-table-header .ivu-table-cell\"); console.log(allHeader); allHeader.forEach((element)=>{ let createNew=document.createElement(\"div\"); createNew.classList.add(\"vue-header-filter\"); element.appendChild(createNew); new Vue({ render(h){ return h(TableHeaderFilter,{ props:{} }) } }).$mount(createNew); }) } } 最后实现的效果为: 此文源码案例:欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue中插件开发的四种方式.html":{"url":"article/vue/Vue中插件开发的四种方式.html","title":"3. Vue中插件开发的四种方式","keywords":"","body":"阅读前必读一、添加全局方法和属性二、给Vue实例添加方法和属性三、通过混入 mixin 方法添加一些组件选项;四、添加全局资源：指令，过滤器等为什么要开发插件？ 插件是对Vue功能上的补充，比如可以设置页面全局共享属性，方法等。 目录 阅读前必读 一、添加全局方法和属性 二、给Vue实例添加方法和属性 三、通过混入 mixin 方法添加一些组件选项; 1. 局部混入 2. 全局混入 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 2. 添加过滤器 依据官方文档插件开发说明，插件开发有四种方式。 添加全局方法或者属性; 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 通过全局 mixin 方法添加一些组件选项; 添加全局资源：指令/过滤器/过渡等; 一个库，提供自己的 API，同时提供上面提到的一个或多个功能， 阅读前必读 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象. 比如： export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } 开发插件时，给Vue/Vue实例添加方法或者属性时，建议命名方式使用$开头，这样就不会存在和插件命名冲突。如果冲突了则优先使用组件属性/方法。 一、添加全局方法和属性 作用: 添加全局方法和属性，所有组件都可共享方法和属性，当某个组件更新了共享属性，那么其他组件也会同步更新。并非是组件实例之间的数据共享。 //1:编写组件 export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } //2:声明组件，注入组件 import install from \"./plugins/demo.js\"; Vue.use(install); //3：组件样例 {{ formatNumber }} import Vue from \"vue\"; export default { data() { return { gloablFunc: \"\" }; }, computed: { formatNumber: function() { //调用全局共享方法 return Vue.$globalFunction(this.gloablFunc); } } }; 二、给Vue实例添加方法和属性 方式:使用Vue.prototype的方式给Vue实例添加方法和属性 注意点：使用Vue.prototype的方式添加的属性是不会在各个实例之间数据共享的。 比如A实例修改了某属性，则B实例使用此属性时不会是A修改的值。 //1：组件编写 demo.js export default { install: function(Vue, options) { Vue.prototype.$instanceFunction = function(num) { return 3 * num; }; Vue.prototype.$instanceVar=\"我是实例变量\"; } }; //2：组件声明 main.js import install from \"./plugins/demo.js\"; Vue.use(install); //3:组件使用 Plugins.vue ...省略部分 添加实例方法/属性测试 {{ instanceVar }} mounted(){ console.log(this.$instanceVar); this.instanceVar=this.$instanceVar; //this.instanceVar=this.$instanceFunction(20); } 三、通过混入 mixin 方法添加一些组件选项; 混入mixin作用： 将混入对象的方法/数据对象合并到改组件本身的方法/数据上；若存在同名的方法，则首先调用混入对象，再调用组件本身方法，若存在同名数据对象，则使用组件的数据对象 混入分为局部混入和全局混入，一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。请谨慎使用全局混入，尽可能使用局部混入。 1. 局部混入 此处借用官方的例子选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 若存在同名方法则优先调用混入对象的方法。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { data: function() { return { message: \"hello\", foo: \"abc\" }; }, created: function() { console.log(\"混入对象的钩子被调用\"); }, methods:{ demo1(){ console.log(\"混入demo1\"); }, demo2(){ console.log(\"混入demo2\"); } } }; export default { mixins: [mixin], data: function() { return { message: \"goodbye\", bar: \"def\" }; }, created: function() { console.log('组件钩子被调用') console.log(this.$data); //混入对象的钩子被调用 //组件钩子被调用 // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } }, methods:{ demo1(){ console.log(\"组件demo1\"); } } }; 2. 全局混入 为全局Vue实例混入一个created方法，在每一个实例调用本身的created之前都会首先调用混入的created。 通常我们可以使用全局混入对Vue实例注入统一处理统计。 // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({ created: function () { //console.log(\"相信我，这个Log会在每一个Vue实例created之前调用\"); var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: 'hello! mrgao' }) // => \"hello!\" 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show等)，Vue 也允许注册自定义指令。 参考官方文档：自定义指令 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 //D.vue export default { data() { return { message: \"我是demo\" }; } }; //main.js Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) 结果为： name: \"demo\" value: \"我是demo\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 2. 添加过滤器 //1：编写过滤器 currency.js const digitsRE = /(\\d{3})(?=\\d)/g export function currency (value, currency, decimals) { value = parseFloat(value) if (!isFinite(value) || (!value && value !== 0)) return '' currency = currency != null ? currency : '$' decimals = decimals != null ? decimals : 2 var stringified = Math.abs(value).toFixed(decimals) var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified var i = _int.length % 3 var head = i > 0 ? (_int.slice(0, i) + (_int.length > 3 ? ',' : '')) : '' var _float = decimals ? stringified.slice(-1 - decimals) : '' var sign = value 单价:{{ product.price | currency }} 上述已经简单讲解了Vue插件开发的四种方式，最后一种方式，也就是将上述四种组合在一个install方法中即可。 文章实例请见：examples目录。 欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue路由变化页面没有刷新解决办法.html":{"url":"article/vue/Vue路由变化页面没有刷新解决办法.html","title":"4. Vue路由变化页面没有刷新","keywords":"","body":" 在Vue使用router开发单页面过程中，我们会遇到多次进入同一页面，页面没有刷新的情况。 一个例子： 有一个列表页面和详情页面，当点击列表的每一项，显示详情。你会发现，如果我们单纯的使用this.$router.push({path:\"/detail\",query:{id:\"your id\",another:\"asasaas\"}})，跳转到详情页面，详情页面的数据并没有发生变化。 解决办法: 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象： export default{ ... watch: { '$route' (to, from) { // 对路由变化作出响应... if(to.path==\"/detail\"){ this.initData(); } } } } 或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫： {{id}} {{another}} export default { data() { return { id: \"\", another: \"\" }; }, methods: { initData(to) { let query = to.query; console.log(\"传递过来的数据\", query,to); this.id = query.id; this.another = query.another; } }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` this.initData(to); next(); }, mounted(){ this.initData(this.$route); } }; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/react/":{"url":"article/react/","title":"二、React","keywords":"","body":"目录 1. React状态管理框架Redux使用 2. Redux中间件详解 3. Redux异步Action方案 4. Mobx异步Action方案 5. React中使用bind函数和箭头函数效率比较 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:36:49 "},"article/react/React状态管理框架Redux使用.html":{"url":"article/react/React状态管理框架Redux使用.html","title":"1. React状态管理框架Redux使用","keywords":"","body":"Action的理解:Reducer的理解全局共享store如何在react中使用state和action？其他的理解redux 的核心思想为： 将需要修改的 state 都存入到 store 里， 发起一个 action 用来描述发生了什么，用 reducers 描述 action 如何改变 state 。 使用dispatch触发action 图片参考于这里 Action的理解: action是用来触发reducer修改state的，触发的方式是使用dispatch; dispatch修改方式为{type:\"唯一的type\",...你的数据} 默认情况只能使用同步方式dispatch，如果需要异步方式则需要引入第三方库redux-thunk; 我们可以在react的component中调用action，来更新或者获取数据。 redux-thunk是异步action的一种解决方案，具体请看下面的例子，如果不了解为什么要使用一个函数嵌套，且为何传入参数为dispatch何getState，请查看Redux中间件详解; //举个例子：global.js //一个异步action export const setDemo = demo => (dispatch, state) => { dispatch({//执行一个action type: \"GLOABLE_DEMO\", demo: demo }); }; //home.js中一个action creator const receiveInfo = response => ({ type: 'RECEIVE_HOME', homeInfo: response }); /**使用redux-thunk异步执行action: thunk要求必须在一个函数中返回另一个函数,且另一个函数的入参为dispatch何getState 这样我们可以在异步执行完成之后触发reducer，并且可以在action中获取到state的值 **/ export const getInfo = () => async (dispatch, getState) => { try { const response = await new Promise((resolve, reject) => { /* 模拟异步操作成功，这样可以通过fetch调接口获取数据 */ setTimeout(() => { resolve({ title: 'React App' }); }, 1000); }); await dispatch(receiveInfo (response));//在异步action调用dispatch()触发reducer更新state return response; } catch (error) { console.log('error: ', error); return error; } }; Reducer的理解 Reducer是一个纯函数，其作用就是通过返回一个新的state来达到修改state的目的； Reducer函数入参有两个：state，action；切记不要直接修改state和action； 如果需要在一个对象中添加/修改一个key可以使用Object.assign()函数，但是此函数在部分浏览器中不支持；需要安装babel-polifill; Reducer中根据action的type不同来更新不同的state，所以建议将type抽离成一个单独的js文件，利于维护; 每一个Reducer在没有state变化时必须返回默认的state; //一个例子 global.js const initState = { userInfo: {}, demo:\"我是demo\" }; export const global = (state = initState, action) => { switch (action.type) { case 'CURRENT_USER': return { ...state, userInfo: action.userInfo }; case 'GLOABLE_DEMO': return{ ...state, demo:action.demo//action.demo就是上面action使用dispatch传递的demo数据 } default: return state;//必须返回默认的state } }; //Reducer可以拆分成多个模块，可以使用统一入口 import { home } from './home'; import { global } from './global'; const rootReducer = { home, global }; export default rootReducer; 全局共享store 使用Reducer 创建全局唯一的store：将各个Reducer返回的state通过combineReducer合并在在一起（这就是下面【 如何在react中使用state和action】） //为什么使用@connect的第一参数可以使用...state.home来获取home的reducer的state； combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数; 理解： createStore(reducer)，使用用来创建全局唯一的store，将各个Reducer返回的state通过combineReducer合并在在一起； combineReducer({})的作用是将多个Reducer合成一个Reducer函数，也就是说我们每次使用dispatch(action)的时候其实都会调用所有的reducer,这就是为什么需要reducer在没有数据变化时直接返回默认的，如果不这样做将会造成死循环。combineReducer接受一个reducer对象，建议将不同的reducer分开{home:homeReducer,global:globalReducer}，这样state也就按照home和global分开了； applyMiddleware([]),接受一个中间件数组，中间件是action到reducer中间的部分，你可以拦截dispatch的操作；详细请看Redux中间件详解; Provider是react-redux包中的，作用是全局注入store这样在每一个connect([mapStateToProps],[mapDispatchToProps])中即可获取到state import { createStore, applyMiddleware, combineReducers } from 'redux'; import { Provider } from 'react-redux'; import { composeWithDevTools } from 'redux-devtools-extension'; import thunk from 'redux-thunk'; import { routerReducer, routerMiddleware } from 'react-router-redux'; import createHistory from 'history/createBrowserHistory'; import App from './App'; import rootReducer from './reducers/index'; const history = createHistory(); const middleware = routerMiddleware(history); const middlewares = [thunk, middleware]; //使用Reducer 创建全局唯一的store：将各个Reducer返回的state通过combineReducer合并在在一起（这就是下面【 如何在react中使用state和action】） //为什么使用@connect的第一参数可以使用...state.home来获取home的reducer的state； const store = createStore( //combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数; combineReducers({ routing: routerReducer, ...rootReducer }), composeWithDevTools(applyMiddleware(...middlewares)) ); // 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 中才能使用 connect() 方法 const render = Component => ReactDOM.render( document.getElementById('root') ); render(App); 如何在react中使用state和action？ 使用之前需要引入第三方库react-redux； 理解： 要在react中使用redux，除开需要引入redux提供的createStore,combineReducer,applyMiddleware,bindActionCreators;也需要引入react-redux中的connect,Provider等； 前面讲到Provider中会将全局store传递给组件，那么组件需要接收store需要使用connect();connect比较重要的有两个参数，第一个：mapStateToProps就是讲reducer中返回的state会注入到此组件的props中；（这就是为啥之前建议reducer要分模块，且在combineReducer传入{home:homeReducer,global:globalReducer}的格式），这样注入props中的key就不至于由于可能不同的reducer返回相同key的state而混乱; 第二个参数为:mapDispatchToProps,就是将那些action注入到props中。mapDispatchToProps其实可以有两种方式，一种是：对象的方式(比如：{home:getInfo,global:getGlobalInfo},其中的getInfo和getGlobalInfo是一些action)；另外一种是函数的方式`(dispatch=>{})。 import React from \"react\"; import { bindActionCreators } from \"redux\"; import { connect } from \"react-redux\"; import * as home from \"../actions/home\"; import * as global from \"../actions/global\"; import \"./index.less\"; //connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])其作用为连接 React 组件与 Redux store； @connect( //1、store 中的数据作为 props 绑定到组件上 ，...state.home是当前页面的状态管理，global则是全局state，如果需要多个 //组件共享一些state，那么可以将state放在global中，比如demo //2、只有定义了此参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变， //mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并 //3、state.home从哪里来？其实是上述总的reducer中的{home,global}中的home state => ({ ...state.home,...state.global }), //将 action 作为 props 绑定到组件上 dispatch => bindActionCreators({ ...home, ...global }, dispatch) ) //再获取传递给当前组件的state //demo为全局global中的state，setDemo为全局的action var {demo,setDemo,getInfo}=this.props; {demo} //调用action 修改state { setDemo(\"我是新的demo\"+(new Date()))}}>点击我修改state //获取数据 getInfo().then(res=>res.json()).then(da=>{ }) connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) 其他的理解 1、mapStateToProps（state, ownProps） mapStateToProps是一个函数，用于建立组件跟 store 的 state 的映射关系 作为一个函数，它可以传入两个参数，结果一定要返回一个 object 传入mapStateToProps之后，会订阅store的状态改变，在每次 store 的 state 发生变化的时候，都会被调用 ownProps代表组件本身的props，如果写了第二个参数ownProps，那么当prop发生变化的时候，mapStateToProps也会被调用。例如，当 props接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。 mapStateToProps可以不传，如果不传，组件不会监听store的变化，也就是说Store的更新不会引起UI的更新； 2、 mapDispatchToProps(dispatch) 如果mapDispatchToProps是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中 如果mapDispatchToProps是函数类型的：该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。 3、bindActionCreators(actionCreators, dispatch) bindActionCreators通常和mapDispatchToProps一起使用 actionCreators (Function or Object): 一个 action creator，或者一个 value 是 action creator 的对象。第一个参数可以接收一个action creator或者一个action creator的对象，这些action将会注入到对应组件的Props中 dispatch (Function): 一个由 Store 实例提供的 dispatch 函数。一般这个dispatch是由函数式的mapDispatchToProps的参数提供 4、 action creator是什么？ 一般情况一个action其实就是一个含有type属性的对象{type:\"HONE_CHANGE\",other:\"\"}， action creator其实是一个返回action的函数。 不要混淆 action 和 action creator 这两个概念。Action 是一个信息的负载，而 action creator 是一个创建 action 的工厂。 调用 action creator 只会生产 action，但不分发。你需要调用 store 的 dispatch function 才会引起变化(dispatch(createActionCreator)) //一个action creator createActionCreator(info){ return { type:\"HONE_CHANGE\", other:info } } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/react/Redux中间件详解.html":{"url":"article/react/Redux中间件详解.html","title":"2. Redux中间件详解","keywords":"","body":"一、 概念二、 中间件的使用三、 applyMiddleware 的理解2、 Redux 的 applyMiddleware 源码理解四、 如何编写自己的中间件？五、 异步 Action redux-thunk 的理解看完此篇文章你可以了解到： 中间件如何使用？ 如何自定义中间件？ redux-thunk异步执行action其实思想很简单 applyMiddleware是如何执行中间件的？ redux 的核心思想为：将需要修改的 state 都存入到 store 里，发起一个 action 用来描述发生了什么，用 reducers 描述 action 如何改变 state tree 。创建 store 的时候需要传入 reducer，真正能改变 store 中数据的是 store.dispatch API。 一、 概念 中间件是 dispatch 一个 action 到触发 reducer 之间做的一个额外操作，通常使用中间件 Middleware 来进行日志记录、创建崩溃报告、调用异步接口、路由、或者改变dispatch; 二、 中间件的使用 import { createStore, applyMiddleware, combineReducers } from \"redux\"; import rootReducer from \"./reducers/index\"; import thunk from \"redux-thunk\"; const store = createStore( combineReducers({ ...rootReducer }), applyMiddleware([thunk]) ); 此处使用了异步 action 中间件 thunk，没错就是传入给 applyMiddleware 即可完成 dispatch 的增强。那么有两个问题？ 当有多个中间件时，每一个 middleware 是如何操作前一个中间件包装过的 dispatch? 如何编写自己的中间件？ 三、 applyMiddleware 的理解 applyMiddleware 即可回答第 2 个问题，applyMiddleware 函数接受一个中间件数组，并依次执行中间件，将上一个 middleware 包装过的 store.dispatch 传递给下一个中间件。 1、 一个简单的 applyMiddleware //一个简单的 applyMiddleware 实现（非官方的 API,后面会介绍） function applyMiddleware(store, middlewares) { middlewares = middlewares.slice(); middlewares.reverse(); //为何要反序？ /** 由于是依次执行中间件，那么当前中间件执行完成肯定得执行下一个中间件，做到链式调用； 之所以将列表反序的目的是为了在遍历的时候，让上一个中间件知道下一个中间件的dispatch是什么；(可能这里有点绕，下面讲述Redux API的时候会介绍) **/ let dispatch = store.dispatch; middlewares.forEach(middleware => (dispatch = middleware(store)(dispatch))); return Object.assign({}, store, { dispatch }); } //提前透露：一个简单的中间件，每一个中间件中需要有当前的store和下一个dispatch。 const logger = store => next => action => { console.log(\"dispatching\", action); let result = next(action); //next为下一个dispatch； console.log(\"next state\", store.getState()); return result; }; 理解： 中间件的执行是顺序执行的，为了能够链式执行中间件，需要在每一个中间件中知道下一个 dispatch，这样就可以跳转到下一个中间件； 每个中间件的dispatch生成其实是反序的，因为 A 在调用时需要知道 B 的 dispatch，B 在执行时需要知道 C 的 dispatch，那么需要先知道 C 的 dispatch。（下面 Redux API 源码会验证这点） 在每一个中间件中，都是可以使用 next 函数(也就是下一个的 dispatch 函数)； 2、 Redux 的 applyMiddleware 源码理解 export default function applyMiddleware(...middlewares) { return createStore => (...args) => { const store = createStore(...args); //取到当前的store let dispatch = () => { throw new Error( \"Dispatching while constructing your middleware is not allowed. \" + \"Other middleware would not be applied to this dispatch.\" ); }; const middlewareAPI = { //每个 middleware 接受 Store 的 dispatch 和 getState 函数作为命名参数 getState: store.getState, //返回应用当前的 state 树。 dispatch: (...args) => dispatch(...args) }; // 依次调用每一个中间件 const chain = middlewares.map(middleware => middleware(middlewareAPI)); //现在 此处的chain应该是一个函数数组[]，一个类似于 /** [ function(next){ return function(action){ } }, function(next){ return function(action){ } } ] **/ //compose(...functions)从右到左来组合多个函数 //作用：compose(funcA, funcB, funcC) 形象为 compose(funcA(funcB(funcC())))； // 其效果类似于上一部分讲述的在循环中得到上一个dispatch dispatch = compose(...chain)(store.dispatch); return { ...store, dispatch }; }; } 理解： 上面简单例子讲到，dispatch的生成其实是反序的可以从 compose 中看出端倪：compose(funcA, funcB, funcC) 形象为 compose(funcA(funcB(funcC())))； 看 conmpose 源码其实你会发现，最后 compose(...chain)的结果应该为: function(){ funcA(funcB(funcC())) } 所以在执行compose(...chain)(store.dispatch)的时候,内部其实先调用了 funcC 来生成 C 的 dispatch。 最后一个中间件中不应该调用 next 函数，因为没有下一个中间件了，同理要是中间某个中间件没有调用 next(action)，那么后面所有的中间件将不会被调用。（这就是官方文章中写的：logger 中间件要放在最后一个的原因） 3、 验证中间件是顺序执行，但是 dispatch 确实反序生成的 此处可能有点超前，如果您不知道如何编写中间件请先阅读下一节，再回到这里来看 //第一个中间件 function createMiddleware(extraArgument) { return ({ dispatch, getState }) => next => action => { console.log(\"第一个的下一个的dispatch\", next); console.log(\"第一个action\", action); const result = next(action); console.log(\"第一个state\", getState()); return result; }; } const firstMid = createMiddleware(); export default firstMid; //第二个中间件 function createMiddleware(extraArgument) { return ({ dispatch, getState }) => next => action => { console.log(\"第二个的下一个的dispatch\", next); console.log(\"第二个action\", action); const result = next(action); console.log(\"第二个state\", getState()); return result; }; } const secondMid = createMiddleware(); export default secondMid; //中间件使用 const middlewares = [firstMid, secondMid]; //注意中间件的顺序 const store = createStore( combineReducers({ ...rootReducer }), composeWithDevTools(applyMiddleware(...middlewares)) ); //实际打印的结果 /** 第一个的下一个的dispatch ƒ (action) { console.log('第二个的下一个的dispatch', next); console.log('第二个action', action); var result = next(action); console.log('第二个state', getState()); return resu… 第一个action {type: \"GLOBAL_DATA\", globalData: {…}} 第二个的下一个的dispatch ƒ dispatch(action) { if (!isPlainObject(action)) { throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.'); } if (typeof action.type === 'unde… 第二个action {type: \"GLOBAL_DATA\", globalData: {…}} 第二个state {routing: {…}, global: {…}, home: {…}} 第一个state {routing: {…}, global: {…}, home: {…}} **/ 四、 如何编写自己的中间件？ 格式为: function yourMiddleware() { return ({ getState, dispatch }) => next => action => {}; } ...middlewares (arguments): 遵循 Redux middleware API 的函数。每个 middleware 接受 Store 的 dispatch 和 getState 函数作为命名参数，并返回一个函数。该函数会被传入 被称为 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数; 这个函数可以直接调用 next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store 的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是 ({ getState, dispatch }) => next => action。 一个记录日志的中间件： function createLoggerkMiddleware() { return ({ dispatch, getState }) => next => action => { console.log(\"will dispatch\", action); // 调用 middleware 链中下一个 middleware 的 dispatch。 let returnValue = next(action); console.log(\"state after dispatch\", getState()); // 一般会是 action 本身，除非 // 后面的 middleware 修改了它。 return returnValue; }; } const logger = createLoggerkMiddleware(); export default logger; 理解： Redux middleware 就像一个链表。每个 middleware 方法既能调用 next(action) 传递 action 到下一个 middleware，也可以调用 dispatch(action) 重新开始处理，或者什么都不做而仅仅终止 action 的处理进程。 五、 异步 Action redux-thunk 的理解 1、redux-thunk的使用例子 const middlewares = [thunk, middleware]; const store = createStore( combineReducers({ ...rootReducer }), composeWithDevTools(applyMiddleware(...middlewares)) ); //action中 //这是一个同步action const receiveInfo = response => ({ type: 'RECEIVE_HOME', homeInfo: response }); //使用redux-thunk异步执行action export const getInfo = () => async (dispatch, getState) => { try { const response = await new Promise((resolve, reject) => { /* 模拟异步操作成功，这样可以通过fetch调接口获取数据 */ setTimeout(() => { resolve({ title: 'React App' }); }, 1000); }); await dispatch(receiveInfo (response));//使用dispatch触发同步action return response; } catch (error) { console.log('error: ', error); return error; } }; //在react中 let {getInfo}=this.props; getInfo().then({ }) 2、redux-thunk源码解析 function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) => next => action => { //可以接受一个返回函数的action creator。如果这个action creator 返回的是一个函数，就将dispatch的决策权交给此函数，如果不是，就按照原来的next(action)执行。 if (typeof action === \"function\") { return action(dispatch, getState, extraArgument);//这就是上面例子的函数为啥接受dispatch和getState两个参数的原因 } return next(action); }; } const thunk = createThunkMiddleware(); thunk.withExtraArgument = createThunkMiddleware; export default thunk; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/react/Redux异步Action方案.html":{"url":"article/react/Redux异步Action方案.html","title":"3. Redux异步Action方案","keywords":"","body":"redux-thunk 使用react-promise 使用redux-promise-middleware使用react-saga 使用最后 本文主要讲述如何在 Redux 中使用异步 action，不追究其原理，如果需要了解原理，请移步Redux 中间件详解 在 Redux 中使用异步 action 有很多种方式，常用的有redux-thunk和redux-promise、redux-promise-middleware和redux-saga中间件 redux-thunk 使用 thunk 实现的异步 action需要action返回一个函数，且函数的入参为(dispatch, getState)；这样你就可以在此函数中根据自己的需要使用 dispatch 分发 action 了。 redux-thunk 源码 thunk 的使用 //一个action creator返回一个action let actionCreateDemo = response => ({ type: \"GET_INFO\", info: response }); //id为react调用getInfo的入参， export const getInfo = id => async (dispatch, getState) => { try { const response = await new Promise((resolve, reject) => { /* 模拟异步操作成功，这样可以通过fetch调接口获取数据 */ setTimeout(() => { resolve({ title: \"React App\" }); }, 1000); }); await dispatch(actionCreateDemo(response)); return response; } catch (error) { // console.log('error: ', error); return error; } }; react-promise 使用 redux-promise 源码 它自定义了一个 middleware，当检测到有 action 的 payload 属性是 Promise 对象时，就会： 若 resolve，触发一个此 action 的拷贝，但 payload 为 promise 的 value，并不设置error 若 reject，触发一个此 action 的拷贝，但 payload 为 promise 的 reason，并设 error为true 也就是 redux-primise 会将异步操作放在 payload 中 //部分源码 return isPromise(action.payload)//action需要有一个payload属性 ? action.payload .then(result => dispatch({ ...action, payload: result }))//如果为resolvapayload九尾promise的值 .catch(error => { dispatch({ ...action, payload: error, error: true });//否则为异常 return Promise.reject(error); }) : next(action); 使用 //action types const GET_DATA = 'GET_DATA'; //action creator const getData = function(id) { return { type: GET_DATA, payload: api.getData(id) //payload为promise对象 } } //reducer function reducer(oldState, action) { switch(action.type) { case GET_DATA: if (action.error) {//需要增加额外的判断 return errorState } else { return successState } } } 注意： redux-promise相对于redux-thunk会有代码减少的提升，但是任何能明显减少代码量的方案，都应该小心它是否过度省略了什么东西，减肥是好事，但是不可过度减肥。 redux-promise为了精简而做出的妥协非常明显：无法处理乐观更新 。 多数异步场景都是悲观更新的，即等到请求成功才渲染数据。而与之相对的乐观更新，则是不等待请求成功，在发送请求的同时立即渲染数据。 redux-promise-middleware使用 redux-promise-middleware相比redux-promise，采取了更为温和和渐进式的思路 redux-promise-middleware提供了三个状态PENDING、FULFILLED和REJECTED这样就可以处理异步action失败的情况； 在action的区分上，它选择了回归type的\"正途\"，_PENDING、_FULFILLED、_REJECTED等后缀借用了promise规范 (当然它们是可配置的) 。 它的遗憾则是只在action层实现了简化，对reducer层则束手无策。另外，相比redux-thunk，它还多出了一个_PENDING的字符串模板代码(三个action却需要四个type)。 //action types const GET_DATA = 'GET_DATA', GET_DATA_PENDING = 'GET_DATA_PENDING',//必须在GET_DATA后面加上PENDING字符 GET_DATA_FULFILLED = 'GET_DATA_FULFILLED', GET_DATA_REJECTED = 'GET_DATA_REJECTED'; //action creator const getData = function(id) { return { type: GET_DATA, payload: { promise: api.getData(id), data: id//需要将数据放在data部分 } } } //reducer const reducer = function(oldState, action) { switch(action.type) { case GET_DATA_PENDING : return oldState; // 可通过action.payload.data获取id case GET_DATA_FULFILLED : return successState; case GET_DATA_REJECTED : return errorState; } } 如果不需要乐观更新，action creator可以使用和redux-promise完全一样的，更简洁的写法，即 const getData = function(id) { return { type: GET_DATA, payload: api.getData(id) //等价于 {promise: api.getData(id)} } } react-saga 使用 redux-saga 源码 redux-saga官方中文文档 上面的三种方案都是讲异步操作放在action中，而saga让异步行为成为架构中独立的一层，既不在action creator中，也不和reducer沾边。 的出发点是把副作用 (Side effect，异步行为就是典型的副作用) 看成\"线程\"，可以通过普通的action去触发它，当副作用完成时也会触发action作为输出。 其中一些函数包括:takeEvery put call等函数请查阅Saga 辅助函数 import { takeEvery } from 'redux-saga' import { call, put } from 'redux-saga/effects' export function* loadUserData(uid) { try { yield put({ type: USERDATA_REQUEST }); let { data } = yield call(userRequest, {data:\"\"});//userRequest为一个一个 Generator 函数, 也可以是一个返回 Promise 或任意其它值的普通函数，第二个参数：传递给 fn 的参数数组。 yield put({ type: USERDATA_SUCCESS, data }); } catch(error) { yield put({ type: USERDATA_ERROR, error }); } } 最后 对于个人而言，较多的使用的是thunk的方式，如果项目较大可采用saga方式，但是会增加学习成本，这就看自己的取舍了。 参考:Redux异步选型 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/react/Mobx异步Action方案.html":{"url":"article/react/Mobx异步Action方案.html","title":"4. Mobx异步Action方案","keywords":"","body":"Mobx中computed和autorun的区别Mobx中action和reaction的区别异步ActionMobx中computed和autorun的区别 它们都是响应式调用的表达式，但是，如果你想响应式的产生一个可以被其它 observer 使用的值，请使用 @computed，如果你不想产生一个新值，而想要达到一个效果，请使用 autorun。 举例来说，效果是像打印日志、发起网络请求等这样命令式的副作用 如果你有一个函数应该自动运行，但不会产生一个新的值，请使用autorun。 其余情况都应该使用 computed Mobx中action和reaction的区别 action是用来修改状态的，而reaction是autorun的变种。 reaction(() => data, (data, reaction) => { sideEffect }, options?) 它接收两个函数参数，第一个(数据 函数)是用来追踪并返回数据作为第二个函数(效果 函数)的输入。 不同于 autorun 的是当创建时效果函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。 在执行效果函数时访问的任何 observable 都不会被追踪. const reaction2 = reaction( () => todos.map(todo => todo.title), titles => console.log(\"reaction 2:\", titles.join(\", \")) ); action(fn)或者@action.bound classMethod() {} (action.bound是自动绑定this)注意: action.bound 不要和箭头函数一起使用；箭头函数已经是绑定过的并且不能重新绑定。 class Ticker { @observable tick = 0 @action.bound increment() { this.tick++ // 'this' 永远都是正确的 } } const ticker = new Ticker() setInterval(ticker.increment, 1000) 异步Action 如果 action 中存在 setTimeout、promise 的 then 或 async 语句，并且在回调函数中某些状态改变了，那么这些回调函数也应该包装在 action 中。创建异步 action 有几种方式; Promises 使用action函数包裹promise的then函数； mobx.configure({ enforceActions: true }) // 不允许在动作之外进行状态修改 class Store { @observable githubProjects = [] @observable state = \"pending\" // \"pending\" / \"done\" / \"error\" @action fetchProjects() { this.githubProjects = [] this.state = \"pending\" fetchGithubProjectsSomehow().then( // 内联创建的动作 action(\"fetchSuccess\", projects => { const filteredProjects = somePreprocessing(projects) this.githubProjects = filteredProjects this.state = \"done\" }), // 内联创建的动作 action(\"fetchError\", error => { this.state = \"error\" }) ) } } 或者使用runInAction函数，而不是为每一个回调都创建一个action mobx.configure({ enforceActions: true }) // 不允许在动作之外进行状态修改 class Store { @observable githubProjects = [] @observable state = \"pending\" // \"pending\" / \"done\" / \"error\" @action fetchProjects() { this.githubProjects = [] this.state = \"pending\" fetchGithubProjectsSomehow().then( projects => { const filteredProjects = somePreprocessing(projects) // 将‘“最终的”修改放入一个异步动作中 runInAction(() => { this.githubProjects = filteredProjects this.state = \"done\" }) }, error => { // 过程的另一个结局:... runInAction(() => { this.state = \"error\" }) } ) } } async / await async搭配runInAction函数，完成异步Action mobx.configure({ enforceActions: true }) class Store { @observable githubProjects = [] @observable state = \"pending\" // \"pending\" / \"done\" / \"error\" @action async fetchProjects() { this.githubProjects = [] this.state = \"pending\" try { const projects = await fetchGithubProjectsSomehow() const filteredProjects = somePreprocessing(projects) // await 之后，再次修改状态需要动作: runInAction(() => { this.state = \"done\" this.githubProjects = filteredProjects }) } catch (error) { runInAction(() => { this.state = \"error\" }) } } } 使用生成器 flow 只能作为函数使用，不能作为装饰器使用。 flow 可以很好的与 MobX 开发者工具集成，所以很容易追踪 async 函数的过程。 mobx.configure({ enforceActions: true }) class Store { @observable githubProjects = [] @observable state = \"pending\" fetchProjects = flow(function * () { // Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/react/React中使用bind函数和箭头函数效率比较.html":{"url":"article/react/React中使用bind函数和箭头函数效率比较.html","title":"5. React中使用bind函数和箭头函数效率比较","keywords":"","body":"提问：react项目中的JSX里，在constructor中使用this.func=this.func.bind(this)的写法，为什么要比非bind的func = () => {}的写法效率高？ 使用构造函数绑定例子 class Test extends Component { constrcutor() { this.handleClick = this.handleClick.bind(this) } handleClick() { console.log(this) } render() { return 测试 } } 使用箭头函数方式 class Test extends Component { handleClick = () => { console.log(this) } render() { return 测试 } } 使用箭头函数方式比构造函数绑定方式的优点： 不需要手动编写bind函数，减少代码量; 为何构造函数绑定方式性能要高呢？ 首先看一下bind的polyfill： if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) {//oThis为需要绑定的对象也就是上例中的{a:20} // this为上例中的bFun，要求必须为函数类型 if (typeof this !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } //将bind函数传入的参数从第1个(index从0开始)开始转换成数组，因为第0个为传入的绑定对象。arguments为类数组 var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() { // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 // 由于使用new 方式创建的对象，this指向为对象的实例，此处判断如果使用new方式创建那么this应该为对象实例的this // 否则使用上下文绑定为传入的对象 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 // 函数的参数：应该为bind时传入的参数+调用生成的函数时传入的参数和 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 维护原型关系 if (this.prototype) { // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; } // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; }; } 原因 通过在构造器中使用bind绑定函数以后，所生成的实例中，都会有一个独立的fBound，函数体相对于待绑定的函数较小，而每个实例中的fBound在被调用时都会共享待绑定的函数handleClick.也就是说：使用构造器bind的方法，每个实例都可以有效地共享函数体，从而更加有效的使用内存。 然后使用箭头方式绑定，所生成的实例中都有一个单独的handleClick 二者使用场景 当函数不做复杂逻辑处理，使用构造函数绑定和箭头函数方式绑定区别不大； 当实例数量比较少或者需要绑定的函数较少情况；使用箭头函数更容易理解； 实例数量比较多或者函数有复杂逻辑处理，请使用构造函数绑定方式。 盗用Demystifying Memory Usage using ES6 React Classes中的两张区别图。 箭头函数方式：每个实例都会创建一个新的handler函数 构造函数方式：每个实例会创建一个较小的函数(也就是bind中返回的fBound)，并复用handler函数 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/javascript/":{"url":"article/javascript/","title":"三、JavaScript","keywords":"","body":"目录 1. 读书笔记：你不知道的Javascript上 2. 读书笔记：你不知道的Javascript中 3. 读书笔记：你不知道的Javascript下 4. new A()和A()的区别 5. Javascript的变量提升和函数提升 6. Javascript对闭包的理解 7. 对Object.create和类式继承的理解 8. Object.create()和New的区别 9. Javascript柯里化和偏函数实现 10. Javascript中this绑定详解 11. JavaScript中改变this指向有几种方式 12. Javascript的call和apply和bind方法 13. Javascript的bind的polyfill的理解 14. Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6 15. Javascript寄生式组合继承详解 16. JavaScript常见ployfill Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-25 20:51:58 "},"article/javascript/你不知道的Javascript上.html":{"url":"article/javascript/你不知道的Javascript上.html","title":"1. 读书笔记：你不知道的Javascript上","keywords":"","body":"第一部分 作用域和闭包第1章 作用域是什么第2章 词法作用域第3章 函数作用域和块作用域第4章 变量和函数提升第5章 作用域闭包附录A 动态作用域附录B 块作用域的替代方案第二部分 this和对象原型第1章 关于this第2章 this全面解析第3章 对象第4章 混合对象“类”第5章 原型第6章 行为委托你不知道的JavaScript 上卷 第一部分 作用域和闭包 第1章 作用域是什么 问题1：变量储存在哪里？ 问题2：程序需要时如何找到它们？ 1.1 编译原理 JavaScript语言是“动态”或“解释执行”语言，但事实上是一门编译语言。但它不是提前编译的，编译结果也不能在分布式系统中移植。 传统编译语言流程中，程序在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（Tokenizing/Lexing） 将由字符组成的字符串分解成（对编程语言来说）有意义的代码块。 var a = 2; 上面这段程序会被分解成以下词法单元：var、a、=、2、;。 空格是否会被当做词法单元，取决于空格在这门语言中是否有意义。 解析/语法分析（Parsing） 将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的数。这个数被称作抽象语法树（Abstract Syntax Tree, AST）。 var a = 2; 以上代码的抽象语法树如下所示： VariableDeclaration 顶级节点 Identifier 子节点，值为a AssignmentExpression 子节点 NumericLiteral 子节点，字为2 代码生成 将AST转换成可执行代码的过程。过程与语言、目标平台等相关。 简单来说就是可以通过某种方法将var a = 2;的AST转化为一组机器指令。用来创建一个叫做a的变量（包括分配内存等），并将一个值存储在a中。 1.2 理解作用域 1.2.1 演员表 引擎：从头到尾负责整个JavaScript程序的编译和执行。 编译器：负责语法分析和代码生成等 作用域：负责收集并维护由所有声明的标识符（变量、函数）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 1.2.2 对话 var a = 2;存在2个不同的声明。 1、编译器在编译时处理（var a）：在当前作用域中声明一个变量（如果之前没有声明过）。 st=>start: Start e=>end: End op1=>operation: 分解成词法单元 op2=>operation: 解析成树结构AST cond=>condition: 当前作用域存在变量a? op3=>operation: 忽略此声明，继续编译 op4=>operation: 在当前作用域集合中声明新变量a op5=>operation: 生成代码 st->op1->op2->cond cond(yes)->op3->op5->e cond(no)->op4->op5->e 2、引擎在运行时处理（a = 2）：在作用域中查找该变量，如果找到就对变量赋值。 st=>start: Start e=>end: End cond=>condition: 当前作用域存在变量a? cond2=>condition: 全局作用域? op1=>operation: 引擎使用这个变量a op2=>operation: 引擎向上一级作用域查找变量a op3=>operation: 引擎把2赋值给变量a op4=>operation: 举手示意，抛出异常 st->cond cond(yes)->op1->op3->e cond(no)->cond2(no)->op2(right)->cond cond2(yes)->op4->e 1.2.3 LHS和RHS查询 L和R分别代表一个赋值操作的左侧和右侧，当变量出现在赋值操作的左侧时进行LHS查询，出现在赋值操作的非左侧时进行RHS查询。 LHS查询（左侧）：找到变量的容器本身，然后对其赋值 RHS查询（非左侧）：查找某个变量的值，可以理解为 retrieve his source value，即取到它的源值 function foo(a) { console.log( a ); // 2 } foo(2); 上述代码共有1处LHS查询，3处RHS查询。 LHS查询有： 隐式的a = 2中，在2被当做参数传递给foo(…)函数时，需要对参数a进行LHS查询 RHS查询有： 最后一行foo(...)函数的调用需要对foo进行RHS查询 console.log( a );中对a进行RHS查询 console.log(...)本身对console对象进行RHS查询 1.3 作用域嵌套 遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止。 1.4 异常 ReferenceError和作用域判别失败相关，TypeError表示作用域判别成功了，但是对结果的操作是非法或不合理的。 RHS查询在作用域链中搜索不到所需的变量，引擎会抛出ReferenceError异常。 非严格模式下，LHS查询在作用域链中搜索不到所需的变量，全局作用域中会创建一个具有该名称的变量并返还给引擎。 严格模式下（ES5开始，禁止自动或隐式地创建全局变量），LHS查询失败会抛出ReferenceError异常 在RHS查询成功情况下，对变量进行不合理的操作，引擎会抛出TypeError异常。（比如对非函数类型的值进行函数调用，或者引用null或undefined类型的值中的属性） 1.5 小结 var a = 2被分解成2个独立的步骤。 1、var a在其作用域中声明新变量 2、a = 2会LHS查询a，然后对其进行赋值 第2章 词法作用域 2.1 词法阶段 词法作用域是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，所以在词法分析器处理代码时会保持作用域不变。（不考虑欺骗词法作用域情况下） 2.1.1 查找 作用域查找会在找到第一个匹配的标识符时停止。 遮蔽效应：在多层嵌套作用域中可以定义同名的标识符，内部的标识符会“遮蔽”外部的标识符。 全局变量会自动变成全局对象的属性，可以间接的通过对全局对象属性的引用来访问。通过这种技术可以访问那些被同名变量所遮蔽的全局变量，但是非全局的变量如果被遮蔽了，无论如何都无法被访问到。 window.a 词法作用域只由函数被声明时所处的位置决定。 词法作用域查找只会查找一级标识符，比如a、b、c。对于foo.bar.baz，词法作用域只会查找foo标识符,找到之后，对象属性访问规则会分别接管对bar和baz属性的访问。 2.2 欺骗词法 欺骗词法作用域会导致性能下降。以下两种方法不推荐使用 2.2.1 eval eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 function foo (str, a) { eval( str ); // 欺骗！ console.log( a, b ); } var b = 2; foo( \"var b = 3;\", 1 ); // 1, 3 eval('var b = 3')会被当做本来就在那里一样来处理。 非严格模式下，如果eval(..)中所执行的代码包含一个或多个声明，会在运行期修改书写期的词法作用域。上述代码中在foo(..)内部创建了一个变量b，并遮蔽了外部作用域中的同名变量。 严格模式下，eval(..)在运行时有自己的词法作用域，其中的声明无法修改作用域。 function foo (str) { \"use strict\"; eval( str ); console.log( a ); // ReferenceError: a is not defined } foo( \"var a = 2;\" ); setTimeout(..)和setInterval(..)的第一个参数可以是字符串，会被解释为一段动态生成的函数代码。已过时，不要使用 new Function(..)的最后一个参数可以接受代码字符串（前面的参数是新生成的函数的形参）。避免使用 2.2.2 with with通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 var obj = { a: 1, b: 2, c: 3 }; // 单调乏味的重复“obj” obj.a = 2; obj.b = 3; obj.c = 4; // 简单的快捷方式 with (obj) { a = 3; b = 4; c = 5; } with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，这个对象的属性会被处理为定义在这个作用域中的词法标识符。 这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。 function foo(obj) { with (obj) { a = 2; } } var o1 = { a: 3 }; var o2 = { b : 3 } foo( o1 ); console.log( o1.a ); // 2 foo( o2 ); console.log( o2.a ); // undefined console.log( a ); // 2 -- 不好，a被泄露到全局作用域上了！ 上面例子中，创建了o1和o2两个对象。其中一个有a属性，另一个没有。在with(obj){..}内部是一个LHS引用，并将2赋值给它。 o1传递进去后，with声明的作用域是o1,a = 2赋值操作找到o1.a并将2赋值给它。 o2传递进去后，作用域o2中并没有a属性，因此进行正常的LHS标识符查找，o2的作用域、foo(..)的作用域和全局作用域都没有找到标识符a，因此当a = 2执行时，自动创建了一个全局变量（非严格模式），所以o2.a保持undefined。 2.2.3 性能 JavaScript引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 引擎在代码中发现eval(..)或with，它只能简单的假设关于标识符位置的判断都是无效的。因为无法在词法分析阶段明确知道eval(..)会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给with用来创建词法作用域的对象的内容到底是什么。 悲观情况下如果出现了eval(..)或with，所有的优化可能都是无意义的，最简单的做法就是完全不做任何优化。代码运行起来一定会变得非常慢。 2.3 小结 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。 有以下两个机制可以“欺骗”词法作用域： eval(..)：对一段包含一个或多个声明的”代码“字符串进行演算，借此来修改已经存在的词法作用域（运行时）。 with：将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，创建一个新的词法作用域（运行时）。 副作用是引擎无法在编译时对作用域查找进行优化。因为引擎只能谨慎地认为这样的优化是无效的，使用任何一个都将导致代码运行变慢。不要使用它们 第3章 函数作用域和块作用域 3.1 函数中的作用域 属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。 function foo(a) { var b = 2; // 一些代码 function bar() { // ... } // 更多的代码 var c = 3; } foo(..)作用域中包含了标识符（变量、函数）a、b、c和bar。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处的作用域。 全局作用域只包含一个标识符：foo。 3.2 隐藏内部实现 最小特权原则（最小授权或最小暴露原则）：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都”隐藏“起来，比如某个模块或对象的API设计。 function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } doSomething( 2 ); // 15 b和doSomethingElse(..)都无法从外部被访问，而只能被doSomething(..)所控制，设计上将具体内容私有化了。 3.2.1 规避冲突 ”隐藏“作用域中的变量和函数带来的另一个好处是可以避免同名标识符之间的冲突。 function foo() { function bar(a) { i = 3; // 修改for循环所属作用域中的i console.log( a + i ); } for (var i = 0; i bar(..)内部的赋值表达式i = 3意外的覆盖了声明在foo(..)内部for循环中的i。 解决方案： 声明一个本地变量，任何名字都可以，例如var i = 3。 采用一个完全不同的标识符名称，例如var j = 3。 规避变量冲突的典型例子： 全局命名空间 第三方库会在全局作用域中声明一个名字足够独特的变量，通常是一个对象，这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。 模块管理 任何库无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显示的导入到另外一个特定的作用域中。 3.3 函数作用域 var a = 2; function foo() { // 上述函数作用域虽然可以将内部的变量和函数定义”隐藏“起来，但是会导致以下2个额外问题。 必须声明一个具名函数foo()，意味着foo这个名称本身”污染“了所在的作用域。 必须显示地通过函数名foo()调用这个函数才能运行其中的代码。 解决方案： var a = 2; (function foo(){ // 上述代码包装函数的声明以(function...开始，函数会被当做函数表达式而不是一个标准的函数声明来处理。 区分函数声明和函数表达式最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。 函数声明：function是声明中的第一个词 函数表达式：不是声明中的第一个词 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 第一个片段中，foo被绑定在所在作用域中，可以直接通过foo()来调用它。 第二个片段中，foo被绑定在函数表达式自身的函数中，而不是所在的作用域。(function foo(){ .. }中foo只能在..所代表的位置中被访问，外部作用域不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 3.3.1 匿名和具名 setTimeout( function() { console.log(\"I wait 1 second!\"); }, 1000 ); 上述是匿名函数表达式，因为function()..没有名称标识符。 函数表达式可以匿名，但函数声明不可以省略函数名。 匿名函数表达式有以下缺点： 在栈追踪中不会显示出有意义的函数名，会使得调试困难。 没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用 递归 事件触发后事件监听器需要解绑自身 匿名函数省略了对于代码可读性/可理解性很重要的函数名。 解决方案： 行内函数表达式可以解决上述问题，始终给函数表达式命名是一个最佳实践。 setTimeout( function timeoutHandler() { // 3.3.2 立即执行函数表达式 立即执行函数表达式（IIFE，Immediately Invoked Function Expression） 匿名/具名函数表达式 第一个（ ）将函数变成表达式，第二个（ ）执行了这个函数 var a = 2; (function IIFE() { var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 改进型(function(){ .. }()) 用来调用的（ ）被移进了用来包装的（ ）中。 当做函数调用并传递参数进去 var a = 2; (function IIFE( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 })( window ); console.log( a ); // 2 解决undefined标识符的默认值被错误覆盖导致的异常 将一个参数命名为undefined，但是在对应的位置不传入任何值，这样就可以保证在代码块中undefined标识符的值真的是undefined。 undefined = true; (function IIFE( undefined ) { var a; if (a === undefined) { console.log(\"Undefined is safe here!\"); } })(); 倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当做参数传递进去 函数表达式def定义在片段的第二部分，然后当做参数（这个参数也叫做def）被传递进IIFE函数定义的第一部分中。最后，参数def（也就是传递进去的函数）被调用，并将window传入当做global参数的值。 var a = 2; (function IIFE( def ) { def( window ); })(function def( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 }); 3.4 块作用域 表面上看JavaScript并没有块作用域的相关功能，除非更加深入了解（with、try/catch 、let、const）。 for (var i = 0; i 上述代码中i会被绑定在外部作用域（函数或全局）中。 var foo = true; if (foo) { var bar = foo * 2; bar = something( bar ); console.log( bar ); } 上述代码中，当使用var声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。 3.4.1 with 块作用域的一种形式，用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效。 3.4.2 try/catch ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch中有效。 try { undefined(); // 执行一个非法操作来强制制造一个异常 } catch (err) { console.log( err ); // 能够正常执行！ } console.log( err )； // ReferenceError: err not found 当同一个作用域中的两个或多个catch分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告，实际上这并不是重复定义，因为所有变量都会安全地限制在块作用域内部。 3.4.3 let ES6引入了let关键字，可以将变量绑定到所在的任意作用域中（通常是{ .. }内部），即let为其声明的变量隐式地劫持了所在的块作用域。 var foo = true; if (foo) { let bar = foo * 2; bar = something( bar ); console.log( bar ); } console.log( bar ); // ReferenceError 存在的问题 用let将变量附加在一个已经存在的的块作用域上的行为是隐式的，如果习惯性的移动这些块或者将其包含在其他的块中，可能会导致代码混乱。 解决方案: 为块作用域显示地创建块。显式的代码优于隐式或一些精巧但不清晰的代码。 var foo = true; if (foo) { { // 在if声明内部显式地创建了一个块，如果需要对其进行重构，整个块都可以被方便地移动而不会对外部if声明的位置和语义产生任何影响。 在let进行的声明不会在块作用域中进行提升 console.log( bar ); // ReferenceError let bar = 2; 1、垃圾收集 function process(data) { // 在这里做点有趣的事情 } var someReallyBigData = { .. }; process( someReallyBigData ); var btn = document.getElementById( \"my_button\" ); btn.addEventListener( \"click\", function click(evt) { console.log(\"button clicked\"); }, /*capturingPhase*/false ); click函数的点击回调并不需要someReallyBigData。理论上当process(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于click函数形成了一个覆盖整个作用域的闭包，JS引擎极有可能依然保存着这个结构（取决于具体实现）。 2、let循环 for (let i = 0; i for循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 { let j; for (j = 0; j 3.4.4 const ES6引用了const，可以创建块作用域变量，但其值是固定的（常量） var foo = true; if(foo) { var a = 2; const b = 3; // 包含在if中的块作用域常量 a = 3; // 正常! b = 4; // 错误! } console.log( a ); // 3 console.log( b ); // ReferenceError! 第4章 变量和函数提升 任何声明在某个作用域内的变量，都将附属于这个作用域。 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 var a = 2;会被看成两个声明，var a;和a = 2;，第一个声明在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。 所有的声明（变量和函数）都会被 “移动” 到各自作用域的最顶端，这个过程叫做 提升 只有声明本身会被提升，而包括函数表达式在内的赋值或其他运行逻辑并不会提升。 a = 2; var a; console.log( a ); // 2 --------------------------------------- // 实际按如下形式进行处理 var a; // 编译阶段 a = 2; // 执行阶段 console.log( a ); // 2 console.log( a ); // undefinde var a = 2; --------------------------------------- // 实际按如下形式进行处理 var a; // 编译 console.log( a ); // undefinde a = 2; // 执行 每个作用域都会进行变量提升 function foo() { var a; console.log( a ); // undefinde a = 2; } foo(); 函数声明会被提升，但是函数表达式不会被提升。 foo(); // 不是ReferenceError，而是TypeError! var foo = function bar() { // ... }; 上面这段程序中，变量标识符foo()被提升并分配给所在作用域，因此foo()不会导致ReferenceError。此时foo并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值），foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常。 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。 foo(); // TypeError bar(); // ReferenceError var foo = function bar() { // ... }; --------------------------------------- // 实际按如下形式进行处理 var foo; foo(); // TypeError bar(); // ReferenceError foo = function() { var bar = ...self... // ... }; 4.1 函数优先 函数声明和变量声明都会被提升，但是，函数首先被提升，然后才是变量 foo(); // 1 var foo; function foo() { console.log( 1 ); }; foo = function() { console.log( 2 ); }; --------------------------------------- // 实际按如下形式进行处理 function foo() { // 函数提升是整体提升，声明 + 赋值 console.log( 1 ); }; foo(); // 1 foo = function() { console.log( 2 ); }; var foo尽管出现在function foo()...的声明之前，但它是重复的声明，且函数声明会被提升到普通变量之前，因此被忽略 后面出现的函数声明可以覆盖前面的。 foo(); // 3 function foo() { console.log( 1 ); }; var foo = function() { console.log( 2 ); }; function foo() { console.log( 3 ); }; 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，不会被条件判断所控制。尽量避免在普通块内部声明函数。 foo(); // \"b\" var a = true; if (a) { function foo() { console.log( \"a\" ); }; } else { function foo() { console.log( \"b\" ); }; } 第5章 作用域闭包 5.1 闭包 当函数可以记住并访问所在的词法作用域，即使函数名是在当前词法作用域之外执行，这时就产生了闭包。 function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); // 2 ---- 这就是闭包的效果 bar()在自己定义的词法作用域以外的地方执行。 bar()拥有覆盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供bar()在之后任何时间进行引用，不会被垃圾回收器回收 bar()持有对foo()内部作用域的引用，这个引用就叫做闭包。 // 对函数类型的值进行传递 function foo() { var a = 2; function baz() { console.log( a ); // 2 } bar( baz ); } function bar(fn) { fn(); // 这就是闭包 } foo(); 把内部函数baz传递给bar，当调用这个内部函数时（现在叫做fn），它覆盖的foo()内部作用域的闭包就形成了，因为它能够访问a。 // 间接的传递函数 var fn; function foo() { var a = 2; function baz() { console.log( a ); } fn = baz; // 将baz分配给全局变量 } function bar() { fn(); // 这就是闭包 } foo(); bar(); // 2 将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 function wait(message) { setTimeout( function timer() { console.log( message ); }, 1000 ); } wait( \"Hello, closure!\" ); 在引擎内部，内置的工具函数setTimeout(..)持有对一个参数的引用，这里参数叫做timer，引擎会调用这个函数，而词法作用域在这个过程中保持完整。这就是闭包 定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ // 典型的闭包例子：IIFE var a = 2; (function IIFE() { console.log( a ); })(); 5.2 循环和闭包 for (var i = 1; i 延迟函数的回调会在循环结束时才执行，输出显示的是循环结束时i的最终值。 尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i，若使用let 定义i ，则每次调用都会产生一个单独的块级作用域，就会输出1-5 尝试方案1：使用IIFE增加更多的闭包作用域 for (var i = 1; i 尝试方案2：IIFE增加变量 for (var i = 1; i 尝试方案3：改进型，将i作为参数传递给IIFE函数 for (var i = 1; i 5.2.1 块作用域和闭包 let可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域 for (var i = 1; i for循环头部的let声明会有一个特殊的行为。变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 上面这句话参照3.4.3–---2.let循环，即以下 { let j; for (j = 0; j 循环改进： for (let i = 1; i 5.3 模块 模块模式需要具备两个必要条件： 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例，可以通过IIFE实现单例模式） 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 function CoolModule() { var something = \"cool\"; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( \" ! \") ); } return { doSomething: doSomething, doAnother: doAnother } } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 // 1、必须通过调用CoolModule()来创建一个模块实例 // 2、CoolModule()返回一个对象字面量语法{ key: value, ... }表示的对象，对象中含有对内部函数而不是内部数据变量的引用。内部数据变量保持隐藏且私有的状态。 使用IIFE实现单例模式 立即调用这个函数并将返回值直接赋予给单例的模块标识符foo。 var foo = (function CoolModule() { var something = \"cool\"; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( \" ! \") ); } return { doSomething: doSomething, doAnother: doAnother } })(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 5.5.1 现代的模块机制 大多数模块依赖加载器/管理器本质上是将这种模块定义封装进一个友好的API。 var MyModules = (function Manager() { var modules = {}; function define(name, deps, impl) { for (var i = 0; i 使用上面的函数来定义模块： MyModules.define( \"bar\", [], function() { function hello(who) { return \"Let me introduct: \" + who; } return { hello: hello }; } ); MyModules.define( \"foo\", [\"bar\"], function(bar) { var hungry = \"hippo\"; function awesome() { console.log( bar.hello( hungry ).toUpperCase() ); } return { awesome: awesome }; } ); var bar = MyModules.get( \"bar\" ); var foo = MyModules.get( \"foo\" ); console.log( bar.hello( \"hippo\" ); ) // Let me introduct: hippo foo.awesome(); // LET ME INTRODUCT: HIPPO 5.5.2 未来的模块机制 在通过模块系统进行加载时，ES6会将文件当做独立的模块来处理。每个模块都可以导入其他模块或特定的API成员，同样可以导出自己的API成员。 ES6模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块） 基于函数的模块不能被静态识别（编译器无法识别），只有在运行时才会考虑API语义，因此可以在运行时修改一个模块的API。 ES6模块API是静态的（API模块不会在运行时改变），会在编译期检查对导入模块的API成员的引用是否真实存在。 // bar.js function hello(who) { return \"Let me introduct: \" + who; } export hello; // foo.js // 仅从“bar”模块导入hello() import hello from \"bar\"; var hungry = \"hippo\"; function awesome() { console.log( hello( hungry ).toUpperCase(); ); } export awesome; // baz.js // 导入完整的“foo”和”bar“模块 module foo from \"foo\"; module bar from \"bar\"; console.log( bar.hello( \"rhino\") ); // Let me introduct: rhino foo.awesome(); // LET ME INTRODUCT: HIPPO import：将一个模块中的一个或多个API导入到当前作用域中，并分别绑定在一个变量上 module：将整个模块的API导入并绑定到一个变量上。 export：将当前模块的一个标识符（变量、函数）导出为公共API 附录A 动态作用域 词法作用域是在写代码或者定义时确定的，关注函数在何处声明，作用域链基于代码嵌套。 动态作用域是在运行时确定的（this也是），关注函数从何处调用，作用域链基于调用栈。 JavaScript并不具备动态作用域，它只有词法作用域。但是this机制某种程度上很像动态作用域。 // 词法作用域，关注函数在何处声明，a通过RHS引用到了全局作用域中的a function foo() { console.log( a ); // 2 } function bar() { var a = 3; foo(); } var a = 2; bar(); ----------------------------- // 动态作用域，关注函数从何处调用，当foo()无法找到a的变量引用时，会顺着调用栈在调用foo()的地方查找a function foo() { console.log( a ); // 3(不是2！) } function bar() { var a = 3; foo(); } var a = 2; bar(); 附录B 块作用域的替代方案 ES3开始，JavaScript中就有了块作用域，包括with和catch分句。 // ES6环境 { let a = 2; console.log( a ); // 2 } console.log( a ); // ReferenceError 上述代码在ES6环境中可以正常工作，但是在ES6之前的环境中如何实现呢？ 答案是使用catch分句，这是ES6中大部分功能迁移的首选方式。 try { throw 2; } catch (a) { console.log( a ); // 2 } console.log( a ); // ReferenceError B.1 Traceur Google 维护着一个名为Traceur 的项目，该项目正是用来将ES6 代码转换成兼容ES6 之前 的环境; ```Js // 代码转换成如下形式 { try { throw undefined; } catch (a) { a = 2; console.log( a ); // 2 } } console.log( a ); // ReferenceError #### B.2 隐式和显式作用域 `let`声明会创建一个显式的作用域并与其进行绑定，而不是隐式地劫持一个已经存在的作用域（对比前面的`let`定义）。 ```Js let (a = 2) { console.log( a ); // 2 } console.log( a ); // ReferenceError 存在的问题： let声明不包含在ES6中，Traceur编译器也不接受这种代码 方案一：使用合法的ES6语法并且在代码规范上做一些妥协 /*let*/ { let a = 2; console.log( a ); } console.log( a ); // ReferenceError 方案二：使用let-er工具，生成完全标准的ES6代码，不会生成通过try/catch进行hack的ES3替代方案 { let a = 2; console.log( a ); } console.log( a ); // ReferenceError B.3 性能 try/catch的性能的确很糟糕，但技术层面上没有合理的理由来说明try/catch必须这么慢，或者会一直慢下去。 IIFE和try/catch不是完全等价的，因为如果把一段代码中的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的this、return、break和continue都会发生变化。IIFE并不是一个普适的方案，只适合在某些情况下进行手动操作。 第二部分 this和对象原型 第1章 关于this this既不指向函数自身也不指向函数的词法作用域 this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。this和词法作用域是不一样的，不能混合使用。 当一个函数被调用时，会创建一个活动记录（执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。 // 使用this，提供一种优雅的方式隐式“传递”一个对象引用。API设计更加简洁并且易于复用。 function identify() { return this.name.toUpperCase(); } function speak() { var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting ); } var me = { name: \"Kyle\" }; var you = { name: \"Reader\" }; identify.call( me ); // KYLE identify.call( you ); // READER speak.call( me ); // Hello, I'm KYLE speak.call( you ); // Hello, I'm READER // ----------------------------------------------- // 词法作用域方案，显式传递上下文对象方式，会让代码变得越来越混乱 function identify(context) { return context.name.toUpperCase(); } function speak(context) { var greeting = \"Hello, I'm \" + identify( context ); console.log( greeting ); } identify( you ); // READER speak.call( me ); // Hello, I'm KYLE 第2章 this全面解析 2.1 调用位置 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。 查找方法： 分析调用栈：调用位置就是当前正在执行的函数的前一个调用中 function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // bar --> foo // 因此，当前调用位置在bar中 console.log( \"foo\" ); } baz(); // 使用开发者工具得到调用栈： 设置断点或者插入debugger;语句，运行时调试器会在那个位置暂停，同时展示当前位置的函数调用列表，这就是调用栈。找到栈中的第二个元素，这就是真正的调用位置。 2.2 绑定规则 2.2.1 默认绑定 独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。 function foo() { // 运行在严格模式下，this会绑定到undefined \"use strict\"; console.log( this.a ); } var a = 2; // 调用 foo(); // TypeError: this is undefined // -------------------------------------- function foo() { // 运行 console.log( this.a ); } var a = 2; (function() { // 严格模式下调用函数则不影响默认绑定 \"use strict\"; foo(); // 2 })(); 2.2.2 隐式绑定 当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 隐式丢失 被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。 // 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。 // bar()是一个不带任何修饰的函数调用，应用默认绑定。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名 var a = \"oops, global\"; // a是全局对象的属性 bar(); // \"oops, global\" 参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。 function foo() { console.log( this.a ); } function doFoo(fn) { // fn其实引用的是foo fn(); // 2.2.3 显式绑定 通过call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。 function foo() { console.log( this.a ); } var obj = { a: 2 }; foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 显示绑定无法解决丢失绑定问题。 解决方案： 1、硬绑定 创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。 function foo() { console.log( this.a ); } var obj = { a: 2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的bar不可能再修改它的this bar.call( window ); // 2 典型应用场景是创建一个包裹函数，负责接收参数并返回值。 function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 创建一个可以重复使用的辅助函数。 function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); } } var obj = { a: 2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数，用法如下。 function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = foo.bind( obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 2、API调用的“上下文” JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。 function foo(el) { console.log( el, this.id ); } var obj = { id: \"awesome\" } // 调用foo(..)时把this绑定到obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 2.2.4 new绑定 在JS中，构造函数只是使用new操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。 包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1、创建（或者说构造）一个新对象。 2、这个新对象会被执行[[Prototype]]连接。 3、这个新对象会绑定到函数调用的this。 4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 使用new来调用foo(..)时，会构造一个新对象并把它（bar）绑定到foo(..)调用中的this。 function foo(a) { this.a = a; } var bar = new foo(2); // bar和foo(..)调用中的this进行绑定 console.log( bar.a ); // 2 2.3 this绑定优先级 new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断： 函数是否在new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 就是这样。对于正常的函 st=>start: Start e=>end: End cond1=>condition: new绑定 op1=>operation: this绑定新创建的对象， var bar = new foo() cond2=>condition: 显示绑定 op2=>operation: this绑定指定的对象， var bar = foo.call(obj2) cond3=>condition: 隐式绑定 op3=>operation: this绑定上下文对象， var bar = obj1.foo() op4=>operation: 默认绑定 op5=>operation: 函数体严格模式下绑定到undefined， 否则绑定到全局对象， var bar = foo() st->cond1 cond1(yes)->op1->e cond1(no)->cond2 cond2(yes)->op2->e cond2(no)->cond3 cond3(yes)->op3->e cond3(no)->op4->op5->e 在new中使用硬绑定函数的目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）。 function foo(p1, p2) { this.val = p1 + p2; } // 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么 // 反正使用new时this会被修改 var bar = foo.bind( null, \"p1\" ); var baz = new bar( \"p2\" ); baz.val; // p1p2 2.4 this优先级绑定例外 2.4.1 被忽略的this 把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。 下面两种情况下会传入null 使用apply(..)来“展开”一个数组，并当作参数传入一个函数 bind(..)可以对参数进行柯里化（预先设置一些参数） function foo(a, b) { console.log( \"a:\" + a + \"，b:\" + b ); } // 把数组”展开“成参数 foo.apply( null, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( null, 2 ); bar( 3 ); // a:2，b:3 总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。 更安全的this 安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。 JS中创建一个空对象最简单的方法是Object.create(null)，这个和{}很像，但是并不会创建Object.prototype这个委托，所以比{}更空。 function foo(a, b) { console.log( \"a:\" + a + \"，b:\" + b ); } // 我们的空对象 var ø = Object.create( null ); // 把数组”展开“成参数 foo.apply( ø, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( ø, 2 ); bar( 3 ); // a:2，b:3 2.4.2 间接引用 间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。 // p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo() function foo() { console.log( this.a ); } var a = 2; var o = { a: 3, foo: foo }; var p = { a: 4}; o.foo(); // 3 (p.foo = o.foo)(); // 2 2.4.3 软绑定 硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。 如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。 // 默认绑定规则，优先级排最后 // 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this if(!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有curried参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; }; } 使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。 function foo() { console.log(\"name:\" + this.name); } var obj = { name: \"obj\" }, obj2 = { name: \"obj2\" }, obj3 = { name: \"obj3\" }; // 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj // 隐式绑定规则 obj2.foo = foo.softBind( obj ); obj2.foo(); // name: obj2 2.5 this词法 ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this. foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改(new也不行)。 function foo() { // 返回一个箭头函数 return (a) => { // this继承自foo() console.log( this.a ); }; } var obj1 = { a: 2 }; var obj2 = { a: 3 } var bar = foo.call( obj1 ); bar.call( obj2 ); // 2，不是3！ 箭头函数可以像bind(..) 一样确保函数的this 被绑定到指定对象 ES6之前和箭头函数类似的模式，采用的是词法作用域取代了传统的this机制。 function foo() { var self = this; // lexical capture of this setTimeout( function() { console.log( self.a ); // self只是继承了foo()函数的this绑定 }, 100 ); } var obj = { a: 2 }; foo.call(obj); // 2 代码风格统一问题：如果既有this风格的代码，还会使用 seft = this 或者箭头函数来否定this机制。 只使用词法作用域并完全抛弃错误this风格的代码； 完全采用this风格，在必要时使用bind(..)，尽量避免使用 self = this 和箭头函数。 小结 如果要判断一个运行中函数的this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断this 的绑定对象。 由new 调用？绑定到新创建的对象。 由call 或者apply（或者bind）调用？绑定到指定的对象。 由上下文对象调用？绑定到那个上下文对象。 默认：在严格模式下绑定到undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略this 绑 定，你可以使用一个DMZ 对象，比如ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的this 绑定（无论this 绑定到什么）。这 其实和ES6 之前代码中的self = this 机制一样。 第3章 对象 3.1 语法 文字形式和构造形式生成的对象是一样的。 文字（声明）形式 var myObj = { key: value // ... } 构造形式 var myObj = new Object(); myObj.key = value; 3.2 类型 基本数据类型：string、number、boolean、null、undefined、symbol 上述6种数据类型本身不是对象，”JS中万物皆是对象“的说法是错误的 typeof null返回字符串”object“，实际上，null本身是基本数据类型，这是语言本身的一个bug。(原理是这样：不同的对象在底层都表示为二进制，在JS中二进制前三位都为0的话会被判断为object类型，null的二进制表示是全0，自然前三位也是0，所以执行typeof时会返回”object“) 引用数据类型：统称为object类型，称作对象子类型（内置对象），细分有String、Number、Boolean、Object、Function、Array、Date、RegExp、Error var strPrimitive = \"I am a string\"; typeof strPrimitive; // \"string\" strPrimitive instanceof String; // false var strObject = new String(\"I am a string\"); typeof strObject; // \"object\" strObject instanceof String; // true // 检查sub-type对象 // 可以认为子类型在内部借用了Object中的toString()方法 Object.prototype.toString.call( strObject ); // [object String] 上述strPrimitive并不是一个对象，只是一个字面量，并且是一个不可变的值。如果需要执行一些操作，比如获取长度、访问其中某个字符等，那需要转换成String对象。 JS引擎会自动把字面量转换成String对象，所以可以访问属性和方法。数值字面量和布尔字面量同理。 var strPrimitive = \"I am a string\"; console.log( strPrimitive.length ); // 13 console.log( strPrimitive.charAt( 3 ) ); // \"m\" null和undefined没有对应的构造形式，Date只有构造，没有文字形式。 Object、Array、Function和RegExp（正则表达式），无论使用文字形式还是构造形式，它们都是对象，不是字面量。 3.3 内容 对象的内容是由一些存储在特定命名位置的值（任意类型的）组成的，称之为属性。 引擎内部，属性的值一般不保存在对象容器内部，存储在对象容器内部的是这些属性的名称，通过引用指向这些值真正的存储位置。 .a语法称为”属性访问“，[\"a\"]语法称为”键访问“。它们访问的是同一个位置。 var myObject = { a: 2 }; myObject.a; // 2 属性 值 myObject[\"a\"]; // 2 键 值 [\"..\"]语法使用字符串来访问属性，可以在程序中构造这个字符串 var myObject = { a: 2 }; var idx; if (true) { idx = \"a\"; } // 之后 console.log( myObject[idx] ); // 2 对象属性名永远是字符串，如果是其他类型，则会转换为一个字符串，数字也不例外。 var myObject = { }; myObject[true] = \"foo\"; myObject[3] = \"bar\"; myObject[myObject] = \"baz\"; myObject[\"true\"]; // \"foo\"; myObject[\"3\"]; // \"bar\"; myObject[\"[object Object]\"]; // \"baz\"; 3.3.1 可计算属性名 ES6增加可计算属性名，可以在文字形式中使用[ ]包裹一个表达式来当做属性名 var prefix = \"foo\"; var myObject = { [prefix + \"bar\"]: \"hello\", [prefix + \"baz\"]: \"world\" }; myObject[\"foobar\"]; // hello myObject[\"foobaz\"]; // world 3.3.2 属性与方法 技术角度来说，函数永远不会”属于“一个对象。有些函数具有this引用，有时候这些this确实会指向调用位置的对象引用。但是这是this在运行时根据调用位置动态绑定的，本质上并没有把一个函数变成一个”方法“，函数和对象的关系最多只能是间接关系。 function foo() { console.log( \"foo\" ); } var someFoo = foo; // 对foo的变量引用 var myObject = { someFoo: foo }; // 对同一个对象的不同引用 foo; // function foo(){..} someFoo; // function foo(){..} myObject.someFoo; // function foo(){..} 3.3.3 数组 数组期望的是数值下标，索引是非负数。 var myArray = [ \"foo\", 42, \"bar\" ]; myArray.length; // 3 myArray[0]; // \"foo\" myArray[2]; // \"bar\" 数组也是对象，可以给数组添加属性。（数组的length值并未发生变化） var myArray = [ \"foo\", 42, \"bar\" ]; myArray.baz = \"baz\"; myArray.length; // 3 myArray.baz; // \"baz\" 如果添加的属性名”看起来“像一个数字，那它会变成一个数值下标。会修改数组的内容而不是添加一个属性。 var myArray = [ \"foo\", 42, \"bar\" ]; myArray[\"3\"] = \"baz\"; myArray.length; // 4 myArray[3]; // \"baz\" 3.3.4 复制对象 function anotherFunction() { /*..*/ } var anotherObject = { c: true }; var anotherArray = []; var myObject = { a: 2, b: anotherObject, // 引用，不是复本！ c: anotherArray, // 另一个引用！ d: anotherFunction } anotherArray.push( anotherObject, myObject ); 对于浅拷贝（浅复制）：新对象中的a是复制的，但是b、c、d只是三个引用，和旧对象中是一样的。 Object.assign(..)，ES6新增，第一个参数是目标对象，之后跟一个或多个源对象。遍历所有源对象的所有可枚举（enumerable）的自有键（owned key）,并把它们复制（使用=操作符赋值）到目标对象，最后返回目标对象。 var newObj = Object.assign( {}, myObject ); newObj.a; // 2 newObj.b === anotherObject; // true newObj.c === anotherArray; // true newObj.d === anotherFunction; // true 对于深拷贝（深复制）：除了复制myObject以外，还会复制anotherObject和anotherArray，问题在于anotherArray还引用了anotherObject和myObject，这样就由于循环引用导致死循环。 JSON安全（可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象） var newObj = JSON.parse( JSON.stringify( someObj ) ); 3.3.5 属性描述符 ES5开始，所有的属性都具备了属性描述符（数据描述符）。 Object.getOwnPropertyDescriptor(..)：获取对象属性对应的属性描述符 var myObject = { a: 2 }; Object.getOwnPropertyDescriptor( myObject, \"a\"); // { // value: 2, // writable: true, // 可写 // enumerable: true, // 可枚举 // configurable: true // 可配置 // } Object.defineProperty(..)：添加新属性或者修改已有属性（configurable为true） var myObject = {}; Object.defineProperty( myObject, \"a\", { value: 2, writable: true, enumerable: true, configurable: true }); myObject.a; // 2 1、Writable：属性的值是否可修改。 false时，对于属性值的修改静默失败（silently failed）。严格模式下，产生TypeError错误。 2、configurable：属性是否可配置。 true时，使用defineProperty(..)修改属性描述符。 false时，尝试使用defineProperty(..)会产生TypeError错误（无论是不是严格模式）。改成false是单向操作，无法撤销！ false时，还是可以把writable的状态由true改为false，但是无法由false改为true。 false时，禁止删除这个属性。delete myObject.a会静默失败。 3、enumerable：属性是否会出现在对象的属性枚举中，比如说for..in循环 3.3.6 不变性 实现属性或者对象不可改变的方法有如下多种，但是所有的方法创建的都是浅不变性，只会影响目标对象和它的直接属性。 1、对象常量 writable:false和configurable:false可以创建常量属性（不可修改、重定义或者删除）。 var myObject = {}; Object.defineProperty( myObject, \"FAVORITE_NUMBER\", { value: 42, writable: false, configurable: false } ); 2、禁止扩展 Object.preventExtensions(..)，禁止一个对象添加新属性并且保留已有属性。 非严格模式下，创建属性b会静默失败。严格模式下，抛出TypeError错误。 var myObject = { a:2 }; Object.preventExtensions( myObject ); myObject.b = 3; myObject.b; // undefined 3、密封 Object.seal(..)，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（但是可以修改属性的值）。 内部会调用Object.preventExtensions(..)并把所有现有属性标记为configurable:false。 4、冻结 Object.freeze(..)，禁止对于对象本身及其任意直接属性的修改（引用对象不受影响）。 内部调用Object.seal(..)并把所有现有属性标记为writable:false。这样就无法修改属性的值。 5、深度冻结 在这个对象上调用Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用Object.freeze(..)。但是这样有可能会在无意中冻结其他（共享）对象。 3.3.7 [[Get]] var myObject = { a: 2 }; myObject.a; // 2 对象默认的[[Get]]操作可以控制属性值的获取 myObject.a在myObject上实现了[[Get]]操作（有点像函数调用：[[Get]]()）。 st=>start: Start e=>end: End op1=>operation: myObject.a执行[[Get]]操作 cond1=>condition: 对象中是否有名称相同的属性 op2=>operation: 查找成功，返回属性值 op3=>operation: 没有找到，遍历可能存在的[[Prototype]]链 cond2=>condition: 原型链是否查找成功 op4=>operation: 最终没有找到，返回undefined st->op1->cond1 cond1(yes)->op2->e cond1(no)->op3->cond2 cond2(yes)->op2 cond2(no)->op4->e 变量访问和对象属性访问的区别 st=>start: Start e=>end: End cond1=>condition: 变量访问 op1=>operation: 查找词法作用域 op11=>operation: 对象属性访问 op2=>operation: [[Get]]操作 cond3=>condition: 是否查找成功 op3=>operation: 查找成功，返回变量值 op4=>operation: 查找失败，抛出 ReferenceError异常 cond4=>condition: 是否查找成功 op5=>operation: 查找成功，返回属性值 op6=>operation: 查找失败， 返回undefined st->cond1 cond1(yes)->op1->cond3 cond1(no)->op11->op2->cond4 cond3(yes)->op3->e cond3(no)->op4->e cond4(yes)->op5->e cond4(no)->op6->e 由于仅根据返回值无法判断出到底变量的值为undefined还是变量不存在，所以[[Get]]操作返回了undefined var myObject = { a: undefined }; myObject.a; // undefined myObject.b; // undefined 3.3.8 [[Put]] 误解：可能会认为给对象的属性赋值会触发[[Put]]来设置或者创建这个属性。实际情况并不完全如此。 [[Put]]被触发时，实际行为取决于很多因素，包括对象中是否已经存在这个属性（这是最重要的因素）。 对象默认的[[Put]]操作可以控制属性值的设置 st=>start: Start e=>end: End cond1=>condition: 属性是否存在 op11=>operation: 请看第5章[[Prototype]] cond2=>condition: 是否是访问描述符 (参见3.3.9) op1=>operation: 存在setter就调用setter cond3=>condition: 数据描述符中 writable为false？ op2=>operation: 非严格模式下静默失败， 严格模式下抛出TypeError异常 op3=>operation: 将该值设置为属性的值 st->cond1 cond1(yes)->cond2 cond1(no)->op11 cond2(yes)->op1->e cond2(no)->cond3 cond3(yes)->op2->e cond3(no)->op3->e 3.3.9 Getter和Setter ES5中可以使用getter和setter部分改写[[Get]]和[[Put]]的默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter和setter是隐藏函数。 当给属性定义getter、setter或者两者都有时，这个属性会被定义为”访问描述符“（和”数据描述符“相对）。会忽略它们的value和writable特性。关心的是set和get(还有configurable和enumerable)特性。 // 对象文字语法 var myObject = { // 给a定义一个getter get a() { return 2; } }; // defineProperty(..)显式定义 Object.defineProperty( myObject, // 目标对象 \"b\", // 属性名 { // 给b设置一个getter访问描述符 get: function() { return this.a * 2 }, // 确保b会出现在对象的属性列表中 enumerable: true } ); myObject.a; // 2 myObject.b; // 4 myObject.a = 3; // 没有定义setter，set操作无效 myObject.a; // 2 定义setter var myObject = { // 给a定义一个getter get a() { return this._a_; // _a_ 只是一种惯例，没有任何特殊的行为，和其他普通属性一样 }, // 给a定义一个setter set a(val) { this._a_ = val * 2; } }; myObject.a = 2; myObject.a; // 4 3.3.10 存在性 in：检查属性名是否在对象及其[[Prototype]]原型链中 对数组来说，4 in [2, 4, 6]返回false，因为这个数组包含的属性名是0、1、2 hasOwnProperty(..)：只会检查属性名是否在对象中 对于Object.create(null)对象没有连接到Object.prototype，此时需要Object.prototype.hasOwnProperty.call(myObject, \"a\")显式绑定到myObject。 var myObject = { a: 2 }; (\"a\" in myObject); // true (\"b\" in myObject); // false myObject.hasOwnProperty( \"a\" ); // true myObject.hasOwnProperty( \"b\" ); // false for..in循环：遍历对象的可枚举属性名列表，包括[[Prototype]]原型链。 对于数组，不仅会包含所有数值索引，还会包含所有可枚举属性。遍历数组使用传统for循环 propertyIsEnumerable(..)：只检查属性名是否在对象中并且enumerable:true。 Object.keys(..)：只查找属性名是否在对象中，返回一个数组，包含所有可枚举属性名。 Object.getOwnPropertyNames(..)：只查找属性名是否在对象中，返回一个数组，包含所有属性名，无论是否可枚举。 var myObject = {}; Object.defineProperty( myObject, \"a\", // 让a像普通属性一样可以枚举 { enumerable: true, value: 2 } ); Object.defineProperty( myObject, \"b\", // 让b不可枚举 { enumerable: false, value: 3} ); myObject.b; // 3 (\"b\" in myObject); // true myObject.hasOwnProperty( \"b\" ); // true for(var k in myObject) { console.log( k, myObject[k] ); } // \"a\" 2 myObject.propertyIsEnumerable( \"a\" ); // true myObject.propertyIsEnumerable( \"b\" ); // false Object.keys( myObject ); // [\"a\"] Object.getOwnPropertyNames( myObject ); // [\"a\", \"b\"] 3.4 遍历 遍历对象属性时的顺序是不确定的。 forEach(..)遍历数组中的所有值并忽略回调函数的返回值。 every(..)一直运行直到回调函数返回false（或者“假”值），会提前终止遍历 some(..)一直运行直到回调函数返回true（或者“真”值），会提前终止遍历 for..of：直接遍历值 数组：直接遍历值而不是数组下标。 var myArray = [ 1, 2, 3 ]; for(var v of myArray) { console.log( v ); } // 1 // 2 // 3 数组有内置的`@@iterator`，因此`for..of`可以直接应用在数组上。使用ES6的`Symbol.iterator`来获取对象的`@@iterator`内部属性。`@@iterator`本身并不是一个迭代器对象，而是一个**返回迭代器对象的函数**。 ```Js // 手动遍历数组 var myArray[ 1, 2, 3 ]; var it = myArray[Symbol.iterator](); it.next(); // { value: 1, done: false } it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { done: true } ``` 对象：定义了迭代器就可以遍历。先向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法遍历所有值。 普通对象没有内置的@@iterator，无法自动完成for..of遍历。 // 手动给对象定义@@iterator var myObject = { a: 2, b: 3 }; Object.defineProperty( myObject, Symbol.iterator, { enumerable: false, writable: false, configurable: true, value: function() { var o = this; var idx = 0; var ks = Object.keys( o ); return { next: function() { return { value: o[ks[idx++]], done: (idx > ks.length) // 结束条件 } } } } } ); // 手动遍历myObject var it = myArray[Symbol.iterator](); it.next(); // { value: 2, done: false } it.next(); // { value: 3, done: false } it.next(); // { value: undefined, done: true } // 用for..of遍历myObject for (var v of myObject ) { console.log( v ); } // 2 // 3 第4章 混合对象“类” 类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JS也有类似的语法，但是和其他语言中的类完全不同。 类意味着复制。 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 多态（在继承链的不同层次名称相同但是功能不同的函数）看起来似乎是从子类引用父类，但是本质上引用的是复制的结果。 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 JS并不会（像类那样）自动创建对象的副本，不会自动执行复制行为。 混入模式（无论显式还是隐式）可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态（OtherObj.methodName.call(this, ...)）,会让代码更加难懂并且难以维护。 显式混入实际上无法完全模拟类的复制行为，因为对象（函数也是对象）只能复制引用，无法复制被引用的对象或者函数本身。 在JS中模拟类是得不偿失的。 4.1 混入 混入用来模拟类的复制行为。 4.1.1 显式混入 混入处理的已经不再是类了，因为在JS中不存在类，Vehicle和Car都是对象，进行复制和粘贴。 // 非常简单的mixin(..)例子： function mixin( sourceObj, targetObj ) { for(var key in sourceObj) { // 只会在不存在的情况下复制 if(!(key in targetObj)) { targetObj[key] = sourceObj[key]; } } return targetObj; } var Vehicle = { engines: 1, ignition: function() { console.log( \"Turning on my engine.\" ); }, drive: function() { this.ignition(); console.log( \"Steering and moving forward!\" ); } }; var Car = mixin( Vehicle, { wheels: 4, drive: function() { Vehicle.drive.call( this ); // 显示多态(伪多态)调用，因为Vehicle和Car中都有drive console.log( \"Rolling on all\" + this.wheels + \"wheels!\" ); } } ); 另一种混入模式，先复制然后对Car进行特殊化，可以跳过存在性检查。不如第一种方法常用。 // 可能有重写风险 function mixin( sourceObj, targetObj ) { for(var key in sourceObj) { targetObj[key] = sourceObj[key]; } return targetObj; } var Vehicle = { // ... }; // 首先创建一个空对象并把Vehicle的内容复制进去 var Car = mixin( Vehicle, { }); // 然后把新内容复制到Car中 mixin( { wheels: 4, drive: function() { // ... } }, Car ); 寄生继承，既是显式的又是隐式的 // “传统的JS类” Vehicle function Vehicle() { this.engines = 1; } Vehicle.prototype.ignition = function() { console.log( \"Turning on my engine.\" ); }; Vehicle.prototype.drive = function() { this.ignition(); console.log( \"Steering and moving forward!\" ); } // \"寄生类\"Car function Car() { // 首先，car是一个Vehicle var car = new Vehicle(); // 接着我们对car进行定制 car.wheels = 4; // 保存到Vehicle::drive()的特殊引用 var vehDrive = car.drive(); // 重写Vehicle::drive() car.drive = function() { vehDrive.call( this ); console.log( \"Rolling on all \" + this.wheels + \" wheels!\" ); } return car; } var myCar = new Car(); myCar.drive(); // Turning on my engine. // Steering and moving forward! // Rolling on all 4 wheels! 调用new Car()时会创建一个新对象并绑定到Car的this上，上述代码没有使用这个新对象而是返回了我们自己的car对象，最初创建的这个对象会被丢弃。因此可以不使用new关键字调用Car()。结果是一致的，但是可以避免创建并丢弃多余的对象。 4.1.2 隐式混入 var Something = { cool: function() { this.greeting = \"Hello World\"; this.count = this.count ? this.count + 1 : 1; } }; Something.cool(); Something.greeting; // \"Hello World\" Something.count; // 1 var Another = { cool: function() { // 隐式把Something混入Another Something.cool.call( this ); } }; Another.cool(); Another.greeting; // \"Hello World\" Another.count; // 1 (count不是共享状态) 第5章 原型 5.1 [[Prototype]] 使用for..in 遍历对象时原理和查找[[Prototype]] 链类似，任何可以通过原型链访问到 （并且是enumerable，参见第3 章）的属性都会被枚举。使用in 操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）： 5.1.1 Object.prototype 所有普通的[[Prototype]] 链最终都会指向内置的Object.prototype。由于所有的“普通” （内置，不是特定主机的扩展）对象都“源于”（或者说把[[Prototype]] 链的顶端设置为） 这个Object.prototype 对象. 5.1.2 属性设置和屏蔽 如果属性名foo 既出现在myObject 中也出现在myObject 的[[Prototype]] 链上层， 那么就会发生屏蔽。 ，只读属性会阻止[[Prototype]] 链下层 隐式创建（屏蔽）同名属性。这样做主要是为了模拟类属性的继承。 5.2 \"类\" 5.2.1 “类”函数 5.2.2 “构造函数” 函数不是构造函数，但是当且仅当使用new 时，函数调用会变成“构造函数调用”。 function Foo() { // ... } Foo 和你程序中的其他函数没有任何区别。函数本身并不是构造函数，然而，当你在普通的函数调用前面加上new关键字之后，就会把这个函数调用变成一个“构造函数调用”。实际上，new 会劫持所有普通函数并用构造对象的形式来调用它。 5.2.3 prototype改变导致constructor改变 Foo.prototype 的.constructor 属性只是Foo 函数在声明时的默认属性。如果你创建了一个新对象并替换了函数默认的.prototype 对象引用，那么新对象并不会自动获.constructor 属性。 思考下面的代码： function Foo() { /* .. */ } Foo.prototype = { /* .. */ }; // 创建一个新原型对象 var a1 = new Foo(); a1.constructor === Foo; // false! a1.constructor === Object; // true! Object(..) 并没有“构造”a1，对吧？看起来应该是Foo()“构造”了它。大部分开发者 都认为是Foo() 执行了构造工作，但是问题在于，如果你认为“constructor”表示“由…… 构造”的话，a1.constructor 应该是Foo，但是它并不是Foo ！ a1 并没有.constructor 属性，所以它会委托[[Prototype]] 链上的Foo. prototype。但是这个对象也没有.constructor 属性（不过默认的Foo.prototype 对象有这 个属性！），所以它会继续委托，这次会委托给委托链顶端的Object.prototype。这个对象 有.constructor 属性，指向内置的Object(..) 函数。 5.3 （原型）继承(寄生式组合集成详解) 请参考:寄生式组合继承详解 5.4 对象关联 function Foo() { // ... } Foo.prototype.blah = ...; var a = new Foo(); 我们如何通过内省找出a 的“祖先”（委托关联）呢？第一种方法是站在“类”的角度来 判断： a instanceof Foo; // true instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof 回答 的问题是：在a 的整条[[Prototype]] 链中是否有指向Foo.prototype 的对象？ 可惜,这个方法只能处理对象（a）和函数（带.prototype 引用的Foo）之间的关系。如果你想判断两个对象（比如a 和b）之间是否通过[[Prototype]] 链关联，只用instanceof无法实现。 判断两个对象的关联关系常用方法: b.isPrototypeOf( c ); 注意，这个方法并不需要使用函数（“类”），它直接使用b 和c 之间的对象引用来判断它 们的关系 Object.getPrototypeOf( a );接获取一个对象的[[Prototype]] 链 第6章 行为委托 6.3 对象关联 原型模式和对象关联实现继承的区别 。下面是典型的（“原型”）面向对象风格： function Foo(who) { this.me = who; } Foo.prototype.identify = function() { return \"I am \" + this.me; }; function Bar(who) { Foo.call( this, who ); } Bar.prototype = Object.create( Foo.prototype ); Bar.prototype.speak = function() { alert( \"Hello, \" + this.identify() + \".\" ); }; var b1 = new Bar( \"b1\" ); var b2 = new Bar( \"b2\" ); b1.speak(); b2.speak(); 子类Bar 继承了父类Foo，然后生成了b1 和b2 两个实例。b1 委托了Bar.prototype，后者委托了Foo.prototype。这种风格很常见，你应该很熟悉了。 下面我们看看如何使用对象关联风格来编写功能完全相同的代码： Foo = { init: function(who) { this.me = who; }, identify: function() { return \"I am \" + this.me; } }; Bar = Object.create( Foo ); Bar.speak = function() { alert( \"Hello, \" + this.identify() + \".\" ); }; var b1 = Object.create( Bar ); b1.init( \"b1\" ); var b2 = Object.create( Bar ); b2.init( \"b2\" ); b1.speak(); b2.speak(); 对象关联可以更好地支持关注分离（separation of concerns）原则，创建和初始化并不需要 合并为一个步骤。 6.4 更好的语法 ES6 的class 语法可以简洁地定义类方法，这个特性让class 乍看起来更有吸引力（附录A 会介绍为什么要避免使用这个特性）： class Foo { methodName() { /* .. */ } } 使用简洁方法methodName()存在的问题 var Foo = { bar() { /*..*/ }, baz: function baz() { /*..*/ } }; 由于函数对象本身没有名称标识符， 所以bar() 的缩写形式 （function()..）实际上会变成一个匿名函数表达式并赋值给bar 属性 匿名函数没有name 标识符，这会导致： 调试栈更难追踪； 自我引用（递归、事件（解除）绑定，等等）更难； 代码（稍微）更难理解。 简洁方法会存在第二个问题 如果你需要自我引用的话，那最好使用传统的具名函 数表达式来定义对应的函数（ · baz: function baz(){..}· ），不要使用简洁方法。 6.5 内省 避免使用 if (a1.something) { a1.something(); } 推荐使用isPrototypeOf和getPrototypeOf ```js // 让Foo 和Bar 互相关联 Foo.isPrototypeOf( Bar ); // true Object.getPrototypeOf( Bar ) === Foo; // true // 让b1 关联到Foo 和Bar Foo.isPrototypeOf( b1 ); // true Bar.isPrototypeOf( b1 ); // true Object.getPrototypeOf( b1 ) === Bar; // true ### 附录 A ### ES6 class语法糖 ```js class Widget { constructor(width,height) { this.width = width || 50; this.height = height || 50; this.$elem = null; } render($where){ if (this.$elem) { this.$elem.css( { width: this.width + \"px\", height: this.height + \"px\" } ).appendTo( $where ); } } } class Button extends Widget { constructor(width,height,label) { super( width, height ); this.label = label || \"Default\"; this.$elem = $( \"\" ).text( this.label ); } render($where) { super( $where ); this.$elem.click( this.onClick.bind( this ) ); } onClick(evt) { console.log( \"Button '\" + this.label + \"' clicked!\" ); } } 语法糖的优点 不再引用杂乱的.prototype 了。 Button 声明时直接“ 继承” 了Widget， 不再需要通过Object.create(..) 来替 换.prototype 对象，也不需要设置.proto 或者Object.setPrototypeOf(..)。 可以通过super(..) 来实现相对多态，这样任何方法都可以引用原型链上层的同名方 法。这可以解决第4 章提到过的那个问题：构造函数不属于类，所以无法互相引用——super() 可以完美解决构造函数的问题。 class 字面语法不能声明属性（只能声明方法）。 可以通过extends 很自然地扩展对象（子）类型，甚至是内置的对象（子）类型，比如 rray 或RegExp。 语法糖存在的问题 class并不会像传统面向类的语言一样在声明时静态复制所有行为。如果你（有意或无意）修改或者替换了父“类”中的一个方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于[[Prototype]] 的实时委托; 意外屏蔽问题。 class C { constructor(id) { // 噢，郁闷，我们的id 属性屏蔽了id() 方法 this.id = id; } id() { console.log( \"Id: \" + id ); } } var c1 = new C( \"c1\" ); c1.id(); // TypeError -- c1.id 现在是字符串\"c1 参考:你不知道的JavaScript上卷 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/你不知道的Javascript中.html":{"url":"article/javascript/你不知道的Javascript中.html","title":"2. 读书笔记：你不知道的Javascript中","keywords":"","body":"第一部分 类型和语法第1章 类型第2章 值2.2 字符串数字假与真字符串和数字的转换宽松相等和严格相等第5章 语法第二部分 异步和性能第1章 异步(现在与将来)第2章 回调第3章 PromisePromise链式处理Promise API (详解)Promise的局限性以前的回调函数修改为Promise第6章 生成器生成器使用for ... of第5章 程序性能Web Worker 启动多线程单指令多数据 SIMDasm.js第6章 微性能测试和调优性能测试此文章借阅了精读《你不知道的javascript》中卷中的思维导图，十分感谢！ 第一部分 类型和语法 第1章 类型 JavaScript 有七种内置类型： 空值（null ） 未定义（undefined ） 布尔值（boolean ） 数字（number ） 字符串（string ） 对象（object ） 符号（symbol ，ES6 中新增） typeof null === \"object\" typeof [] === \"object\" //typeof 运算符总是会返回一个字符串： typeof typeof 42; // \"string\" 在对变量执行 typeof 操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为 JavaScript 中的变量没有类型. 第2章 值 类数组：有时需要将类数组（一组通过数字索引的值）转换为真正的数组。通常使用Array.prototype.slice.call(类数组);和Array.from(类数组) 2.2 字符串 字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值 上进行操作。 c = a.toUpperCase(); a === c; // false a; // \"foo\" c; // \"FOO\" 过“借用”数组的非变更方法来处理字符串。 var c = Array.prototype.join.call( a, \"-\" ); var d = Array.prototype.map.call( a, function(v){ return v.toUpperCase() + \".\"; } ).join( \"\" ); c; // \"f-o-o\" d; // \"F.O.O.\" 字符串反转 数组有反转函数reverse()而字符串没有，所以通常将字符串转换成数组。 var a=\"foo\"; var c = a // 将a的值转换为字符数组 .split( \"\" ) // 将数组中的字符进行倒转 .reverse() // 将数组中的字符拼接回字符串 .join( \"\" ); c; // \"oof\" 2.3 数字 0.1 + 0.2 === 0.3; // false 从数学角度来说，上面的条件判断应该为 true ，可结果为什么是 false 呢? 简单来说，二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3 ，而是一个比较接近的数字 0.30000000000000004 ，所以条件判断结果为 false 。 那么应该怎样来判断0.1 + 0.2和0.3是否相等呢? 最常见的方法是设置一个误差范围值，通常称为“机器精度”(machine epsilon)，对 JavaScript 的数字来说，这个值通常是 2^-52 (2.220446049250313e-16)。 在es6中使用Number.EPSILON判断。 if (!Number.EPSILON) { Number.EPSILON = Math.pow(2,-52); } 2.3.3 整数的安全范围 能够被“安全”呈现的最大整数是2^53 - 1，即9007199254740991，在ES6中被定义为 Number.MAX_SAFE_INTEGER 。最小整数是 -9007199254740991 ，在 ES6 中被定义为 Number.MIN_SAFE_INTEGER 。 2.3.4 整数的检测 可以使用 ES6 中的 Number.isInteger(..) 方法 ```js ///Number.isInteger的polyfill if (!Number.isInteger) { Number.isInteger = function(num) { return typeof num == \"number\" && num % 1 == 0; }; } ### 2.4 特殊值 - null 指空值(empty value) - undefined 指没有值(missing value) > **简单值(即标量基本类型值，scalar primitive)总是 通过值复制的方式来赋值 / 传递，包括 null 、undefined 、字符串、数 字、布尔和 ES6 中的 symbol**。 > **复合值(compound value)——对象(包括数组和封装对象，参见第 3 章)和函数，则总是 通过引用复制的方式来赋值 / 传 递**。 ## 第3章 原生函数 ![](https://user-gold-cdn.xitu.io/2018/6/20/1641c303afb22377?imageslim) ![](https://user-gold-cdn.xitu.io/2018/6/20/1641c306f032cf04?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) ## 第4章 强制类型转换 **JSON** - JSON.stringify(..) 在对象中遇到 undefined 、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。 ```js JSON.stringify( undefined ); // undefined JSON.stringify( function(){} ); // undefined JSON.stringify( [1,undefined,function(){},4] ); // \"[1,null,null,4]\" JSON.stringify( { a:2, b:function(){} } ); // \"{\"a\":2}\" 数字 其中 true 转换为 1 ，false 转换为 0 。undefined 转换为 NaN ，null 转换为 0 。 ```js function onlyOne() { var sum = 0; for (var i=0; i > 通过 sum += arguments[i] 中的隐式强制类型转换，将真值（true/truthy）转换为 1 并进行累加。如果有且仅有一个参数 为 true ，则结果为 1 ；否则不等于 1 ，sum == 1 条件不成立。 - 从 ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。 **数字解析和转换时不同的概念** ```js var a = \"42\"; var b = \"42px\"; Number( a ); // 42 parseInt( a ); // 42 Number( b ); // NaN parseInt( b ); // 42 解析允许 字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许 出现非数字字符， 否则会失败并返回 NaN 。 解析和转换之间不是相互替代的关系。它们虽然类似，但各有各的用途。如果字符串右边的非数字字符不影响结果，就可以使 用解析。而转换要求字符串中所有的字符都是数字，像 \"42px\" 这样的字符串就不行。 不要忘了 parseInt(..) 针对的是字符串值。向 parseInt(..) 传递数字和其他类型的参数是没有用的，比如 true 、function(){...} 和 [1,2,3] 。 假与真 假 JavaScript的假值: undefined null false +0 、-0 和 NaN \"\" JavaScript的假对象: var a = new Boolean( false ); var b = new Number( 0 ); var c = new String( \"\" ); 它们都是封装了假值的对象,其实结果都为true; document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。 真 var a = \"false\"; var b = \"0\"; var c = \"''\"; var d = Boolean( a && b && c ); d; 答案是 true 。 所有字符串都是真值。不过 \"\" 除外，因为它是假值列表中唯一的字符串。 同样的道理，[] 、{} 和 function(){} 都不在假值列表中，因此它们都是真值。 字符串和数字的转换 除了 String(..) 和 Number(..) 以外，还有其他方法可以实现字符串和数字之间的显式转换： ```js var a = 42; var b = a.toString(); var c = \"3.14\"; var d = +c; b; // \"42\" d; // 3.14/ +c 是 + 运算符的一元 （unary）形式（即只有一个操作数）。+ 运算符显式地将 c 转换为数字，而非数字加法运算 （也不是字符串拼接) / var e = 5+ +c; e; // 8.14 为什么？ > 一元运算符 - 和 + 一样，并且它还会反转数字的符号位。由于 -- 会被当作递减运算符来处理，所以我们不能使用 -- 来撤销反转，而应该像 - -\"3.14\" 这样，在**中间加一个空格**，才能得到正确结果 3.14 。 ### 　隐式强制类型转换为布尔值 。下面的情况会发生布尔值隐式强制类型转换。 - (1) if (..) 语句中的条件判断表达式。 - (2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。 - (3) while (..) 和 do..while(..) 循环中的条件判断表达式。 - (4) ? : 中的条件判断表达式。 - (5) 逻辑运算符 || （逻辑或）和 && （逻辑与）左边的操作数（作为条件判断表达式）。 以 ### || 和 &&的理解 > **它们的返回值是两个操作数中的一个（且仅一个）。即选择两个操作数中的一个，然后返回它的值** ```js var a = 42; var b = \"abc\"; var c = null; a || b; // 42 a && b; // \"abc\" c || b; // \"abc\" c && b; // null 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数（a 和 c ）的值，如果为 false 就返回第二个操作数（b ）的值。 || 运算符常常用来设置默认值 && 则相反，如果条件判断结果为 true 就返回第二个操作数（b ）的值，如果为 false 就返回第一个操作数（a 和 c ）的值。 && 常用来代替if 运算符 function foo() { console.log( a ); } var a = 42; a && foo(); // 42 /** foo() 只有在条件判断 a 通过时才会被调用。如果条件判断未通过，a && foo() 就会悄然终止（也叫作“短路”，short circuiting），foo() 不会被调用。 **/ var a = 42; var b = null; var c = \"foo\"; if (a && (b || c)) { console.log( \"yep\" ); } 这里 a && (b || c) 的结果实际上是 \"foo\" 而非 true ，然后再由 if 将 foo 强制类型转换为布尔值，所以最后结果为 true 。 宽松相等和严格相等 常见的误区是“== 检查值是否相等，=== 检查值和类型是否相等”。 正确的解释是：== 允许在相等比较中进行强制类型转换，而 === 不允许。 相比时的性能 如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。 如果两个值的类型不同，我们就需要考虑有没有强制类型转换的必要，有就用 == ，没有就用 === ，不用在乎性能。 其他类型和布尔类型之间的相等比较 个人建议无论什么情况下都不要使用 == true 和 == false - 不要使用 null 和 undefined 之间的相等比较 null 和 undefined 之间的 == 也涉及隐式强制类型转换。ES5 规范 11.9.3.2-3 规定： (1) 如果 x 为 null ，y 为 undefined ，则结果为 true。 (2) 如果 x 为 undefined ，y 为 null ，则结果为 true。 在 == 中 null 和 undefined 相等（它们也与其自身相等），除此之外其他值都不存在这种情况。 这也就是说在 == 中 null 和 undefined 是一回事，可以相互进行隐式强制类型转换： //建议使用 var a = doSomething(); if (a == null) { // .. } 代码中不要使用的 //假值的相等比较 \"0\" == null; // false \"0\" == undefined; // false \"0\" == false; // true -- 晕！ \"0\" == NaN; // false \"0\" == 0; // true \"0\" == \"\"; // false false == null; // false false == undefined; // false false == NaN; // false false == 0; // true -- 晕！ false == \"\"; // true -- 晕！ false == []; // true -- 晕！ false == {}; // false \"\" == null; // false \"\" == undefined; // false \"\" == NaN; // false \"\" == 0; // true -- 晕！ \"\" == []; // true -- 晕！ \"\" == {}; // false 0 == null; // false 0 == undefined; // false 0 == NaN; // false 0 == []; // true -- //极端情况 [] == ![] // true //完整性检查 \"0\" == false; // true -- 晕！ false == 0; // true -- 晕！ false == \"\"; // true -- 晕！ false == []; // true -- 晕！ \"\" == 0; // true -- 晕！ \"\" == []; // true -- 晕！ 0 == []; // true -- 晕！ 第5章 语法 第二部分 异步和性能 第1章 异步(现在与将来) 第2章 回调 > 回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越成熟,对于异步编程领域的发展,回调已经不够用了。 第一,大脑对于事情的计划方式是线性的、阻塞的、单线程的语义,但是回调表达异步流 程的方式是非线性的、非顺序的,这使得正确推导这样的代码难度很大。难于理解的代码 是坏代码,会导致坏 bug。 我们需要一种更同步、更顺序、更阻塞的的方式来表达异步,就像我们的大脑一样。 第二,也是更重要的一点,回调会受到控制反转的影响,因为回调暗中把控制权交给第三 方(通常是不受你控制的第三方工具!)来调用你代码中的 continuation。 这种控制转移导 致一系列麻烦的信任问题,比如回调被调用的次数是否会超出预期,是否有错误返回,调用回调过早（在追踪之前）,没有把所需的环境 / 参数成功传给你的回调函数。 可以发明一些特定逻辑来解决这些信任问题,但是其难度高于应有的水平,可能会产生更 笨重、更难维护的代码,并且缺少足够的保护,其中的损害要直到你受到 bug 的影响才会 被发现。 我们需要一个通用的方案来解决这些信任问题。不管我们创建多少回调,这一方案都应可 以复用,且没有重复代码的开销。 我们需要比回调更好的机制。到目前为止,回调提供了很好的服务,但是未来的 JavaScript 需要更高级、功能更强大的异步模式。本书接下来的几章会深入探讨这些新型技术。 第3章 Promise Promise链式处理 决议 （resolve）、完成 （fulfill）和拒绝 （reject）； new Promise( function(..){ ..} ) 模式通常称为 revealing constructor（http://domenic.me/2014/02/13/the-revealing-constructor-pattern/ ）。传入的函数会 立即执行（不会像 then(..) 中的回调一样异步延迟），它有两个参数，在本例中我们将其分别称为 resolve 和 reject 。这些是 promise 的决议函数。 resolve(..) 通常标识完成，而 reject(..) 则标识拒绝。 不可使用p instanceof Promise 既然 Promise 是通过 new Promise(..) 语法创建的，那你可能就认为可以通过 p instanceof Promise 来检查。但遗 憾的是，这并不足以作为检查方法，原因有许多。 其中最主要的是，Promise 值可能是从其他浏览器窗口（iframe 等）接收到的。这个浏览器窗口自己的 Promise 可能和当前窗口 /frame 的不同，因此这样的检查无法识别 Promise 实例。 resolve/reject只能传递一个值 如果使用多个参数调用 resovle(..) 或者 reject(..) ，第一个参数之后的所有参数都会被默默忽略。 如果要传递多个值，你就必须要把它们封装在单个值中传递，比如通过一个数组或对象。 特殊异常捕获 如果在 Promise 的创建过程中或在查看其决议结果过程中的任何时间点上出现了一个JavaScript 异常错 误，比如一个 TypeError 或 ReferenceError ，那这个异常就会被捕捉，且会使这个 Promise 被拒绝。 var p = new Promise( function(resolve,reject){ foo.bar(); // foo未定义，所以会出错！ resolve( 42 ); // 永远不会到达这里 :( } ); p.then( function fulfilled(){ // 永远不会到达这里 :( }, function rejected(err){ // err将会是一个TypeError异常对象来自foo.bar()这一行 } ); 调用 Promise 的 then(..) 会自动创建一个新的 Promise 从调用返回。 then 都是链式调用，默认情况下一个then都会接受到上一个then的默认promise返回； 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise 就相应地决议(resolve)。 // 步骤1：request是thenable的 request( \"http://some.url.1/\" ) // 步骤2： .then( function(response1){ foo.bar(); // undefined，出错！ // 永远不会到达这里 return request( \"http://some.url.2/?v=\" + response1 ); } ) // 步骤3： .then( function fulfilled(response2){ // 永远不会到达这里 }, // 捕捉错误的拒绝处理函数 function rejected(err){ console.log( err ); // 来自foo.bar()的错误TypeError return 42; } ) // 步骤4： .then( function(msg){ console.log(msg) )} 如果完成或拒绝处理函数返回一个 Promise，它将会被展开，这样一来，不管它的决议值(resolve)是什么，都会成为当前then(..) 返回的链接 Promise 的决议(resolve)值 如果需要步骤二，在步骤一处理完成处理，你可以在步骤一手动返回一个promise new Promise(function(resolve,reject){ //do something resovle(); }).then(function(data){ //do something return new Promise(function(resolve,reject){ //do something resovle(); }) }). .then(function(data){ //这个地方的值 就是上一个new Pormise的决议值(resolve) }) Promise.resolve(..) 会将传入的真正 Promise 直接返回，对传入的 thenable 则会展开。如果这个thenable 展开得到一个拒绝状态，那么从 Promise.resolve(..) 返回的 Promise 实际上就是这同一个拒绝状态. reject(..) 不会像 resolve(..) 一样进行展开。如果向 reject(..) 传入一个 Promise/thenable 值，它会把 这个值原封不动地设置为拒绝理由。后续的拒绝处理函数接收到的是你实际传给 reject(..) 的那个Promise/thenable，而不是其底层的立即值。 var rejec = new Promise( function(resolve,reject){ // 用一个被拒绝的promise完成这个promise resolve( Promise.reject( \"Oops\" ) ); } ); rejec.then( function fulfilled(){ // 永远不会到达这里 }, function rejected(err){ console.log( err ); // \"Oops\" } ); Promise.catch捕获异常 没有为 then(..) 传入拒绝处理函数，所以默认的处理函数被替换掉了，而这仅仅是把错误传递给了链中的下一个 promise。因此，进入 p 的错误以及 p 之后进入其决议(resolve)（就像 msg.toLowerCase() ）的错误都会传递到最后的 遗留的问题：要是在catch中还存在异常咋办 handleErrors(..) var p = Promise.resolve( 42 ); p.then( function fulfilled(msg){ // 数字没有string函数，所以会抛出错误 console.log( msg.toLowerCase() ); } ) . catch( handleErrors ); Promise API (详解) new Promise(..) 构造器 构造器 Promise(..) 必须和 new 一起使用，并且必须提供一个函数回调。这个回调是同步的或立即调用的。这 个函数接受两个函数回调，用以支持 promise 的决议。通常我们把这两个函数称为 resolve(..) 和 reject(..) var p = new Promise( function(resolve,reject){ // resolve(..)用于决议/完成这个promise // reject(..)用于拒绝这个promise } ); reject(..) 就是拒绝这个 promise；但 resolve(..) 既可能完成 promise，也可能拒绝，要根据传入参数而定。 如果传给resolve(..) 的是一个非 Promise、非 thenable 的立即值，这个 promise 就会用这个值完成。 如果传给 resolve(..) 的是一个真正的 Promise 或 thenable 值，这个值就会被递归展开，并且（要构造的）promise 将取用其最终决议值或状态。 Promise.resolve(..) 和 Promise.reject(..) Promise.reject是使用new Pormise()中reject的快捷方式。 //如下两种方式是等价的 var p1 = new Promise( function(resolve,reject){ reject( \"Oops\" ); } ); var p2 = Promise.reject( \"Oops\" ); Promise.resolve并不是完成，而是决议，有可能从pending到fulfilled或者rejected。 Promise.resolve返回一个状态由给定value决定的Promise对象。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；(见下面的then方法介绍) 否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise.resolve和reject只能接收一个参数，如果需要传递多个参数请使用数组/对象包裹起来。 // then(..) 接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调 var fulfilledTh = { then: function(cb) { cb( 42 ); } }; var rejectedTh = { then: function(cb,errCb) { errCb( \"Oops\" ); } }; var p1 = Promise.resolve( fulfilledTh ); var p2 = Promise.resolve( rejectedTh ); // p1是完成的promise then()和catch then(..) 接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回调只是把消息传递下去，而默认拒绝回调则只是重新抛出（传播）其接收到的出错原因。 p.then( fulfilled ); p.then( fulfilled, rejected ); p.catch( rejected ); // 或者p.then( null, rejected ) then和catch也会创建并返回一个新的promise，用于链式调用then， 如果then中的fulfilled函数或者rejected中抛出异常 ，那么返回的promise将会到下一个then的rejected函数中; 如果then中返回一个非thenable(即带有then方法的对象),那么返回的值将会在下一个then方法中的fulfilled中； 如果then返回的是一个thenable或者promise，那么具体调用下一个then的哪个方法，由thenable或promsie决定。 new Promise(function(resolve,reject){ resolve(\"data\");//非thenable，会到then的fulfilled中 }) .then(function fulfilled(res){ return new Promise(function(resolve,reject){//返回的是thenable resolve(\"下一个\");//调用下一个then的哪个方法由这个promise决定，此处为resolve，并且返回的是一个非thenable对象，那么就会调用下一个then方法的fulfilled，否则为thenable对象，会再次展开 }) } ,function rejected(error){ }) .then(function fulfilled(){//到fulfilled还是rejected由上一个then决定 },function rejected(error){ }) 　Promise.all([ .. ]) 多个任务并行执行，。它们的完成顺序并不重要，但是必须都要完成，都执行完成后回调。 Promise.all([ .. ]) 需要一个参数，是一个数组，通常由 Promise 实例组成。从 Promise.all([ .. ]) 调用返回的 promise 会收到一个完成消息（代码片段中的 msg ）。这是一个由所有传入 promise 的完成消息组成的数组，与指定的顺序一致（与完成顺序无关）。 // request(..)是一个Promise-aware Ajax工具 // 就像我们在本章前面定义的一样 var p1 = request( \"http://some.url.1/\" ); var p2 = request( \"http://some.url.2/\" ); Promise.all( [p1,p2] ) .then( function(msgs){ // 这里，p1和p2完成并把它们的消息传入;msgs是一个数组 return request( \"http://some.url.3/?v=\" + msgs.join(\",\") ); } ) .then( function(msg){ console. 从 Promise.all([ .. ]) 返回的主 promise 在有且仅在所有的成员 promise 都完成后才会完成。如果这些 promise 中有任何一个被拒绝的话，主 Promise.all([ .. ]) promise 就会立即被拒绝，并丢弃来自其他所有 promise 的全部结果。 永远要记住为每个 promise 关联一个拒绝 / 错误处理函数，特别是从 Promise.all([ .. ]) 返回的那一个。 Promise.race([ .. ]) race为竞争，只有一个胜利者； Promise.race([ .. ]) 也接受单个数组参数。这个数组由一个或多个 Promise、thenable 或立即值组成 与 Promise.all([ .. ]) 类似，一旦有任何一个 Promise 决议为完成，Promise.race([ .. ]) 就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝 要注意，永远不要递送空数组。 Promise的局限性 顺序错误处理 在最后添加一个catch函数捕获异常 单一值 resolve/rejected可以使用数组/对象包括；在fulfilled中使用对象解构{}或者数组解构[]获取值。 单决议 无法取消 单独的 Promise 不应该可取消，但是取消一个可序列是合理的，因为你不会像对待 Promise 那样把序列作为一个单独的不变值来传送。 以前的回调函数修改为Promise //之前使用回调函数，达到异步效果 function foo(x,y,cb) { ajax( \"http://some.url.1/?x=\" + x + \"&y=\" + y, cb ); } foo( 11, 31, function(err,text) { if (err) { console.error( err ); } else { console.log( text ); } } ); 使用Promise封装一个包裹函数 // polyfill安全的guard检查 if (!Promise.wrap) { Promise.wrap = function(fn) { return function() { var args = [].slice.call( arguments ); return new Promise( function(resolve,reject){ fn.apply( null, //args为实例调用时传入的所有参数，在最后加上一个回调函数，然后调用fn函数 args.concat( function(err,v){ if (err) { reject( err ); } else { resolve( v ); } } ) ); } ); }; }; } //使用的时候，但是要求ajax回调函数必须为最后一个参数 var request = Promise.wrap( ajax ); request( \"http://some.url.1/\")//只传递需要的参数 .then( .. ) 第6章 生成器 抱歉，此章看的是阮一峰老师的es6 module function* helloWorldGenerator() { yield 'hello'; yield 'world'; return 'ending'; } var hw = helloWorldGenerator(); 里面重要的几个概念： 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式 三是，next()函数 必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止; hw.next() // { value: 'hello', done: false } hw.next() // { value: 'world', done: false } hw.next() // { value: 'ending', done: true } hw.next() // { value: undefined, done: true } 每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束 一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式 yield表达式只能用在 Generator 函数里面 yield表达式如果用在另一个表达式之中，必须放在圆括号里面 function* demo() { console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK } 生成器使用for ... of for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。 function* foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (let v of foo()) { console.log(v); } // 1 2 3 4 5 第5章 程序性能 Web Worker 启动多线程 Work使用场景 Web Worker 通常应用于哪些方面呢？ 处理密集型数学计算 大数据集排序 数据处理（压缩、音频分析、图像处理等） 高流量网络通信 Work创建及终止 实例化 //1. 实例化woker, var w1 = new Worker( \"http://some.url.1/mycoolworker.js\" ); 这个 URL 应该指向一个 JavaScript 文件的位置（而不是一个 HTML 页面！），这个文件将被加载到一个 Worker 中。然后浏览器启动一个独立的线程，让这个文件在这个线程中作为独立的程序运行。 如果浏览器中有两个或多个页面（或同一页上的多个 tab ！）试图从同一个文件 URL 创建 Worker，那么最终得到的实际上是完全独立的 Worker 数据收发 Worker 之间以及它们和主程序之间，不会共享任何作用域或资源，那会把所有多线程编程的噩梦带到前端领域，而是通过一个基本的事件消息机制相互联系`; //2. 数据的获取（主线程发送消息给woker） w1.addEventListener( \"message\", function(evt){ // evt.data } ); //数据的发送(主线程收到woker的信息) w1.postMessage( \"something cool to say\" ); // mydemo_woker.js //在worker内部，监听主线程发给自己的信息 addEventListener( \"message\", function(evt){ // evt.data } ); //发送数据给主线程 postMessage( \"a really cool reply\" ); 注意，专用 Worker 和创建它的程序之间是一对一的关系。 通常由主页面应用程序创建 Worker，但若是需要的话，Worker 也可以实例化它自己的子 Worker，称为 subworker。有时候，把这样的细节委托给一个“主”Worker，由它来创建其他 Worker 处理部分任务，这样很有用。不幸的是，到写作本书时为 止，Chrome 还不支持 subworker，不过 Firefox 支持。 Work的终止 //主页面手动终止 w1.terminate(); 突然终止Worker 线程不会给它任何机会完成它的工作或者清理任何资源。这就类似于通过关闭浏览器标签页来关闭页面。 Work运行环境及外部脚本加载 Work不可以访问主程序的任何资源，不能访问dom或者其他资源，但是可以执行网络操 作（Ajax、WebSockets）以及设定定时 器。还 有，Worker 可以访问几个重要的全局变量和功能的本地复 本，包括 navigator 、location 、JSON 和 applicationCache 可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本： // 在Worker内部 importScripts( \"foo.js\", \"bar.js\" ); 这些脚本加载是同步的。也就是说，importScripts(..) 调用会阻塞余下 Worker 的执行，直到文件加载和执行完成。 Work数据传递 在早期的 Worker 中，唯一的选择就是把所有数据序列化到一个字符串值中，然后使用postMessage发送并使用addEventListener(\"message\")的方式获取数据 方法一：使用Transferable对象 特别是对于大数据集而言，就是使用 Transferable 对象 （http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast ）。 这时发生的是对象所有权的转移，数据本身并没有移动。一旦你把对象传递到一个 Worker 中，在原来的位置上，它就变为空的或者是不可访问的，这样就消除了多线程编程作用域共享带来的混乱。当然，所有权传递是可以双 向进行的。 如果选择 Transferable 对象的话，其实不需要做什么。任何实现了 Transferable 接口（http://developer.mozilla.org/en-US/docs/Web/API/Transferable ）的数据结构就自动按照这种方式传输（Firefox 和 Chrome 都支持）。 使用结构化克隆算法 如果要传递一个对象，可以使用结构化克隆算法 （structured clone algorithm）（https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm ）把这个对象复制到另一边。这个算法非常高级，甚至可以处理要复制的对象有循环引用的情况。这样就不用付出 to-string 和 from-string 的性能损失了，但是这种方案还是要使用双倍的内存。IE10 及更高版本以及所有其他主流浏览器都支持这种方案。 共享Worker 常见情况：前面已经讲过每一个worker是独立的，但为了节省系统资源（在这一方面最常见的有限资源就是 socket 网络连接，因为浏览器限制了到同一个主机的同时连接数目。（2-8个之间，通常为6个）） 主页面实例化共享Woker //创建一个整个站点或 app 的所有页面实例都可以共享的中心 Worker var w1 = new SharedWorker( \"http://some.url.1/mycoolworker.js\" ); /** 因为共享 Worker 可以与站点的多个程序实例或多个页面连接，所以这个 Worker 需要通过某种方式来得知消息来自于哪个程 序。这个唯一标识符称为端口 （port），可以类比网络 socket 的端口。因此，调用程序必须使用 Worker 的 port 对象用于通 信： **/ w1.port.addEventListener( \"message\", handleMessages ); // .. w1.port.postMessage( \"something cool\" ); // 端口连接必须要初始化 w1.port.start(); 共享Worker内部 共享 Worker 内部，必须要处理额外的一个事件：\"connect\" 。这个事件为这个特定的连接提供了端口对象。保持多个连接独立的最简单办法就是使用 port 上的闭包 // 在共享Worker内部 addEventListener( \"connect\", function(evt){ // 这个连接分配的端口 var port = evt.ports[0]; port.addEventListener( \"message\", function(evt){ // .. port.postMessage( .. ); // .. } ); // 初始化端口连接 port.start(); } ); 共享Worker和Worker的区别 如果有某个端口连接终止而其他端口连接仍然活跃，那么共享 Worker 不会终止。而对专用 Worker 来说，只要到实例化它的程序的连接终止，它就会终止 Worker的模拟 http://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers 上列出了一些实现 https://gist.github.com/getify/1b26accb1a09aa53ad25 单指令多数据 SIMD 单指令多数据（SIMD）是一种数据并行 （data parallelism）方式，与 Web Worker 的任务并行 （task parallelism）相对，因为这 里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。 应用在：做并行数学处理；数据密集型的应用（信号分析、关于图形的矩阵运算，等等） 对于可用的 SIMD 功能（http://github.com/johnmccutchan/ecmascript_simd ），有一个官方的（有希望的、值得期待的、面向未来的）prolyfill， asm.js asm.js 描述了 JavaScript 的一个很小的子集，它避免了 JavaScript 难以优化的部分（比如垃圾收集和强制类型转换），并 且让 JavaScript 引擎识别并通过激进的优化运行这样的代码。可以手工编写 asm.js，但是会极端费力且容易出错，类似于手写 汇编语言（这也是其名字的由来）。实际上，asm.js 也是高度优化的程序语言交叉编译的一个很好的目标，比如 Emscripten 把 C/C++ 转换成 JavaScript（https://github.com/kripken/emscripten/wiki ）。 第6章 微性能测试和调优 性能测试 使用Benchmark.js 与其打造你自己的统计有效的性能测试逻辑,不如直接使用 Benchmark.js 库,它已经为你 实现了这些。但是,编写测试要小心,因为我们很容易就会构造一个看似有效实际却有缺 陷的测试,即使是微小的差异也可能扭曲结果,使其完全不可靠。 如果你想要对你的代码进行功能测试和性能测试，这个库应该最优先考 虑。 //一个简单例子 ```js function foo() { // 要测试的运算 } var bench = new Benchmark( \"foo test\", // 测试名称 foo, // 要测试的函数（也即内容） { // .. // 可选的额外选项（参见文档） } ); bench.hz; // 每秒运算数 bench.stats.moe; // 出错边界 bench.stats.variance; // 样本方差 2. jsPerf.com 从尽可能多的环境中得到尽可能多的测试结果以消除硬件/ 设备的偏差, 这一点很重要。 jsPerf.com 是很好的网站,用于众包性能测试运行。 一个比较以下几种转换数字性能的例子: [点击这里看代码测试例子](https://jsperf.com/js-test-demo) ```js var x = \"42\"; // 需要数字42 // 选择1：让隐式类型转换自动发生 var y = x / 2; // 选择2：使用parseInt(..) var y = parseInt( x, 0 ) / 2; // 选择3：使用Number(..) var y = Number( x ) / 2; // 选择4：使用一元运算符+ var y = +x / 2; // 选项5：使用一元运算符| var y = (x | 0) / 2; 尾调用优化是 ES6 要求的一种优化方法。它使 JavaScript 中原本不可能的一些递归模式变 得实际。 TCO 允许一个函数在结尾处调用另外一个函数来执行,不需要任何额外资源。这意味着,对递归算法来说,引擎不再需要限制栈深度。 参考:精读《你不知道的javascript》中卷 参考：ECMAScript6 入门 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-08 20:30:34 "},"article/javascript/new_A和A的区别.html":{"url":"article/javascript/new_A和A的区别.html","title":"4. new A()和A()的区别","keywords":"","body":"function Me(name,age,job){ this.name = name; this.age = age; this.job = job; } //请问这以下两种实例化对象方式有什么区别呢？ var mefun1 = new Me('fei','20','it'); var mefun2 = Me('fei','20','it'); 第一种是构造函数式，即通过new运算符调用构造函数Function来创建函数 第二种不是实例化，只是调用函数把返回值赋给变量。 JavaScript 中并没有真正的类，但JavaScript 中有构造函数和new 运算符。构造函数用来给实例对象初始化属性和值。任何JavaScript 函数都可以用做构造函数，构造函数必须使用new 运算符作为前缀来创建新的实例。 new 运算符改变了函数的执行上下文，同时改变了return 语句的行为。实际上，使用new和构造函数很类似于传统的实现了类的语言: // 实例化一个Me var alice = new Me('alice', 18, 'Coder'); // 检查这个实例 assert( alice instanceof Me ); 构造函数的命名通常使用驼峰命名法，首字母大写，以此和普通的函数区分开来，这是一种习惯用法。 // 不要这么做! Me('alice', 18, 'Coder'); //=> undefined 这个函数只会返回undefined，并且执行上下文是window（全局）对象，无意间创建了3个全局变量name,age,job。调用构造函数时不要丢掉new 关键字。 当使用new 关键字来调用构造函数时，执行上下文从全局对象（window）变成一个空的上下文，这个上下文代表了新生成的实例。 因此，this 关键字指向当前创建的实例。尽管理解起来有些绕，实际上其他语言内置类机制的实现也是如此。 默认情况下，如果你的构造函数中没有返回任何内容，就会返回this——当前的上下文。 要不然就返回任意非原始类型的值. 转载：javascript中使用new与不使用实例化对象的区别 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:33:19 "},"article/javascript/Javascript的变量提升和函数提升.html":{"url":"article/javascript/Javascript的变量提升和函数提升.html","title":"5. Javascript的变量提升和函数提升","keywords":"","body":"Javascript的变量提升和函数提升一、变量提升二、函数提升参考:Javascript的变量提升和函数提升 在JavaScript执行代码的过程中是一段一段从上往下执行代码。执行代码之前是有一个预处理过程的，比如变量的提升和函数提升。 一、变量提升 通常我们会遇到如下的代码: console.log(a); //输出结果:undefined var a=\"mr gao\"; console.log(a);//输出结果:mr gao function demo(){ console.log(a);//输出结果:undefined var a=\"demo\"; console.log(a);//输出结果:demo } demo(); 其实javascript在预处理过程时，会将声明的变量提升至对应作用域的顶端；所以上述的代码类似于: var a; //变量提升，如果当前作用域有相同的变量名，则会被提升至同一位置。 console.log(a); //输出结果:undefined a=\"mr gao\"; console.log(a);//输出结果:mr gao function demo(){ var a; console.log(a);//输出结果:undefined a=\"demo\"; console.log(a);//输出结果:demo } demo(); 二、函数提升 在搞懂函数提升之前先要了解函数声明的几种方式: //1:函数声明方式 function funName(){ } //2:函数表达式 } var funName=function(){ } //3:函数对象方式 var funcName=new Function(); 只有函数声明方式采用函数作用域的提升 foo(); // 不是ReferenceError, 而是TypeError! var foo = function bar() { // ... }; 这段程序中的变量标识符foo() 被提升并分配给所在作用域（在这里是全局作用域），因此 foo() 不会导致ReferenceError。但是foo 此时并没有赋值（如果它是一个函数声明而不 是函数表达式，那么就会赋值）。foo() 由于对undefined 值进行函数调用而导致非法操作， 因此抛出TypeError 异常。 同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中 foo(); // TypeError bar(); // ReferenceError var foo = function bar() { // ... }; 例子： （1）变量提升 demo();//结果为:undefined var age=20;//这个变量的声明会提升到变量使用之前 function demo() { console.log(age);//undefined var age=30; } //代码解析过程为 var age; function demo() { var age; console.log(age); age=30; } demo(); age=20; （2）相同函数名变量提升 function demo(){ console.log(\"我是第一个函数啊\") } demo(); function demo(){ console.log(\"我是第二个函数啊\") } demo(); //执行结果为:我是第二个函数啊 我是第二个函数啊 //执行过程为: function demo(){//第一个demo函数提升至作用域顶端，第二个同名demo函数也提升至顶端，覆盖第一个demo函数 console.log(\"我是第二个函数啊\") } demo()//调用第一个demo函数 demo()//调用第二个demo函数 （3）函数名和变量名冲突：函数名优先级高(函数优先) console.log(demo); var demo=\"我是变量\"; function demo (){ console.log(\"我是函数\"); } //输出结果为: ƒ demo(){ console.log(\"我是函数\"); } 参考: JavaScript 解析器、预解析、变量提升、函数提升 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-20 07:18:16 "},"article/javascript/Javascript对闭包的理解.html":{"url":"article/javascript/Javascript对闭包的理解.html","title":"6. Javascript对闭包的理解","keywords":"","body":"闭包的定义常见的闭包闭包的用途闭包的缺点MDN 闭包 闭包的定义 闭包是指有权访问另一个函数作用域中的变量的函数 --《JavaScript高级程序设计》 闭包是函数和声明该函数的词法环境的组合。 -- 《MDN》 Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。 而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。 当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 常见的闭包 function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); //使用匿名函数 function makeAdder(x) { return function(y) {//匿名函数的闭包内部的this位windows，请见最后闭包的缺点 return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 闭包的用途 1. 保护变量的安全-实现JS私有属性和私有方法 利用闭包可以读取函数内部的变量，变量在函数外部不能直接读取到，从而达到保护变量安全的作用。因为私有方法在函数内部都能被访问到，从而实现了私有属性和方法的共享。 常见的模块模式就是利用闭包的这种特性建立的 var Counter = (function() { //私有属性 var privateCounter = 0; //私有方法 function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(privateCounter); //privateCounter is not defined console.log(Counter.value()); // 0 Counter.increment(); Counter.increment(); console.log(Counter.value()); // 2 Counter.decrement(); console.log(Counter.value()); // 1 在jQuery框架的私有方法和变量也是这么设计的 var $ = jQuery = function(){ return jQuery.fn.init(); } jQuery.fn = jQuery.prototype = { init:function(){ return this; //this指向jQuery.prototype }, length: 1, size: function(){ return this.length; } } console.log($().size()); // 1 2. 将处理结果缓存 var mult = (function(){ var cache = {}; var calculate = function(){ var a = 1; for(vari=0,l=arguments.length;i 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 理解了闭包的原理我们发现闭包的这些用途都是利用了闭包保存了当前函数的活动对象的特点， 这样闭包函数在作用域之外被调用时依然能够访问其创建时的作用域 闭包的缺点 闭包将函数的活动对象维持在内存中，过度使用闭包会导致内存占用过多，所以在使用完后需要将保存在内存中的活动对象解除引用； 闭包只能取得外部函数中任何变量的最后一个值，在使用循环且返回的函数中带有循环变量时会得到错误结果；(这就是为什么循环对节点绑定事件无效的原因) 当返回的函数为匿名函数时，注意匿名函数中的this指的是window对象。 参考:对JavaScript中闭包的理解 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/对Object.create和类式继承的理解.html":{"url":"article/javascript/对Object.create和类式继承的理解.html","title":"7. 对Object.create和类式继承的理解","keywords":"","body":"对类式继承的理解对Object.create()的理解对类式继承的理解 疑问1？实现类式继承时为啥是 B.prototype = new A(); 而不是 B.prototype = A or B.prototype = A.prototype？ proto 与 prototype 的区别prototype是类(构造函数)才有的!! proto是对象拥有的! 因为函数也是对象, 所有函数也有proto.proto是为了实现继承, prototype是为了定义一些公用属性和方法. var b = new B(); // 解释:那么 b.__proto__ == B.prototype == A A.__proto__ == Function.prototype Function.prototype.__proto__ == Object.prototype Object.prototype.__proto__ == null //所以通过__proto__永远找不到A.prototype, 所以 B 不能继承 A 疑问2? 这里为啥是 B.prototype = new A(); 而不是B.prototype == A.prototype 继承的目的 1. 复用父类方法 2. 有权添加/重写父的方法但继承决不允许改变父的方法和属性, 对于父子是只读的.//所以 B.prototype == A.prototype使得两者成为一体, 一旦修改 全部都修改了, 所以不行 //而 B.prototype == new A() //假设 var a = new A()那么向上链起来:B.protype == a var b = new B(); b.__proto__ == B.prototype == a a.__proto__ == A.prototype // 这一步也证明B继承了A B.prototype.xxx= function() {} 这里添加的xxx方法只是改变了a而已(一个局部变量),不会影响到A.prototype 对Object.create()的理解 Object.create()的作用：Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 简单理解为：创建一个新的对象，来实现原型链的继承。 Polyfill的实现 Object.create=function(proto){ function F() {} F.prototype = proto; return new F(); } //demo var prototype = Object.create(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象 使用Object.create()方式实现原型链集成，其构造函数没有继承。这就是为什么你会发现在使用寄生式组合集成时使用Object.create()之后还需要 指定构造函数。 看了前面的类式继承的理解，再来看Object的polyfill实现，为什么要使用一个中转函数来实现原型链的集成。 如果直接使用 subType.prototype=new superType();会将superType的构造函数也会继承；这就违背了Object.create()的定义：实现原型链的集成 如果使用subType.prototype=supertype.prototype;实现原型链集成，会导致对subType.prototype原型链的修改影响到supertype的原型链。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-10 22:25:51 "},"article/javascript/Object.create和New的区别.html":{"url":"article/javascript/Object.create和New的区别.html","title":"8. Object.create()和New的区别","keywords":"","body":"Object.create()的polyfill实现NewNew和Object.create()的区别 引用官方的一句话：Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 Object.create(proto, [propertiesObject]) proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性） 对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 Object.create()的polyfill实现 方法内部定义一个新的空对象obj 将obj.proto的对象指向传入的参数proto 将传入的对象属性复制到obj并且返回obj if (typeof Object.create !== \"function\") { Object.create = function (proto, propertiesObject) { if (typeof proto !== 'object' && typeof proto !== 'function') { throw new TypeError('Object prototype may only be an Object: ' + proto); } else if (proto === null) { throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\"); } if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\"); //核心是下面的代码 function F() {} F.prototype = proto; return new F(); }; } New 语法： new constructor ( [aguments] ) MDN文档 由此我们可以看出，实际new创建对象，就是调用构造函数来实例化，在调用构造函数的时候会执行以下操作： 创建一个新的对象 将新对象执行原型操作，指向构造函数的原型 将this绑定到新对象上（可以使用 call 或者 apply 强制转换执行环境） 构造函数返回的对象就是实例化的结果，如果构造函数没有显示返回一个对象，则返回新的对象 New的polyfill实现 function _new_ (){ var obj = {}, Constructor = [].shift.call(arguments);//第一个参数为要new的那个对象 obj.__proto__ = Constructor.prototype;//得到对象的原型 var ret = Constructor.apply(obj, arguments);//将this绑定到新的对象上,arguments已经移除了第一个参数，那么后续的入参为对象的入参 return typeof ret === 'object' ? ret : obj; } //测试 function Demo(name,age){ this.name=name; this.age=age; } var demo=_new_(Demo,'mrgao',20); console.log(demo); New和Object.create()的区别 比较 new Object.create 构造函数 保留原构造函数属性 丢失原构造函数属性(这就是为什么使用寄生式组合时需要重新设置构造函数) 原型链 原构造函数prototype属性 原构造函数/（对象）本身 作用对象 function function和object 参考： New 和 Object.create()的区别 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-20 07:18:16 "},"article/javascript/Javascript柯里化和偏函数实现.html":{"url":"article/javascript/Javascript柯里化和偏函数实现.html","title":"9. Javascript柯里化和偏函数实现","keywords":"","body":"第二种手动结束偏函数什么是函数柯里化 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。用公式表示就是我们要做的事情其实是 ```js fn(a,b,c,d)=>fn(a)(b)(c)(d)； fn(a,b,c,d)=>fn(a，b)(c)(d)； fn(a,b,c,d)=>fn(a)(b，c，d)； ...... 再或者这样： fn(a,b,c,d)=>fn(a)(b)(c)(d)()； fn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()； 但不是这样：(下面为偏函数) fn(a,b,c,d)=>fn(a)； fn(a,b,c,d)=>fn(a，b)； ### 第一种方式：按照参数个数自动结束 ```js fn(a,b,c,d)=>fn(a)(b)(c)(d)； fn(a,b,c,d)=>fn(a，b)(c)(d)； fn(a,b,c,d)=>fn(a)(b，c，d)； 代码实现 const curry = (fn, ...arg) => { let all = arg || [], length = fn.length; return (...rest) => { let _args = all.slice(0); //拷贝新的all，避免改动公有的all属性，导致多次调用_args.length出错 _args.push(...rest); if (_args.length 第二种手动结束 fn(a,b,c,d)=>fn(a)(b)(c)(d)()； fn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()； const curry=function(fn,...args){ let all=args||[]; let argsLen=fn.length; return function(...argsIn){ let _args=all.slice(0); _args.push(argsIn); if(argsIn.length===0){ all=[]; return fn.apply(this,_args); }else{ return curry.call(this,fn,..._args); } } } //测试 let test = curry(function(...rest) { let args = rest.map(val => val * 10); console.log(args); }) test(2); test(2); test(3); test(); test(5); test(); test(2)(2)(2)(3)(4)(5)(6)(); test(2, 3, 4, 5, 6, 7)(); 偏函数 fn(a,b,c,d)=>fn(a)； fn(a,b,c,d)=>fn(a,b)； function part(fn, ...arg) { let all = arg || []; return (...rest) => { let args = all.slice(0); args.push(...rest); return fn.apply(this, args) } } function add(a = 0, b = 0, c = 0) { console.log(a + b + c); } let addPart = part(add); addPart(9); //9 addPart(9, 11);//20 参考：js高阶函数应用—函数柯里化和反柯里化 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/Javascript中this绑定详解.html":{"url":"article/javascript/Javascript中this绑定详解.html","title":"10. Javascript中this绑定详解","keywords":"","body":"一、 默认绑定二、隐式绑定三、显式绑定三、new绑定五、this绑定优先级六、this优先级绑定例外七、软绑定 This 绑定大致分为4中 默认绑定，隐式绑定，显示绑定和new 绑定。 一、 默认绑定 独立函数调用，可以把默认绑定看作是无法应用其他规则时的默认规则，this指向全局对象。 严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined。只有函数运行在非严格模式下，默认绑定才能绑定到全局对象。在严格模式下调用函数则不影响默认绑定。 function foo() { // 运行在严格模式下，this会绑定到undefined \"use strict\"; console.log( this.a ); } var a = 2; // 调用 foo(); // TypeError: this is undefined // -------------------------------------- function foo() { // 运行 console.log( this.a ); } var a = 2; (function() { // 严格模式下调用函数则不影响默认绑定 \"use strict\"; foo(); // 2 })(); 二、隐式绑定 当函数引用有上下文对象时，隐式绑定规则会把函数中的this绑定到这个上下文对象。对象属性引用链中只有上一层或者说最后一层在调用中起作用。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 隐式丢失 被隐式绑定的函数特定情况下会丢失绑定对象，应用默认绑定，把this绑定到全局对象或者undefined上。 // 虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。 // bar()是一个不带任何修饰的函数调用，应用默认绑定。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名 var a = \"oops, global\"; // a是全局对象的属性 bar(); // \"oops, global\" 参数传递就是一种隐式赋值，传入函数时也会被隐式赋值。回调函数丢失this绑定是非常常见的。 function foo() { console.log( this.a ); } function doFoo(fn) { // fn其实引用的是foo fn(); // 三、显式绑定 通过call(..) 或者 apply(..)方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。 function foo() { console.log( this.a ); } var obj = { a: 2 }; foo.call( obj ); // 2 调用foo时强制把foo的this绑定到obj上 显示绑定无法解决丢失绑定问题。 丢失绑定解决方案： 1、硬绑定 创建函数bar()，并在它的内部手动调用foo.call(obj)，强制把foo的this绑定到了obj。 function foo() { console.log( this.a ); } var obj = { a: 2 }; var bar = function() { foo.call( obj ); }; bar(); // 2 setTimeout( bar, 100 ); // 2 // 硬绑定的bar不可能再修改它的this bar.call( window ); // 2 典型应用场景是创建一个包裹函数，负责接收参数并返回值。 function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = function() { return foo.apply( obj, arguments ); }; var b = bar( 3 ); // 2 3 console.log( b ); // 5 创建一个可以重复使用的辅助函数。 function foo(something) { console.log( this.a, something ); return this.a + something; } // 简单的辅助绑定函数 function bind(fn, obj) { return function() { return fn.apply( obj, arguments ); } } var obj = { a: 2 }; var bar = bind( foo, obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5内置了Function.prototype.bind，bind会返回一个硬绑定的新函数，用法如下。 function foo(something) { console.log( this.a, something ); return this.a + something; } var obj = { a: 2 }; var bar = foo.bind( obj ); var b = bar( 3 ); // 2 3 console.log( b ); // 5 2、API调用的“上下文” JS许多内置函数提供了一个可选参数，被称之为“上下文”（context），其作用和bind(..)一样，确保回调函数使用指定的this。这些函数实际上通过call(..)和apply(..)实现了显式绑定。 function foo(el) { console.log( el, this.id ); } var obj = { id: \"awesome\" } // 调用foo(..)时把this绑定到obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 三、new绑定 在JS中，构造函数只是使用new操作符时被调用的普通函数，他们不属于某个类，也不会实例化一个类。 包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1、创建（或者说构造）一个新对象。 2、这个新对象会被执行[[Prototype]]连接。 3、这个新对象会绑定到函数调用的this。 4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 使用new来调用foo(..)时，会构造一个新对象并把它（bar）绑定到foo(..)调用中的this。 function foo(a) { this.a = a; } var bar = new foo(2); // bar和foo(..)调用中的this进行绑定 console.log( bar.a ); // 2 五、this绑定优先级 new 绑定 > 显示绑定 > 隐式绑定 > 默认绑定 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断： 函数是否在new 中调用（new 绑定）？如果是的话this 绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 就是这样。对于正常的函 st=>start: Start e=>end: End cond1=>condition: new绑定 op1=>operation: this绑定新创建的对象， var bar = new foo() cond2=>condition: 显示绑定 op2=>operation: this绑定指定的对象， var bar = foo.call(obj2) cond3=>condition: 隐式绑定 op3=>operation: this绑定上下文对象， var bar = obj1.foo() op4=>operation: 默认绑定 op5=>operation: 函数体严格模式下绑定到undefined， 否则绑定到全局对象， var bar = foo() st->cond1 cond1(yes)->op1->e cond1(no)->cond2 cond2(yes)->op2->e cond2(no)->cond3 cond3(yes)->op3->e cond3(no)->op4->op5->e 在new中使用硬绑定函数的目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数（柯里化）。 function foo(p1, p2) { this.val = p1 + p2; } // 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么 // 反正使用new时this会被修改 var bar = foo.bind( null, \"p1\" ); var baz = new bar( \"p2\" ); baz.val; // p1p2 六、this优先级绑定例外 1. 被忽略的this 把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认规则。 下面两种情况下会传入null 使用apply(..)来“展开”一个数组，并当作参数传入一个函数 bind(..)可以对参数进行柯里化（预先设置一些参数） function foo(a, b) { console.log( \"a:\" + a + \"，b:\" + b ); } // 把数组”展开“成参数 foo.apply( null, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( null, 2 ); bar( 3 ); // a:2，b:3 总是传入null来忽略this绑定可能产生一些副作用。如果某个函数确实使用了this，那默认绑定规则会把this绑定到全局对象中。 更安全的this 安全的做法就是传入一个特殊的对象（空对象），把this绑定到这个对象不会对你的程序产生任何副作用。 JS中创建一个空对象最简单的方法是Object.create(null)，这个和{}很像，但是并不会创建Object.prototype这个委托，所以比{}更空。 function foo(a, b) { console.log( \"a:\" + a + \"，b:\" + b ); } // 我们的空对象 var ø = Object.create( null ); // 把数组”展开“成参数 foo.apply( ø, [2, 3] ); // a:2，b:3 // 使用bind(..)进行柯里化 var bar = foo.bind( ø, 2 ); bar( 3 ); // a:2，b:3 2. 间接引用 间接引用下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生。 // p.foo = o.foo的返回值是目标函数的引用，所以调用位置是foo()而不是p.foo()或者o.foo() function foo() { console.log( this.a ); } var a = 2; var o = { a: 3, foo: foo }; var p = { a: 4}; o.foo(); // 3 (p.foo = o.foo)(); // 2 七、软绑定 硬绑定可以把this强制绑定到指定的对象（new除外），防止函数调用应用默认绑定规则。但是会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改this。 如果给默认绑定指定一个全局对象和undefined以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显示绑定修改this的能力。 // 默认绑定规则，优先级排最后 // 如果this绑定到全局对象或者undefined，那就把指定的默认对象obj绑定到this,否则不会修改this if(!Function.prototype.softBind) { Function.prototype.softBind = function(obj) { var fn = this; // 捕获所有curried参数 var curried = [].slice.call( arguments, 1 ); var bound = function() { return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) ); }; bound.prototype = Object.create( fn.prototype ); return bound; }; } 使用：软绑定版本的foo()可以手动将this绑定到obj2或者obj3上，但如果应用默认绑定，则会将this绑定到obj。 function foo() { console.log(\"name:\" + this.name); } var obj = { name: \"obj\" }, obj2 = { name: \"obj2\" }, obj3 = { name: \"obj3\" }; // 默认绑定，应用软绑定，软绑定把this绑定到默认对象obj var fooOBJ = foo.softBind( obj ); fooOBJ(); // name: obj // 隐式绑定规则 obj2.foo = foo.softBind( obj ); obj2.foo(); // name: obj2 参考：你不知道的Javascript上 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-11 22:47:14 "},"article/javascript/JavaScript中改变this指向有几种方式.html":{"url":"article/javascript/JavaScript中改变this指向有几种方式.html","title":"11. JavaScript中改变this指向有几种方式","keywords":"","body":"JavaScript中改变this指向有几种方式丢失的this this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window JavaScript中改变this指向有几种方式 this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。 （1）作为函数名调用 当函数不作为对象的属性被调用时候，也就是我们所说的普通函数方式，此时的this总是指向全局的对象。在浏览器的js里面，这个全局对象是window对象。 function a(){ var author = \"lry\"; console.log(this.author); //undefined console.log(this); //Window } a(); //其实这是相当于 window.a() //或者 window.name = \"globalName\"; var myObject = { name: \"louis\", getName: function () { return this.name; } } var getName = myObject.getName; console.log(getName()); // \"globalName\" （2）作为对象方法调用  函数作为对象中的一个属性，成为该对象的一个方法，this指向该对象 var o = { author:\"lry\", fn:function(){ console.log(this.author); //lry } } o.fn(); //this => o （3）使用构造函数调用 使用new调用的函数，则其中this将会被绑定到那个新构造的对象。（首先new关键字会创建一个空的对象，然后会自动调用一个函数方法(apply...)，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代） 除了宿主提供的一些内置函数，大部分js函数都可以当成构造器使用，构造器的外表看起来和普通的函数没有什么区别，他们的区别在于调用方式，当使用new运算符调用函数的时候，该函数总是返回一个对象，通常情况下，构造器里面的this就是指向返回的这个对象。 function Fn() { this.author = \"lry\" } var o = new Fn(); console.log(o.author); //lry （4）apply或call,bind调用  自行改变this指向，函数this指向apply或call方法调用时的第一个参数 var o = { author:\"lry\", fn:function(){ console.log(this.author); //lry } } var b = o.fn; b.call(o); //或者 b.apply(o) var o = { a:10, b:{ a:20, fn:function(){ console.log(this.a); //20 } } } o.b.fn(); 这里的this为什么不是指向o？如果按照上面的理论，最终this指向的是调用它的对象，因为 如果一个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。看下面例子：虽然对象b中没有属性a，但this仍然指向的是它的上一级对象b var o = { a:10, b:{ //a:20, fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 特殊情况： var o = { a:10, b:{ a:20, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var c = o.b.fn; c(); 丢失的this 下面看一个经常遇到的问题： var obj = { myName: \"louis\", getName: function () { return this.name; } } console.log(obj.getName()); // louis; var getName2 = obj.getName; console.log(getName2()) // undefined 当调用obj.getName时，getName方法是作为obj对象的属性被调用的，根据上文提到的规律，此时的this指向obj对象，所以obj.getName()输出'louis'。 当用另外一个变量getName2来引用obj.getName，并且调用getName2时， 此时是普通函数调用方式，this是指向全局window的，window上面并没有挂载任何属性所以程序的执行结果是undefined。 再看另一个例子，document.getElementById这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同prototype.js等一些框架所做过的事情: var getId = function (id) { return document.getElementById(id); }; getId('div1'); 我们也许思考过为什么不能用下面这种更简单的方式 var getId = document.getElementById; getId( 'div1' ); 现在不妨花1分钟时间，让这段代码在浏览器中运行一次 我是一个div var getId = document.getElementById; getId( 'div1' ); 在chrome friefox IE10 中执行过后就会发现，这段代码抛出一个异常,这是因为很多引擎的document.getElementById 方法的内部实现中需要用到this，这个this本来被期望指向document，当getElementById方法作为document对象的属性被调用时，方法内部的this确实是指向document的。 但是当getId来引用document,getElementById之后，再调用getId，此时就成了普通的函数调用了，函数内部的this指向了window，而不是原来的document。 我们可以尝试利用apply把document当做this传递给getId函数，修正 this指向问题。 document.getElementById = (function(func){ return function(){ return func.apply(document,arguments); } })(document.getElementById); var getId = document.getElementById; var div = getId('div1'); alert(div.id); 参考：深入学习js之——this Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/Javascript的call和apply和bind方法.html":{"url":"article/javascript/Javascript的call和apply和bind方法.html","title":"12. Javascript的call和apply和bind方法","keywords":"","body":"call/apply方法第一个参数解释:借肉的人，call/apply的使用场景文章参考 在JavaScript中call、apply、bind是Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。 call、apply、bind方法的共同点和区别：apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；apply 、 call 、bind 三者都可以利用后续参数传参； 区别：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 call() 、apply()可以看作是某个对象的方法，通过调用方法的形式来间接调用函数。bind() 就是将某个函数绑定到某个对象上 一个例子： //有刀没肉 function peopleOne(name,name2){ var knife=\"西瓜刀\"; console.log(name,name2,\"使用\",knife,\"切\",this.meat); }; //有肉，没刀 var peo={ meat:\"五花肉\" }; //让peopleOne的上下文对象为peo，这样peo就可以调用peopleOne()方法使用刀去切肉了 peopleOne.call(peo,'mrgao','mrwho'); //mrgao mrwho 使用 西瓜刀 吃 五花肉 peopleOne.apply(peo,['mrgao','mrwho']); //mrgao mrwho 使用 西瓜刀 吃 五花肉 call()和apply()的作用是: 借别人的方法(刀)吃自己的肉。：允许在一个对象（a）上调用该对象没有定义的方法(b)，并且这个方法(b)中可以访问该对象(a)中的属性。 其中call()和apply()的不同点为：入参的方式不同，call接受多个参数，而apply接收两个参数，其中第二个参数为一个数组列表 call/apply方法第一个参数解释:借肉的人， 不传，或者传null,undefined， 函数中的 this 指向 window 对象，传递另一个函数的函数名，函数中的 this 指向这个函数的引用，传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean，传递一个对象，函数中的 this 指向这个对象。 call/apply的使用场景 1、继承 function Product(name, price) { this.name = name; this.price = price; } function Food(name, price) { //Food使用了Product方法，这样Product中的上下文为Food， //所以Food会添加name和price属性 Product.call(this, name, price); this.category = 'food'; } console.log(new Food('cheese', 5).name); // 结果: \"cheese\" 2、借刀切肉/移花接木 参考：深入理解call、apply、bind（改变函数中的this指向） 在javascript中有很多类数组对象；，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的 function test(){ console.log(typeof(arguments)); //输出Object ，arguments //检测arguments是否是Array的实例 console.log(arguments instanceof Array); //输出 false console.log(Array.isArray(arguments)); //输出 false //判断arguments是否有forEach的方法 console.log(arguments.forEach); //输出 undefined //将数组中的forEach方法应用到arguments上 Array.prototype.forEach.call(arguments, function(item){console.log(item); //输出 1 2 3 4 5 }); //因为forEach的入参为一个函数，所以第二个参数应该为一个函数 } test(1,2,3,4,5); 文章参考 深入理解call、apply、bind（改变函数中的this指向） 详解call()，apply()和bind() 官方地址MDN Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/Javascript的bind的polyfill的理解.html":{"url":"article/javascript/Javascript的bind的polyfill的理解.html","title":"13. Javascript的bind的polyfill的理解","keywords":"","body":"bind函数polyfill的理解bind函数polyfill的理解 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 一个例子 function bFun(){ this.d=10; return this.a; } var func=bFun.bind({a:20}); func();//20 new func();//bFun {d:10} ，使用new 构造函数 方式创建，this指向为对象实例，而不是传入的{a:20} Polyfill if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) {//oThis为需要绑定的对象也就是上例中的{a:20} // this为上例中的bFun，要求必须为函数类型 if (typeof this !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } //将bind函数传入的参数从第1个(index从0开始)开始转换成数组，因为第0个为传入的绑定对象。arguments为类数组 var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() { // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 // 由于使用new 方式创建的对象，this指向为对象的实例，此处判断如果使用new方式创建那么this应该为对象实例的this // 否则使用上下文绑定为传入的对象 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 // 函数的参数：应该为bind时传入的参数+调用生成的函数时传入的参数和 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 维护原型关系 if (this.prototype) { // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; } // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; }; } 理解1 return fToBind.apply(this instanceof fBound ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments))); 这段代码会判断硬绑定函数是否是被new 调用，如果是的话就会使用新创建的this 替换硬绑定的this。 那么，为什么要在new 中使用硬绑定函数呢？直接使用普通函数不是更简单吗？ 之所以要在new 中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用 new 进行初始化时就可以只传入其余的参数。bind(..) 的功能之一就是可以把除了第一个 参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为“部 分应用”，是“柯里化”的一种） 理解2 其中如下代码作用和fBound.prototype=Object.create(this.prototype)作用一样， 效果为：生成的新函数(func)应该继承于原有函数(bFun)原型链 fNOP = function() {}, if (this.prototype) { fNOP.prototype = this.prototype; } fBound.prototype = new fNOP(); Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6.html":{"url":"article/javascript/Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6.html","title":"14. Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6","keywords":"","body":"CommonJS 模块化AMD模块化特点优缺点AMD的库requireJS的使用CMD模块化特点CMD & AMD间的区别sea.js的使用UMD 模块化ES6模块化特点ES6 模块与 CommonJS 模块的差异使用示例 前端模块化的发展大致有如下：IIFE,CommonJS,AMD,CMD,UMD,Es6 Module 模块化的好处 避免命名冲突(减少命名空间污染) 更好的分离, 按需加载 更高复用性 高可维护性 CommonJS 模块化 CommonJS是服务器端模块的规范，commonJS用同步的方式加载模块, Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。核心思想是通过 require方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。 特点 1、根据CommonJS规范，一个单独的文件就是一个模块。 2、每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 3、模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; 4、dirname代表当前模块文件所在的文件夹路径，filename代表当前模块文件所在的文件夹路径+文件名; 5、require（同步加载）基本功能：读取并执行一个JS文件，然后返回该模块的exports对象，如果没有发现指定模块会报错; 6、模块内的exports：为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给exports对象添加方法，PS：不能直接赋值（因为这样就切断了exports和module.exports的联系）; // 定义模块math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum } // 引用自定义的模块时，参数包含路径，可省略.js var math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径 var http = require('http'); http.createService(...).listen(3000); AMD模块化 AMD 是RequireJs在推广过程中对模块化定义的规范化产出。（异步模块）AMD 规范主要是为了解决针对浏览器环境的模块化问题。 特点 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 AMD 推崇依赖前置、提前执行; 由于依赖的模块是异步加载的，那么函数执行的时机为所有模块都加载完成了才执行。如果某个模块加载比较耗时，建议采用全局依赖的形式去加载顶层模块。 requirejs 模块的加载顺序是不固定的，但执行顺序是固定的，按依赖声明的先后顺序执行. 优缺点 AMD 的优点 可在不转换代码的情况下直接在浏览器中运行 可加载多个依赖 代码可运行在浏览器环境和 Node.js 环境下 AMD 的缺点 JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 由于依赖前置，那么及时在回调函数中没有使用依赖的模块，模块还是会被加载。 AMD的库 requireJS curl requireJS的使用 使用requireJS:用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 //首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 /** 网页中引入require.js及main.js **/ /** main.js 入口文件/主模块 **/ // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 // 定义math.js模块 define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum }; }); // 定义一个依赖underscore.js的模块 define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify }; }) // 引用模块，将模块放在[]内,模块的加载是异步，只有两者都加载完成才调用回调函数 require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum); }); CMD模块化 CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 特点 依赖就近，延时执行 CMD是按需加载依赖，在用到那个模块再去require CMD & AMD间的区别 AMD依赖前置，在定义模块时就声明其所要依赖的模块 CMD是按需加载依赖，在用到那个模块再去require AMD在使用前就准备好，CMD是用到了再去准备模块 AMD CMD 定义module时对依赖的处理 推崇依赖前置，在定义的时候就要声明其依赖的模块 推崇就近依赖，只有在用到这个module的时候才去require 加载方式 async async 执行module的方式 加载module完成后就会执行该module，所有module都加载执行完成后会进入require的回调函数，执行主逻辑。依赖的执行顺序和书写的顺序不一定一致，谁先下载完谁先执行，但是主逻辑 一定在所有的依赖加载完成后才执行(有点类似Promise.all)。 加载完某个依赖后并不执行，只是下载而已。在所有的module加载完成后进入主逻辑，遇到require语句的时候才会执行对应的module。module的执行顺序和书写的顺序是完全一致的。 /** AMD写法 **/ define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } }); /** CMD写法 **/ define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); } }); /** sea.js **/ // 定义模块 math.js define(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add; }); // 加载模块 seajs.use(['math.js'], function(math){ var sum = math.add(1+2); }); sea.js的使用 sea.js 引入sea.js的库 如何变成模块？ - define - 如何调用模块？ -exports -sea.js.use 如何依赖模块？ -require define(function (require,exports,module) { //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports }) UMD 模块化 UMD是AMD和CommonJS和 全局对象(Global Object)的融合 AMD模块以浏览器第一的原则发展，异步加载模块。 CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。 这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。 UMD先判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。然后判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。 (function (root, factory) { if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['b'], factory); } else if (typeof module === 'object' && module.exports) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(require('b')); } else { // Browser globals (root is window) root.returnExports = factory(root.b); } }(typeof self !== 'undefined' ? self : this, function (b) { // Use b in some fashion. // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return {}; })); ES6模块化 ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义，作为浏览器和服务器通用的模块解决方案它可以取代我们之前提到的 AMD ，CMD , UMD ,CommonJS。 关于 ES6 的 Module 相信大家每天的工作中都会用到，对于使用上有疑问可以看看 ES6 Module 入门，阮一峰; 特点 ES6模块导入的变量(其实应该叫常量更准确)具有以下特点： 变量提升、相当于被Object.freeze()包装过一样、import/export只能在顶级作用域 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 ES6模块区别于CommonJS的运行时加载，import 命令会被JavaScript引擎静态分析，优先于模块内的其他内容执行(类似于函数声明优先于其他语句那样)， 也就是说在文件的任何位置import引入模块都会被提前到文件顶部。 ES6的模块 自动开启严格模式，即使没有写'use strict'; 运行一个包含import声明的模块时，被引入的模块先导入并加载，然后根据依赖关系，每个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，避免依赖循环 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 使用示例 import { prop } from 'app'; //从app中导入prop import { prop as newProp } from 'app'; // 功能和上面一样，不过是将导入的prop重命名为newProp import App from 'App'; // 导入App的default import * as App from 'App'; // 导入App的所有属性到App对象中 export const variable = 'value'; // 导出一个名为variable的常量 export {variable as newVar}; // 和import 的重命名类似，将variable作为newVar导出 export default variable = 'value'; // 将variable作为默认导出 export {variable as default}; // 和上面的写法基本一样 export {variable} from 'module'; // 导出module的variable ，该模块中无法访问 export {variable as newVar} from 'module'; // 下面的自己看 不解释了 export {variable as newVar} from 'module'; export * from 'module'; 参考: 前端开发之模块化开发中的规范讲解--commonjs、AMD、CMD、ES6 前端模块化：CommonJS,AMD,CMD,ES6 AMD, CMD, CommonJS和UMD Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-11 22:47:14 "},"article/javascript/Javascript寄生式组合继承详解.html":{"url":"article/javascript/Javascript寄生式组合继承详解.html","title":"15. Javascript寄生式组合继承详解","keywords":"","body":" 也许你可能在网上看到一大堆寄生式组合继承的样例，但是心中一直有困惑，为什么要这样做，此篇文章也许能帮你了解为什么这么实现。 一个寄生式组合继承的例子： function Foo(name) { this.name = name; } Foo.prototype.myName = function() { return this.name; }; function Bar(name,label) { Foo.call( this, name ); this.label = label; } // 我们创建了一个新的Bar.prototype 对象并关联到Foo.prototype Bar.prototype = Object.create( Foo.prototype ); // 注意！现在没有Bar.prototype.constructor 了 // 如果你需要这个属性的话可能需要手动修复一下它 Bar.prototype.constructor=Bar; Bar.prototype.myLabel = function() { return this.label; }; var a = new Bar( \"a\", \"obj a\" ); a.myName(); // \"a\" a.myLabel(); // \"obj a\"/ 疑问1：为什么this指向a? 如果看了之前的this指向问题，那么就会明白new 一个对象，就会改变函数this执行到实例a上。 Foo.call(this)的理解 使用Foo.call(this)可以改变Foo函数内部的this指向，由于this执行的是a，那么在初始化Foo内部函数的操作时，相当于a.name=name;但是有一个缺点就是Foo的原型链并没有继承到。 如果不了解this指向问题，可以参考一下两个文章: JavaScript中改变this指向有几种方式 JavaScript中this绑定详解 为什么不使用Bar.prototype=Foo.prototype? Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype 的新对象，它只是让Bar.prototype 直接引用Foo.prototype 对象。因此当你执行类似Bar.prototype.myLabel = ... 的赋值语句时会直接修改Foo.prototype 对象本身。 简单来说：如果使用这样的形式，那么修改Bar.prototype就会影响到Foo.prototype，会影响到Foo关联的对象； 为什么使用Object.create(Foo.prototype)而不是new Foo（） 上面讲了，Foo.call()可以解决实例a，继承Foo函数内部的属性，但是无法继承Foo的原型链；所以需要修改Bar.prototype； 使用Bar.prototype=new Foo();理论上是可以的，但是会造成两个副作用 Foo函数被重复调用。使用Foo.call已经调用了一次，再次使用new Foo，其构造函数会再次被调用； 如果函数Foo 有一些副作用（比如写日志、修改状态、注册到其他对象、给this 添加数据属性，等等）的话，就会影响到Bar() 的“后代”，后果不堪设想。 为什么使用Object.create? 使用Object.create()可以创建一个新对象来提供prototype，如果你看过Object.create的polyfill就会明白，Object.create只继承了prototype并没有调用Foo构造函数。 Object.create()会造成的一个问题：Bar.prototype.constructor会改变，为什么会改变？引用你不知道的JavaScript上中的一句话如果你创建了一个新对象并替换了函数默认的.prototype 对象引用，那么新对象并不会自动获.constructor 属性。 Object.create()的理解 那么如何解决这个问题 呢？直接使用Bar.prototype.constructor=Bar就可以了。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-30 20:44:57 "},"article/javascript/JavaScript常见ployfill.html":{"url":"article/javascript/JavaScript常见ployfill.html","title":"16. JavaScript常见ployfill","keywords":"","body":"私有变量的实现单例设计模式promisify 将回调函数变为 promise优雅的捕获 async 的异常发布订阅 EventEmitter实现 Promise.finally实现 ES6 的 class 语法bind 函数的 polyfillcall 函数的 ployfillnew 关键字的 polyfillObject.assign 的 polyfillinstanceof 关键字 polyfill函数防抖 debounce函数节流 throttle函数柯里化偏函数循环实现数组 map 方法使用 reduce 实现数组 map 方法循环实现数组 filter 方法循环实现 filter循环实现数组的 reduce 方法使用 reduce 实现数组的 flat 方法参考文章部分参考与:中级前端工程师必须要掌握的 28 个 JavaScript 技巧 私有变量的实现 const privateVar = function(obj) { return new Proxy(obj, { get(target, key) { if (key.startWith(\"_\")) { throw new Error(\"private key\"); } return Reflect.get(target, key); }, ownKeys(target) { return Reflect.ownKeys(target).filter(val => !val.startWith(\"_\")); } }); }; 单例设计模式 使用闭包方式 // 单例对象 class SingleObject { login() {} } // 访问方法 SingleObject.getInstance = (function() { let instance; return function() { if (!instance) { instance = new SingleObject(); } return instance; }; })(); const obj1 = SingleObject.getInstance(); const obj2 = SingleObject.getInstance(); console.log(obj1 === obj2); // true 使用 Proxy 方式 //使用Proxy模式 function single(func) { let instance = null; let handler = { construct(target, arges) { if (!instance) { instance = Reflect.construct(target, arges); } return instance; } }; return new Porxy(func, handler); } promisify 将回调函数变为 promise function promisify(asynFunc) { return function(...args) { return new Promise((resolve, reject) => { args.push(function callback(error, ...values) { if (error) { return reject(error); } return resolve(...values); }); asynFunc.call(this, ...args); }); }; } 优雅的捕获 async 的异常 async function capture(func, ...args) { try { let res = await func(...args); return [null, res]; } catch (error) { return [error, null]; } } //使用的时候 let [error, res] = await capture(yourFun, yourArgs); 发布订阅 EventEmitter class EventEmitter { constructor() { this._events = {}; } //发送事件 emit(eventName, data) { let returns = []; //data.eventName = eventName; if (Array.isArray(this.handles[eventName])) { this.handles[eventName].forEach((val, index) => { let returnValue = this._events[eventName][i](data); returns.push(returnValue); }); } return returns; } on(eventName, callback, target) { this._events[eventName] = this._events[eventName] || []; this._events[eventName].push(callback.bind(target)); } off(eventName, offCb) { if (this._events[eventName]) { let index = this._events[eventName].findIndex(cb => cb === offCb); this._events[eventName].splice(index, 1); this._events[eventName] = []; } } } 实现 Promise.finally //finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，使用方法如下 Promise .then(result => { ··· }) .catch(error => { ··· }) .finally(() => { ··· }) finally 特点： 不接收任何参数。 finally 本质上是 then 方法的特例。 Promise.prototype.finally = function (callback) { let P = this.constructor return this.then( value => P.resolve(callback()).then(() => value), reason => P.resolve(callback()).then(() => { throw reason }) ) } 实现 ES6 的 class 语法 function _class_(subType, superType) { subType.prototype = Object.create(superType.prototype, { constructor: { enumerable: false, configurable: true, writable: true, value: subType } }); Object.setPrototypeOf(subType, superType); } 而 Object.create 支持第二个参数，即给生成的空对象定义属性和属性描述符/访问器描述符，我们可以给这个空对象定义一个 constructor 属性更加符合默认的继承行为，同时它是不可枚举的内部属性（enumerable:false） 而 ES6 的 class 允许子类继承父类的静态方法和静态属性，而普通的寄生组合式继承只能做到实例与实例之间的继承，对于类与类之间的继承需要额外定义方法，这里使用 Object.setPrototypeOf 将 superType 设置为 subType 的原型，从而能够从父类中继承静态方法和静态属性 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 bind 函数的 polyfill Function.prototype.bind = function(fThis, ...bindArg) { let fToBind = this; if (typeof fToBind !== \"function\") throw new TypeError( \"Function.prototype.bind - what is trying to be bound is not callable\" ); let fBound = function(...args) { return fToBind.apply( this instanceof fBound ? this : fThis, bindArg.concat(args) ); }; fBound.prototype = Object.create(fToBind.prototype); fBound.prototype.constructor = fBound; return fBound; }; //test function bFun() { this.d = 10; return this.a; } var func = bFun.bind({ a: 20 }); console.log(func()); console.log(new func()); call 函数的 ployfill /** * 原理就是将函数作为传入的上下文参数（context）的属性执行，这里为了防止属性冲突使用了 ES6 的 Symbol 类型 * @param {*} context * @param {...any} args */ Function.prototype.call = function(context, ...args) { context || (context = window); //如果context为null则在windos下运行 let func = this; if (typeof func !== \"function\") { throw new TypeError(\"this is not function\"); } let caller = Symbol(\"caller\"); context[caller] = func; let res = context[caller](...args); delete context[caller]; return res; }; //测试 let demo = { a: 20 }; function b() { console.log(this.a); } b.call(demo); //20 new 关键字的 polyfill 创建一个新的对象 将新对象执行原型操作，指向构造函数的原型 将 this 绑定到新对象上（可以使用 call 或者 apply 强制转换执行环境） 构造函数返回的对象就是实例化的结果，如果构造函数没有显示返回一个对象，则返回新的对象 function _new_(fn, ...args) { let obj = {}; obj.__proto__ = fn.prototype; let result = fn.apply(obj, args); return typeof result === \"object\" ? result : obj; } _new_(data => { console.log(this, data); }, \"你好\"); Object.assign 的 polyfill Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Object.assign 是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用 Object.assign 特点 可以拷贝 Symbol 属性 不能拷贝不可枚举的属性 Object.assign 保证 target 始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined 没有基本包装类型,所以传入会报错 source 参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有 iterator 接口) /** * Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 * @param {*} param */ function isComplexType(obj) { return (typeof obj === \"object\" || typeof obj === \"function\") && obj != null; } function _asign_(target, ...source) { if (target == null) { throw new Error(\"Connot convert undefined or null to target\"); } return source.reduce((pre, curr, index) => { isComplexType(pre) || (pre = new Object(pre)); if (curr == null) return pre; [...Object.keys(curr), ...Object.getOwnPropertySymbols(curr)].forEach( key => { pre[key] = curr[key]; } ); return pre; }, target); } console.log(_asign_({ a: 1 }, { b: 2 }, { c: 3 })); instanceof 关键字 polyfill 使用递归循环查找 left 原型链上是否存在 right function _instanceOf_(left, right) { let leftProto = Object.getPrototypeOf(left); while (true) { if (leftProto == null) return false; if (leftProto === right.prototype) { return true; } leftProto = Object.getPrototypeOf(leftProto); } } function a() {} function b() {} b.prototype = new a(); console.log(_instanceOf_({}, {})); //false console.log(_instanceOf_(new b(), a)); //true 函数防抖 debounce 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 /** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */ function debounce(func, wait, immediate) { let timeout; return function() { let context = this; let args = arguments; if (timeout) clearTimeout(timeout); if (immediate) { let callNow = !timeout; timeout = setTimeout(() => { timeout = null; }, wait); if (callNow) func.apply(context, args); } else { timeout = setTimeout(() => { func.apply(context, args); }, wait); } }; } 函数节流 throttle 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。 节流会稀释函数的执行频率。 /** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */ function throttle(func, wait, type) { if (type === 1) { let previous = 0; } else if (type === 2) { let timeout; } return function() { let context = this; let args = arguments; if (type === 1) { let now = Date.now(); if (now - previous > wait) { func.apply(context, args); previous = now; } } else if (type === 2) { if (!timeout) { timeout = setTimeout(() => { timeout = null; func.apply(context, args); }, wait); } } }; } 函数柯里化 不了解函数柯里化的朋友请见函数柯里化 const curry = (fn, ...arg) => { let all = arg || [], length = fn.length; return (...rest) => { let _args = all.slice(0); //拷贝新的all，避免改动公有的all属性，导致多次调用_args.length出错 _args.push(...rest); if (_args.length 偏函数 不了解偏函数的朋友请见偏函数 function part(fn, ...arg) { let all = arg || []; return (...rest) => { let args = all.slice(0); args.push(...rest); return fn.apply(this, args); }; } function add(a = 0, b = 0, c = 0) { console.log(a + b + c); } let addPart = part(add); addPart(9); //9 addPart(9, 11); //20 循环实现数组 map 方法 Array.prototype.selfMap = function(fn, context) { let arr = Array.prototype.slice.call(this); let mapArr = new Array(); for (let i = 0; i 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 使用 reduce 实现数组 map 方法 Array.prototype.selfMap = function(fn, context) { let arr = Array.prototype.slice.call(this); return arr.reduce((pre, cur, index, array) => { return [...pre, fn.call(context, cur, index, this)]; }, []); }; console.log( [1, 2, 3].selfMap(function(data) { return data + \"v\"; }) ); //[ '1v', '2v', '3v' 循环实现数组 filter 方法 Array.prototype.selfFilter = function(fn, context) { return this.reduce((pre, cur, index, array) => { return fn.call(context, cur, index, this) ? [...pre, cur] : [...pre]; }, []); }; console.log( [1, 2, 3].selfFilter(function(data) { return data % 2 === 0; }) ); 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 循环实现 filter Array.prototype.selfFilter = function(fn, context) { let arr = Array.prototype.slice.call(this); let filterArr = new Array(); for (let i = 0; i 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 循环实现数组的 reduce 方法 Array.prototype.selfReduce = function(fn, initValue) { let arr = Array.prototype.slice.call(this); let startIndex = 0, res; if (initValue === undefined) { for (let i = 0; i 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 使用 reduce 实现数组的 flat 方法 let selfFlat = function(dept = 1) { let arr = Array.prototype.slice.call(this); if (dept === 0) { return arr; } return arr.reduce((pre, curr, index, array) => { if (Array.isArray(curr)) { return [...pre, ...selfFlat.call(curr, dept - 1)]; } else { return [...pre, curr]; } }, []); }; Array.prototype.selfFlat = selfFlat; console.log([1, [4, 5, 6], 3, [0, 10]].selfFlat()); 来自：一个合格的中级前端工程师需要掌握的 28 个 JavaScript 技巧 参考 近一万字的 ES6 语法知识点补充 记录面试中一些回答不够好的题（Vue 居多） | 掘金技术征文 中级前端工程师必须要掌握的 28 个 JavaScript 技巧 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-08-27 23:04:25 "},"article/mendix/":{"url":"article/mendix/","title":"四、轻量化平台Mendix","keywords":"","body":"一、什么是Mendix二、Mendix可以做什么三、Mendix的优点四、Mendix的缺点五、部分学习资料 以下所有文件均是原创，如需转载请注明作者和链接地址。 一、什么是Mendix Mendix是一个轻量化开发工具，我们可以写较少的代码来快速构建一个应用（网站/app）；其实所谓的构建一个APP，其原理也是一个h5界面，也是运行在安全浏览器中。 使用Mendix之后，我们不需要太多的去关心前端和后台代码如何实现，而更多的是关系系统的业务和逻辑。 使用Mendix，不需要你自己写后台程序，不需要你写h5界面，一切只需要托拉拽即可。（构建应用从未如此之快）； 二、Mendix可以做什么 “大部分的网站都可以做”。 也许上面这句话说的优点夸张，但是mendix的底层是使用Java编写，也会使用h5；所以h5能做的它都能做。 当然啦，前提是大家要对其有一定的熟悉度哦！ 三、Mendix的优点 写少量的代码 快速构建并上线一个应用（目前我所在的项目：1周上线一个应用） Mendix适合做公司内部各自权限管理系统（Mendix有非常完善的权限管理机制）； Mendix适合不太懂编程的同学 Mendix构建一个网站只需要托拉拽，当然也可自己写样式或者写h5。 可自己编写java/h5到mendix中，甚至将其他的js库引入直接使用。 Mendix组件开发可以使用Vue/React等框架 代码编写流程化，清晰化。（举个例子） （ if判断（菱形），查询数据库数据（retrieve lis of ）） 等等..... 四、Mendix的缺点 不太适合高并发网站（但是可将前后台分离，Mendix只负责前端界面展示，） 对性能要求非常高的同学，可能mendix做稍有欠缺； 五、部分学习资料 由于mendix目前只在国外流行，故学习资料大部分都是英文文档； 1. Mendix官网 https://gettingstarted.mendixcloud.com/index3.html 里面有100多个module，如果你学习完了，你就是大牛了。 2. mendix组件中关于mx.data的api:https://apidocs.mendix.com/7/client/mx.data.html 一些api文档，我希望大家鞥看看。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/env.html":{"url":"article/mendix/env.html","title":"1. Mendix环境搭建","keywords":"","body":"一、Mendix安装教程二、新建一个项目 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、主要内容：介绍Mendix的安装教程和如何简单构建一个应用 2、适用人群：初学者； 3、浏览时间：有点点长哦； Mendix开发主要有两种方式，一种为网页版，一种是客户端；本文推荐使用客户端安装并开发。 一、Mendix安装教程 在安装Mendix之前，最好使用公司的账号在mendix官网注册一个账号，否则在启动客户端时需要验证邮箱；官网注册地址：https://signup.mendix.com/link/signup/?source=direct 1、Mendix安装额外的文件 mendix的安装主要有以下几个文件： Microsoft .NET Framework 4.6.2 地址：https://www.microsoft.com/net/download/thank-you/net462 Microsoft Visual C++ 2010 SP1 Redistributable Package Microsoft Visual C++ 2013 Redistributable Package Java Development Kit 1.8 地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mendix客户端 地址：https://appstore.home.mendix.com/link/modelers/ （最好下载最新的哦，访问可能有点慢） 记得在安装mendix客户端前安装上述四个文件，并将Java路径设置到系统变量中去哦。 2、安装客户端 在开始构建应用程序之前，需要在计算机上安装Mendix Desktop Modeler。请按照以下步骤安装Mendix Desktop Modeler： 打开下载的Mendix Modeler可执行文件。它的名字如下：Mendix-7.XX-Setup。 单击下一步。 选择我接受许可协议中的条款，然后单击下一步。 选择要安装到的文件夹，然后单击“ 下一步”。 输入要使用的开始菜单快捷方式文件夹，然后单击“ 下一步”。 选中“ 桌面”选项以在桌面上创建Modeler的快捷方式，然后单击“ 下一步”。 单击“ 安装”以在计算机上安装Modeler。 选中Launch Mendix 7.XX并单击Finish完成安装并启动Modeler。 以上是有关安装Mendix Desktop Modeler的方法。 二、新建一个项目 1、创建空项目 2、一些简单概念的介绍 在mendix中简单的界面构建以及数据库的创建只是需要简单的拖拽即可。但是又几个概念得提前缕清一下。 微流（Microflow）：类似于Java中的方法，又入参，出参，可在里面做循环，判断等等； 界面（Page）:页面的实现；使用客户端右侧，已经写好的组件拖拽到Page中即可迅速构建h5界面。 实体（在Domin Model中）：在mendix中有两种实体。持久化实体也就是数据库中的表；非持久化实体：Java中的类。 持久化实体： 非持久化实体： 3、一个视频教程 由于无法上传较长视频，所以请需要观看的同学点击以下链接观看： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/javaaction.html":{"url":"article/mendix/javaaction.html","title":"2. Mendix使用Java","keywords":"","body":"JavaAction使用注意事项一、数据的添加 以下所有文件均是原创，如需转载请注明作者和链接地址。 此文demo地址：https://github.com/mrgaogang/mendix 日常开发中我们难免会有一些情况是无法使用微流实现的，此时需要我们使用Java原生的能力:JavaAction；此文主要介绍如何JavaAction对数据库的数据进行增删改查和使用action执行微流。 目录: 数据添加； 数据删除； 数据修改； 数据查询； 使用Action执行微流； JavaAction使用注意事项 JavaAction使用有几个注意点： executeAction()是mendix默认调用的方法，且我们只能在//BEGIN 和//END之间编写Java代码。 public java.util.List executeAction() throws Exception { // BEGIN USER CODE //此处是你的代码 // END USER CODE } 如果你有大量的代码需要编写请在类的末尾以下两个分隔符之间编写 // BEGIN EXTRA CODE // END EXTRA CODE 一、数据的添加 数据的创建可以使用Core.instantiate创建一个空的对象，也可直接new 出空对象；数据的提交可以使用obj.commit()可以使用Core.commit() public IMendixObject executeAction() throws Exception { // BEGIN USER CODE //第一种方式使用 IMendxObject创建数据 // IMendixObject ob= Core.instantiate(getContext(),\"Demo.User\"); // ob.setValue(getContext(),\"UserName\",UserName); // ob.setValue(getContext(),\"Password\",Password); // ob.setValue(getContext(),\"Age\",Age); // Core.commit(getContext(),ob); //第二种方式直接创建对象 User us=new User(getContext()); us.setUserName(UserName); us.setPassword(Password); us.setAge(Age); //提交数据到数据库 us.commit(getContext()); //也可以使用以下方式 //Core.commit(getContext(),us.getMendixObject()); return us.getMendixObject(); // END USER CODE } 二、数据的删除 数据的删除可以使用obj.delete()也可使用Core.delete() public java.lang.Boolean executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE //可以直接使用obj.delete ParameterParameter1.delete(getContext()); return true; // 也可以使用Core.delete的方式删除数据 //return Core.delete(getContext(),ParameterParameter1.getMendixObject()); // END USER CODE } 三、数据的修改 数据的修改和数据的提交类似，只是在action将数据修改后重新提交。 @Override public IMendixObject executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE ParameterParameter1.setUserName(\"===>我修改啦\"); ParameterParameter1.setPassword(\"我修改了密码\"); ParameterParameter1.setAge(200L); Core.commit(getContext(),ParameterParameter1.getMendixObject()); return ParameterParameter1.getMendixObject(); // END USER CODE } 四、查询数据 数据的查询主要使用以下几种方式 Core.retrieveXPathQuery() Core.retrieveXPathQueryAggregate() Core. retrieveId() Core. retrieveIdAsync() 其中XPath查询数据需要在前方加上// ；但是在mendix客户端编写xpath（比如在datagrid查询数据使用xpath）时 不需要加上//。 //Demo.User 检索所有用户。 //Demo.User[UserName='mrgao'] 检索名为'mrgao'的所有用户。 avg(//Demo.User[Age >10 ]/Age) 检索所有用户年龄大于10岁的 年龄平均数。 其中XPath可用的函数有： avg、count、max、min、sum、contains、starts-with、ends-with、not、true、false @Override public java.util.List executeAction() throws Exception { // BEGIN USER CODE List list=Core.retrieveXPathQuery(getContext(),\"//Demo.User\"); return list; // END USER CODE } 五、执行微流 微流的执行科分为同步执行execute()和异步执行executeAsyn()；此例子主要以同步执行为例； 微流执行时参数的传递主要使用Map的方式，且Key必须要和参数入参名称相同； 如果传入的是Object类型，则需要转化成mendixobject； 微流执行完成可获取到其返回的参数； public java.lang.String executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE Map map=new HashMap<>(); //记得转换成mendixobject,且Map的key需要和微流入参的名称一样 map.put(\"User\",ParameterParameter1.getMendixObject()); map.put(\"other\",other); //执行微流，mf为微流，map则为需要执行微流的入参 String result=Core.execute(getContext(),mf,map); return result; // END USER CODE } 如果还想了解更多相关Core的知识，请访问官方API ：Mendix官方CoreAPI 以及IMendixObject的API :IMendixObject官方API Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widget.html":{"url":"article/mendix/widget.html","title":"3. 组件开发","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/开发组件前工具的准备.html":{"url":"article/mendix/widgets/开发组件前工具的准备.html","title":"1) 环境准备","keywords":"","body":"环境依赖Mendix组件开发打包工具gulp和grunt的比较：环境依赖 一、设置npm镜像为淘宝镜像 npm config set registry https://registry.npm.taobao.org 二、 安装Node.js到本地，然后执行以下命令 npm install yo grunt-cli generator-mendix -g 三、执行jshint进行grunt语法检查插件 npm install grunt-contrib-jshint --save-dev 四、在任意地方建一个目录，并进入此文件夹，执行 Yo mendix //注意在安装的时候要记得选择Grunt方式不要选择Gulp；接下来的选择AppStoreWidgetBiolerplate,from Github的方式 // 执行完之后会在目录中创建一个Gruntfile.js文件；打开JS文件，将里面的mpks->files->dest->TEST_WIDGETS_FOLDER替换成自己的mendix 工程目录的widgets目录即可。 然后在当前组件目录(有Gruntfile.js的目录)执行 grunt watch //该命令会自动的监听组件工程文件的修改，会自动打包到mendix工程目录下 Mendix组件开发打包工具gulp和grunt的比较： gulp优点： 不需要设置项目目录，在test目录下即可测试。 若只更新了组件的js代码，可直接在浏览器强制刷新界面，不需要重启mendix工程。 编译速度更快。 grunt优缺点： 虽说可直接打包到项目工程目录widgets下，但是尽可能不要直接在业务工程下测试组件（因为项目大之后启动会慢）； 每次测试都需要重启Mendix工程。 一、下载并安装Node.js 下载地址：https://nodejs.org/en/ 二、设置npm镜像 npm config set registry https://registry.npm.taobao.org 三、运行yo命令 运行 npm install -g yo generator-mendix命令 检查yo是否安装成功:yo --version 四、安装gulp npm install -g gulp-cli 五、请在空目录下运行 yo mendix 并设置组件的名称，选择Gulp编译，并创建一个AppStoreWidgetBoilerplate。 六、如何使用Gulp测试组件 1、使用VsCode编辑器打开组件根目录 2、在VSCode中新建终端并运行 gulp命令，每次保存，gulp会自动将组件打包 并在dist目录下生成.mpk文件； mpk文件是组件最终的文件，如果您已经开发完成组件， 可以将.mpk文件复制到项目工程目录下的widgets目录下， 并在mendix客户端中按F4刷新项目目录。 3、如果想测试组件的功能，可以将项目根目录下的mpr文件拷贝到组件test目录下， 并且删除Test.mpr文件，如果项目中使用到了其他组件，请一并拷贝到test/widgets目录下。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/Vue_Mendix.html":{"url":"article/mendix/widgets/Vue_Mendix.html","title":"3) Vue开发Mendix组件模板","keywords":"","body":"使用Vue开发Mendix组件模板1. 安装git和zip2. 如何使用致谢 组件开发有很多中方式，比如使用React/Vue或者使用符合AMD规范的库；其实mendix官网开发的组件是使用的dojo开发。 如果有同学没有学习过Vue/React开发，但是对原生Javascript有一定了解的话，请移步开发一个简单组件需要的步骤和组件开发引入外部符合AMD规范的库存在的问题。我想在以上可以找到答案。 本文不详细解释如何使用Vue开发一个页面，如果您有使用Vue开发Mendix组件的需求， 那么请直接点击下载Mendix组件开发之Vue基础包。 使用基础包开发会减少您的开发周期，如果基础包有什么问题请联系我gaogangwork@qq.com。 使用Vue开发Mendix组件模板 English 如果你对mendix组件开发基础知识还不了解的话，请先移步个人博客-mendix组件开发专题 由于mendix只在Windows中有客户端，所以必须在windows中国使用此模板。 使用步骤如下： 1. 安装git和zip 第一步: 建议你使用git命令行来构建组件。git下载地址是 点击这里下载; 第二步: 安装 zip and bzip2 点击去这里下载zip和bzip2 我下载的是“zip-3.0-bin.zip” 和 “zip.exe” ， “bzip2-1.0.5-bin.zip” 和 “bzip2.dll” /bin/.exe 记住：将zip.exe文件和bzip2.dll文件拷贝到git安装目录下 2. 如何使用 第一步: 下载这个模板或者 git clone https://github.com/MrGaoGang/mendix_vue_template 第二步: 打开组件开发根目录 第三步:运行如下命令 npm install npm run build 如果你想打生产包的组件的话，请修改webpack.config.js的文件 mode: \"development\", // Change the mode do \"production\" before you go live! Don't forget! plugins: [ // Change the plugin do \"production\" before you go live! Don't forget! new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '\"development\"' // change to \"production\" when publishing your Mendix widget } }), 致谢 十分感谢 https://intonovi.com 封装了基础模板，其Github地址为here；本项目是基于此模板进行的优化和改良。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/详细API.html":{"url":"article/mendix/widgets/详细API.html","title":"4) 组件进阶-详细API","keywords":"","body":"一、组件开发mx.ui 界面设计二、组件开发mx.session获取三、组件开发数据获取mx.data四、组件开发mx.sever服务调用五、组件开发解析器mx.parse 首先对大家说一声抱歉，最近工作任务较为繁重，所以文章没有及时的更新；以下是最近几天加班总结和翻译出来的mendix，组件开发api文档。希望有同学能理解每一个对应API的作用。 一、组件开发mx.ui 界面设计 主要内容： 页面回退； 弹出框显示； 进度条显示与隐藏； 异常/信息/警告等显示； 组件重新加载； 表单打开； 微流操作中进度条显示； 文章地址： http://note.youdao.com/noteshare?id=1a91eb6560f8de4b0ffc9033b6c147d8 二、组件开发mx.session获取 主要内容： 组件中获取当前用户； 获取当前用户的GUID; 获取当前用户名； 获取当前用户的角色； 文章地址： http://note.youdao.com/noteshare?id=fe4218dce9aa1c7a1a4765e44f07c13c 三、组件开发数据获取mx.data 主要内容： 数据的创建； 数据的删除； 数据的查询； 数据的修改； 数据的监听； 文件保存 文章地址： http://note.youdao.com/noteshare?id=ab8c90ea1e44ffa6509c44568e0df8d5 四、组件开发mx.sever服务调用 主要内容： 服务的调用； 缓存查询 文章地址： http://note.youdao.com/noteshare?id=af24d16c2b8ff7229a368ffa1f69d318 五、组件开发解析器mx.parse 主要内容： 属性格式化； 值格式化； 值解析； 文章地址： http://note.youdao.com/noteshare?id=9e5210978d7789439e79f3c8bbffbc88 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/常用API.html":{"url":"article/mendix/widgets/常用API.html","title":"5) 组件进阶-常用API","keywords":"","body":"一、常用的API（五）查询管理关系的数据（六）创建一个上下文二、组件开发XML文档（一）property配置（二）两个例子 原生前端API主要有一下几个： 1、mx.ui/mx.data/mx.server/mx.session : 链接 2、mendix ：链接 3、mxui : 链接 一、常用的API (一) 从实体中获取/创建/删除数据 mx.data.get({ xpath: \"//System.User\", filter: { sort: [[\"Name\", \"asc\"]], offset: 0, amount: 10 }, callback: function(objs) { console.log(\"Received \" + objs.length + \" MxObjects\"); } }); mx.data.create({ entity: \"MyFirstModule.Cat\", callback: function(obj) { console.log(\"Object created on server\"); }, error: function(e) { console.error(\"Could not commit object:\", e); } }) mx.data.remove({ guids: [ \"123456\", \"45678\" ], callback: function() { console.log(\"Objects removed\"); }, error: function(e) { console.log(\"Could not remove objects:\", e); } }); （二）执行微流 mx.ui.action(\"微流的名称\",{ context:上下文, progress: \"modal\", progressMsg:\"进度条消息\", callback: function(result) { console.log(\"Engine started: \" + result); } }) mx.data.action({ params: { applyto: \"selection\" actionname: \"微流\", guids: [ \"281530811285515\", \"281530811285506\"]//需要传递的参数 }, callback: function(obj) { // expect single MxObject alert(obj.get(\"manufacturer\")); }, error: function(error) { alert(error.message); } }); （三）打开页面 /** 请见：https://apidocs.mendix.com/7/client/mendix_lib_MxContext.html */ //上下文如何获取? var _context=mendix.lib.MxContext(); _context.setTrackEntity(你需要传递的实体) //或者使用_context.setTrackId(你需要传递的guid) mx.ui.openForm(\"页面\",{ location: \"content/popup/modal\", context:_context, callback: function(form) { console.log(form.id); } }) （四）监听实体值得变化 //监听某个实体的变化 var subscription = mx.data.subscribe({ guid: \"123213\", callback: function(guid) { console.log(\"Object with guid \" + guid + \" changed\"); } }); mx.data.unsubscribe(subscription); //监听实体某个属性的变化 var subscription = mx.data.subscribe({ guid: \"123213\", attr: \"Name\", callback: function(guid, attr, value) { console.log(\"Object with guid \" + guid + \" had its attribute \" + attr + \" change to \" + value); } }); mx.data.unsubscribe(subscription); //监听整个实体的变化 // Subscribe to changes in a class var subscription = mx.data.subscribe({ entity: \"System.User\", callback: function(entity) { console.log(\"Update on entity \" + entity); } }); mx.data.unsubscribe(subscription); （五）查询管理关系的数据 //多对一关系，路径要指定到关联关系实体的字段 obj.fetch(\"Demo.Test/Test_Test2/test2Attr\",function(data){ //成功回调数据，返回的是一条数据 },function(){ }); //多对对一关系，路径要指定到关联关系实体，不能是字段 obj.fetch(\"Demo.Test/Test_Test3\",function(data){ //成功回调数据，返回的是一个列表数据 },function(){ }); （六）创建一个上下文 详情请见:组件开发上下文 var context=mendix.lib.MxContext(); context.setTrackEntity(你的obj) 二、组件开发XML文档 （一）property配置 1、配置的类型有： //页面 //微流 2、其他配置项 isList=\"\" //是否为列表配置，只有当type=\"object\"的时候有效 entityProperty=\"配置实体的key\" //执行微流时入参的实体，注意此处的Key为相对位置； //也即是如果这个key所在的property和你配置的property在同一层级， //那么就直接使用实体的key，要是此propery比实体的property深一层， //那么此处就要写: ../实体的key allowNonPersistableEntities=\"false\"//是否允许非持久化实体 isPath=\"no\"//是否可通过关联取数据 parameterIsList=\"false/true\"//微流的入参是否为List的形式 multiline=\"false\"//当type=\"string\"的时候是否支持多行 defaultValue=\"\"//默认值 required=\"false/true\"//此配置项是否必须配置 isDefault=\"false\"//是否默认 （二）两个例子 1、枚举选择，实际在读取的时候是按照key 名称 分类 描述 弹窗 当前页面 2、实体配置 名称 分类 描述 3、微流配置（接受list方式的入参） 名称 分类 描述 或者 //上述的returnType的type可以有 4、选择实体的属性 名称 分类 描述 //所有可能的类型有: 5、选择实体的属性 //所选择的属性为某个实体下面的属性 名称 分类 描述 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/Mendix后台程序环境搭建.html":{"url":"article/mendix/Mendix后台程序环境搭建.html","title":"4. Mendix后台程序环境搭建","keywords":"","body":"一、Docker的安装二、Docker Compose安装三、Mendix环境搭建四、启动成功五、Mendix后台环境搭建注意事项 以下所有文件均是原创，如需转载请注明作者和链接地址。 目录： 一、Docker的安装 二、Docker Compose安装 三、Mendix环境搭建 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 2、登录时为何使用Administor无法登录 3、docker-compose-mysql字段简要介绍 4 、访问地址为何过总是报错502 当在Mendix Desktop上编写完成项目，此时需要打包发布；首先请在客户端 -->Project-->Create Deployement Project； Mendix后台程序需要运行在Docker环境下，此文主要介绍mendix如何在centos下运行。 打包环境必须为生产环境： Mendix程序需要运行需要的环境限制： 在Centos7.3及以上版本,且Docker 要求 CentOS 系统的内核版本高于 3.10； 由于Mendix运行的Docker compose版本为1.22,所以请安装Docker 17.06.2。 一、Docker的安装 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce-17.06.2 #安装的是最新稳定版17.06.2 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version 二、Docker Compose安装 在安装Docker Compose之前请确定已经安装了python-pip。 python-pip安装教程请见此文 https://blog.csdn.net/yulei_qq/article/details/52984334 安装好pip之后，就可以安装Docker-Compose了. 在linunx终端执行：pip install docker-compose. 检查docker-compose是否安装成功： 三、Mendix环境搭建 Mendix运行在docker中，其开源环境请见:https://github.com/mendix/docker-mendix-buildpack。 开源地址的Readme.md文件有如下介绍： 简单介绍： get-sample：得到一个Mendix应用程序，并将其解压到build目录下； buid-image：创建Mendix运行，需要的镜像； run-container：启动容器。 1、请将您之前打包好的mda文件上传到服务器 scp xxx.mda root@ip地址:/usr/local/mendix/app (xxx：自己的工程名；mendix/app是自己创建的目录) 2、复制项目并切换目录 git clone https://github.com/mendix/docker-mendix-buildpack cd docker-mendix-buildpack 3、将sample的apk替换成自己的apk 替换成： 4、启动容器 运行make run-container 正常情况下容器会被启动，这样就可以通过url地址访问自己的应用程序。但是在启动时总会遇到各种问题。 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 由于在配置文件中配置了docker的8080映射到服务器的80端口，以及8090映射到81端口；所以请确认服务器的这两个端口是否已被占用（如果已经被占用：可修改此处的配置文件） 如果修改成其他的端口，请记修改Dockerfile配置文件中的nginx端口：否则程序不会允许 3、登录时为何使用Administor无法登录 mendix客户端的administor账户是在测试环境使用的； 如果程序发布到服务器， 则需要登录的账户为：MxAdmin 密码为：docker-compose-mysql中的ADMIN_PASSWORD字段 4、docker-compose-mysql字段简要介绍 mendixapp: image:为docker镜像； ADMIN_PASSWORLD:使用MxAdmin账户登录系统的密码； DATABASE_ENDPOINT：应用的数据库地址，最后一个mendix为创建的mendix数据库； ports：docker端口和服务器端口的映射关系，如果服务器的端口已被占用，则需要修改映射的端口； db： MYSQL_DATABASE=mendix //mendix数据库名 MYSQL_USER：mendix数据库的用户 MYSQL_PASSWORD：mendix数据库的密码 MYSQL_ROOT_PASSWORD=root //数据库最高权限密码（当然账号也为root） ports：docker中数据库端口和服务器端口的映射关系。 5、访问地址为何过总是报错502 哪些情况出现502: 访问次数过多； 3个小时左右会自动停止； 之所以一直报错502的最根本原因是没有向Mendix购买license；没有license 最多只能在线10个用户，且系统每隔3小时左右关闭。所以需要向Mendix购买License。 停止了，可重启容器 重新部署包，则需要先关闭mysql容器，再使用make run-container。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/获取配置信息,使用java创建Rest服务.html":{"url":"article/mendix/获取配置信息,使用java创建Rest服务.html","title":"6. 使用Java创建Rest服务","keywords":"","body":" 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、如何读取resource下的配置文件信息 假设resource目录下的文明为properties文件； //第一步：获取配置文件目录: File resourcePath=Core.getConfiguration().getResourcesPath(); //第二步：读取对应配置文件，此处可以根据环境的不同读取不同的配置文件 File configFile=new File(resourcePath,\"config.properties\"); Properties prop = new Properties(); //第三步：读取属性文件到Properties中 InputStream in = new BufferedInputStream (new FileInputStream(configFile)); prop.load(in); ///加载属性列表 Iterator it=prop.stringPropertyNames().iterator(); while(it.hasNext()){ String key=it.next(); System.out.println(key+\":\"+prop.getProperty(key)); } in.close(); 2、如何获取Cookie String cookies=\"\"; Cookie[] cook=this.context().getRuntimeRequest().get().getHttpServletRequest().getCookies(); for(Cookie c:cook){ cookies+=c.getName()+\"=\"+c.getValue()+\";\"; } 3、如何在java中打Log private static ILogNode log=Core.getLogger(\"mylogname\"); 4、如何在mendix启动之前做一下预处理？ 只需要在Project》Settings》Runtime》After Startup中调用即可。 5、自定义Rest服务 常常使用mendix自带的Rest服务无法满足我们的需求，那么怎么自定义Rest服务呢？自定义Rest服务只需要继承RequestHandler即可。 //第一步：继承RequestHandler，并实现processRequest方法 public class ArticleService extends RequestHandler { @Override protected void processRequest(IMxRuntimeRequest iMxRuntimeRequest, IMxRuntimeResponse iMxRuntimeResponse, String path) throws Exception { } } //第二步：在启动整个mendix的时候，调用一个Javaaction，在此Action中进行Rest服务注册。 public java.lang.Boolean executeAction() throws Exception { // BEGIN USER CODE //throw new com.mendix.systemwideinterfaces.MendixRuntimeException(\"Java action was not implemented\"); // 注册自定义服务 Core.addRequestHandler(\"my/rest\",new ArticleService()); return true; // END USER CODE } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/一些功能的实现.html":{"url":"article/mendix/一些功能的实现.html","title":"7. Mendix教程（11篇文章）","keywords":"","body":" 由于文章较多，此处列举一些常实现的mendix功能和大家分享。以下所有文件均是原创，如需转载请注明作者和链接地址。 一、基础公共包功能一览 基础公共包功能一览 二、使用dojo开发mendix组件你必须知道的 dijit.register你必须知道的 dojo.aspect模块你必须知道的 dom-construct 三、开发者与非开发者如何定制化datagrid的样式 定制化datagrid 四、Excel中大量字段如何高效构建Entity Excel中大量字段如何高效构建Entity 五、Mendix实现级联选择 Mendix实现级联选择 六、Mendix导出数据到Excel（基础使用） Mendix导出数据到Excel（基础使用) 七、Mendix如何一键导出数据到Excel的多个Sheet Mendix如何一键导出数据到Excel的多个Sheet 八、Mendix监控实现方案（使用自带端口） Mendix监控实现方案（使用自带端口） 九、Mendix使用队列异步处理大量数据 Mendix使用队列异步处理大量数据 十、Mendix使用Excel导入数据 Mendix使用Excel导入数据 十一、DataGrid数据从微流获取，并实现自定义Search DataGrid数据从微流获取，并实现自定义Search Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/other/vscode.html":{"url":"article/other/vscode.html","title":"VsCode插件开发","keywords":"","body":"一、环境搭建二、package.json 配置三、contributes介绍四、常用 API五、环境 简介：本文将会教会大家如何一步步开发Vscode插件。 插件地址 luck_npm 欢迎star 此插件的主要功能是方面使用 npm install,npm run dev,npm run build 命令；搭配 vue 脚手架 Vue+webpack+vuex+router更加舒适哦 效果图： 一、环境搭建 1、npm install -g yo generator-code 安装脚手架; 2、yo code 创建项目 本人选择的是：javascript 创建好之后系统会自动生成一个 package.json 和 extension.js 文件； 二、package.json 配置 { \"name\": \"lucky-npm\", //插件名称 \"displayName\": \"lucky npm\", \"description\": \"\", \"version\": \"1.0.1\", \"publisher\": \"mrgao\", \"engines\": { \"vscode\": \"^1.32.0\" }, \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/MrGaoGang/lucky_start.git\" }, \"categories\": [ //分类 \"Other\" ], \"icon\": \"icon/logo.png\", //logo \"activationEvents\": [ //激活方式 \"workspaceContains:package.json\", \"onCommand:lucky.gao.extension.install\", \"onCommand:lucky.gao.extension.start_dev\", \"onCommand:lucky.gao.extension.build_pro\" ], \"main\": \"./extension.js\", //入口文件 \"contributes\": { \"snippets\": [ //自定义一些代码模板（可以尝试输入fetch） { \"language\": \"javascript\", \"path\": \"./src/snippet/snippet.json\" } ], \"views\": { //视图 \"explorer\": [ { //在资源管理器中的视图，id为mrgao_luckys，名字为LUCKY NPM \"id\": \"mrgao_luckys\", \"name\": \"LUCKY NPM\" } ] }, \"commands\": [ //有哪些命令 { \"command\": \"lucky.gao.extension.install\", \"title\": \"安装依赖(install)\" }, { \"command\": \"lucky.gao.extension.start_dev\", \"title\": \"启动测试环境(dev)\" }, { \"command\": \"lucky.gao.extension.build_pro\", \"title\": \"构建生产版本(pro)\" } ], \"menus\": { //菜单，是否右键显示菜单，其中group为分类, \"editor/context\": [ { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.install\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.start_dev\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.build_pro\", \"group\": \"6_luck\" } ] } }, \"scripts\": { \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" }, \"devDependencies\": { \"typescript\": \"^3.3.1\", \"vscode\": \"^1.1.28\", \"eslint\": \"^5.13.0\", \"@types/node\": \"^10.12.21\", \"@types/mocha\": \"^2.2.42\" } } 1. activationEvents 介绍 激活插件的方式 onLanguage 激活 发出此激活事件，只要解析为某种语言的文件被打开，就会激活感兴趣的扩展。 \"activationEvents\"：[ \" onLanguage：python \" ] 可以使用数组中的单独 onLanguage 条目声明多种语言 activationEvents。 \"activationEvents\"：[ \" onLanguage：json \", \" onLanguage：markdown \", \" onLanguage：typescript \" ] onCommand 加载方式 发出此激活事件，并且只要调用命令，就会激活当前扩展： \" activationEvents \"：[ \" onCommand：extension.sayHello \" ] onDebug 加载方式 并在启动调试会话之前激活当前扩展： \" activationEvents \"：[ \" onDebug \" ] onDebugInitialConfigurations onDebugResolve 这是两个更细粒度的 onDebug 激活事件： onDebugInitialConfigurations 在调用 provideDebugConfigurations 方法之前触发 DebugConfigurationProvider。 onDebugResolve:type 在调用指定类型的 resolveDebugConfiguration 方法之前触发 DebugConfigurationProvider。 经验法则：如果调试扩展的激活是轻量级的，请使用 onDebug。如果它是重量级的，则使用 onDebugInitialConfigurations 和/或 onDebugResolve 取决于是否 DebugConfigurationProvider 实施相应的方法 provideDebugConfigurations 和/或 resolveDebugConfiguration。有关这些方法的更多详细信息，请参阅使用 DebugConfigurationProvider。 workspaceContains 激活方式 每当打开文件夹并且文件夹包含至少一个与 模式匹配的文件时，就会激活此激活事件并激活当前扩展。 \" activationEvents \"：[ \" workspaceContains：** /。editorconfig \" ] onFileSystem 激活方式 发出此激活事件，只要读取特定方案中的文件或文件夹，就会激活感兴趣的扩展。这通常是 file-scheme，但是对于自定义文件系统提供程序，有更多的方案可以实现，例如 ftp 或 ssh。 \" activationEvents \"：[ \" onFileSystem：sftp \" ] onView 激活方式 发出此激活事件，只要展开指定 ID 的视图，就会激活当前扩展： \" activationEvents \"：[ \" onView：nodeDependencies \" ] onUri 激活方式 发出此激活事件，只要打开该扩展的系统范围的 Uri，就会激活感兴趣的扩展。Uri 计划固定为 vscode 或 vscode-insiders。Uri 权限必须是扩展的标识符。Uri 的其余部分是任意的。 \" activationEvents \"：[ \" onUri \" ] 如果 vscode.git 扩展名定义 onUri 为激活事件，则会在以下任何一个 Uris 中打开它： vscode://vscode.git/init vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git vscode-insiders://vscode.git/init （对于 VS Code Insiders） onWebviewPanel 激活方式 每当 VS Code 需要使用匹配恢复 webview 时，将发出此激活事件并激活当前扩展 viewType。 例如，onWebviewPanel 的声明如下： \" activationEvents \"：[ \" onWebviewPanel：catCoding \" ] 当 VS Code 需要使用 viewType 恢复 webview 时，将导致扩展被激活：catCoding。viewType 在调用中设置 window.createWebviewPanel，您需要有另一个激活事件（例如，onCommand）来初始激活您的扩展并创建 webview。 * 激活方式 该*激活事件发出后，每当 VS 代码启动感兴趣的扩展将被激活。为确保良好的最终用户体验，请仅在您的用户使用其他激活事件组合时才在扩展中使用此激活事件。 \" activationEvents \"：[ \" * \" ] 三、contributes介绍 详情请见 contributes介绍 四、常用 API 这里主要介绍一下 extension 中的一些常用命令。官方 API 请见: vscode api 1. 命令 命令注册 //注册命令 vscode.commands.registerCommand('lucky.hello', () => { }); //注册之后必须在package.json中配置: { \"contributes\": { \"commands\": [{ \"command\": \"lucky.hello\", \"title\": \"Hello World\" }] } } // 命令执行 //vscode.open为vscode自带命令（也可以使用自己的命令），可以用来打开一个页面 vscode.commands.executeCommand( \"vscode.open\", vscode.Uri.parse(`https://code.visualstudio.com/updates/`) ); 获取所有命令 vscode.commands.getCommands(false); //会返回所有命令 接收一个参数:是否显示系统自带的内部命令,此处Wiefalse 2. 显示 vscode.window.showInformationMessage(\"我是info信息！\"); vscode.window.showErrorMessage(\"我是错误信息！\"); vscode.window.setStatusBarMessage(\"设置状态栏的消息\"); //带回调的提示 vscode.window .showInformationMessage(\"是否要做什么.....？\", \"是\", \"否\", \"不再提示\") .then(result => { if (result === \"是\") { } else if (result === \"不再提示\") { // 其它操作 } }); 3. window 创建一个终端并输入命令 let terminalA = vscode.window.createTerminal({ name: \"我是终端的名字\" }); terminalA.show(true); terminalA.sendText(\"npm start\"); //输入命令 显示一个输入框，让用户输入一个字符串 /** * 打开输入框以询问用户输入。 undefined如果输入框被取消（例如按ESC），则返回值。否则，返回的值将是用户键入的字符串，如果用户没有输入任何内容，则返回值为空，但是单击\"确定\"将输入框解除。 * */ const result = vscode.window.showInputBox({ prompt: \"请输入版本号，\", value: \"默认值\", placeHolder: \"提示\", valueSelection: [len, len] }); result.then(inputValue => { // 是按下ESC键 if (typeof _versionName === \"undefined\") return; //按下enter键 }); 创建树状视图 vscode.window.registerTreeDataProvider('viewId', treeProvider); //viewId对应package.json中id \"contributes\": { \"views\": { \"explorer\": [ { \"id\": \"viewId\", \"name\": \"NPM Tools\" } ] }, } //treeProvider请见此插件源码。 打开文档 vscode.workspace.openTextDocument(vscode.Uri.file(\"文件路径)).then( document => vscode.window.showTextDocument(document) ) 五、环境 vscode.env.appName //当前编辑器的名称 vscode.env.appRoot //打开的根目录 vscode.env.language //用户的语言环境 插件地址 欢迎star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "}}