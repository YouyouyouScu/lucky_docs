{"./":{"url":"./","title":"Introduction","keywords":"","body":"每日一学JavaScript基础学习Vue开发其他每日一学 常用第三方库 目录： JavaScript基础学习 Vue开发 JavaScript基础学习 Javascript继承机制的设计思想 【转载】 Javascript 代码执行顺序 :+1: 【转载】 Javascript的call和applay方法 【原创】 Javascript深入之创建对象的多种方式以及优缺点 【转载】 Javascript的变量提升和函数提升 【原创】 Vue开发 Vue父组件使用scoped无法修改子组件样式 【原创】 Vue插件开发详解 【原创】 Vue使用render函数渲染组件详解 【原创】 其他 常用的github API Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-12 20:34:55 "},"article/vue/":{"url":"article/vue/","title":"Vue","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-25 21:42:07 "},"article/vue/Vue父组件使用scoped无法修改子组件样式.html":{"url":"article/vue/Vue父组件使用scoped无法修改子组件样式.html","title":"1. Vue父组件使用scoped无法修改子组件样式","keywords":"","body":"1、部分全局方法2、深选择器 在Vue开发中我们难免会引用各种组件和样式；有时候样式不符合业务需求；则需要对指定的dom进行样式的修改；如果我们在vue中使用了scoped， 则无法在父组件中修改子组件的样式。下面介绍几种修改样式的方法 1、部分全局方法 /**在全局样式中修改要覆盖的样式**/ /**本地样式**/ 2、深选择器 .parentclass >>> .childClass{ } /**或者使用**/ .parentclass /deep/ .childClass{ } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-25 21:42:54 "},"article/vue/Vue使用render函数渲染组件.html":{"url":"article/vue/Vue使用render函数渲染组件.html","title":"2. Vue使用render函数渲染组件","keywords":"","body":"一、Render 函数参数详解二、样例：如何给表格组件添加表头筛选此文源码案例:欢迎Star 目录 一、Render 函数参数详解 二、样例：如何给表格组件添加表头筛选 Vue 组件的开发有几种方式：单文件组件，使用 render 函数渲染，使用 template。 在大多数的情况下，Vue 可以使用单文件/template 的方式来创建页面；然而在有一些情况我们需要使用 JavaScript 的编程能力，比如使用第三方框架时，想要自定义某个功能；这个时候就可以使用到 render 函数。 本文将使用 iView table 为例，通过 render 函数添加可搜索的表头筛选。 一、Render 函数参数详解 //一个简单的例子：渲染一个p标签，内容为 '我是p标签的内容' new Vue({ render: createElement => createElement(\"p\", \"我是p标签的内容\") }); 其实 createElement()还有更强大的参数: // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 \"div\", // {Object} // 一个包含模板相关属性的数据对象, // 你可以在 template 中使用这些特性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ \"先写一些文字\", createElement(\"h1\", \"一则头条\"), createElement(MyComponent, { props: { someProp: \"foobar\" } }) ] ); createElement(obj,{},[]) 参数详解: 第一个参数为渲染成哪个节点，接受 String,Object,Function 三种类型； 如果是 String,比如是 div，那么表示此标签将会渲染成 div 标签；String 渲染成普通的 html 标签 如果是 Object，比如是一个 Vue 的组件:TableFilter，那么表示此标签将会渲染一个组件。通常我们在单文件组件中使用的时候是 import {Table} from \"iview\";然后在 template 中引用此标签；而使用 render 则需要使用 createElement 方式创建一个。 如果是 Function，则可以根据自己的业务逻辑动态觉得是渲染成普通的 html 标签还是 Vue 组件。 2) 第二个参数接受 一个对象{}类型的数据。其主要作用类似于组件中对某一个节点设置各种 bind 属性：设置样式 style，设置事件 on，设置类 class，设置自定义的命令，设置普通的 html 属性，设置传递参数 props 等等。 有一点要注意：正如在模板语法中，v-bind:class 和 v-bind:style，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。 { // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: { color: 'red', fontSize: '14px' }, // 普通的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on`，当子组件使用$emit()方式发生，使用on接收 // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // 作用域插槽格式 // { name: props => VNode | Array } scopedSlots: { default: props => createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true } 你会发现使用 render 函数没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：比如 props: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } 第三个参数为列表类型的数据，表示当前渲染组件的有哪些子组件。 render(createElement=> return createElement( 'div', { }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [// '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] )) 注意：子组件中的每一项（VNodes）都必须是唯一的;意味着，下面的 render function 是无效的： render: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 二、样例：如何给表格组件添加表头筛选 效果图: iview的默认table组件不支持 表头输入框筛选，官方地址 此处默认您有了一定的vue开发基础。 套用iview官方的例子： //显示表格的例子 import { Table ,Button,Icon,Modal} from \"iview\"; import Vue from \"vue\"; export default { components: { Table }, data() { return { columns7: [ { title: \"Name\", key: \"name\", //使用render函数自定义列显示效果：文本加粗 render: (h, params) => { return h(\"div\", [//使用render渲染一个div标签 h(Icon, {//使用render渲染一个iview的组件 props: {//传递参数 type: \"person\" } }), h(\"strong\", params.row.name)//文字加粗 ]); } }, { title: \"Age\", key: \"age\" }, { title: \"Address\", key: \"address\" }, { title: \"Action\", key: \"action\", width: 150, align: \"center\", render: (h, params) => { return h(\"div\", [//渲染一个div标签 h( Button,//在div标签下渲染一个iview组件 { props: {//传递参数 type: \"primary\", size: \"small\" }, style: {//设置样式 marginRight: \"5px\" }, on: {//监听$emit事件 click: () => { this.show(params.index); } } }, \"View\" ), h( Button, { props: { type: \"error\", size: \"small\" }, on: { click: () => { this.remove(params.index); } } }, \"Delete\" ) ]); } } ], data6: [ { name: \"John Brown\", age: 18, address: \"New York No. 1 Lake Park\" }, { name: \"Jim Green\", age: 24, address: \"London No. 1 Lake Park\" }, { name: \"Joe Black\", age: 30, address: \"Sydney No. 1 Lake Park\" }, { name: \"Jon Snow\", age: 26, address: \"Ottawa No. 2 Lake Park\" } ] }; }, methods: { show(index) { this.$Modal.info({ title: \"User Info\", content: `Name：${this.data6[index].name}Age：${ this.data6[index].age }Address：${this.data6[index].address}` }); }, remove(index) { this.data6.splice(index, 1); } }, mounted(){ //modal注入 Vue.prototype.$Modal=Modal; } }; 由于table组件表头筛选不支持输入框筛选，那么我们就必须的自己绘制。 思路如下： 找到表头所在的节点 在表头节点后添加一个自定义筛选的div节点； 使用render函数渲染一个下拉输入的单文件组件 mounted(){ //modal注入 Vue.prototype.$Modal=Modal; //等dom元素渲染完成之后渲染筛选 this.$nextTick(()=>{ this.renderHeaderFilter(); }) } methods:{ //添加头部筛选 renderHeaderFilter(){ let allHeader =document.querySelectorAll(\".ivu-table-header .ivu-table-cell\"); console.log(allHeader); allHeader.forEach((element)=>{ let createNew=document.createElement(\"div\"); createNew.classList.add(\"vue-header-filter\"); element.appendChild(createNew); new Vue({ render(h){ return h(TableHeaderFilter,{ props:{} }) } }).$mount(createNew); }) } } 最后实现的效果为: 此文源码案例:欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-25 21:46:17 "},"article/vue/Vue中插件开发的四种方式.html":{"url":"article/vue/Vue中插件开发的四种方式.html","title":"3. Vue中插件开发的四种方式","keywords":"","body":"阅读前必读一、添加全局方法和属性二、给Vue实例添加方法和属性三、通过混入 mixin 方法添加一些组件选项;四、添加全局资源：指令，过滤器等为什么要开发插件？ 插件是对Vue功能上的补充，比如可以设置页面全局共享属性，方法等。 目录 阅读前必读 一、添加全局方法和属性 二、给Vue实例添加方法和属性 三、通过混入 mixin 方法添加一些组件选项; 1. 局部混入 2. 全局混入 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 2. 添加过滤器 依据官方文档插件开发说明，插件开发有四种方式。 添加全局方法或者属性; 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 通过全局 mixin 方法添加一些组件选项; 添加全局资源：指令/过滤器/过渡等; 一个库，提供自己的 API，同时提供上面提到的一个或多个功能， 阅读前必读 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象. 比如： export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } 开发插件时，给Vue/Vue实例添加方法或者属性时，建议命名方式使用$开头，这样就不会存在和插件命名冲突。如果冲突了则优先使用组件属性/方法。 一、添加全局方法和属性 作用: 添加全局方法和属性，所有组件都可共享方法和属性，当某个组件更新了共享属性，那么其他组件也会同步更新。并非是组件实例之间的数据共享。 //1:编写组件 export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } //2:声明组件，注入组件 import install from \"./plugins/demo.js\"; Vue.use(install); //3：组件样例 {{ formatNumber }} import Vue from \"vue\"; export default { data() { return { gloablFunc: \"\" }; }, computed: { formatNumber: function() { //调用全局共享方法 return Vue.$globalFunction(this.gloablFunc); } } }; 二、给Vue实例添加方法和属性 方式:使用Vue.prototype的方式给Vue实例添加方法和属性 注意点：使用Vue.prototype的方式添加的属性是不会在各个实例之间数据共享的。 比如A实例修改了某属性，则B实例使用此属性时不会是A修改的值。 //1：组件编写 demo.js export default { install: function(Vue, options) { Vue.prototype.$instanceFunction = function(num) { return 3 * num; }; Vue.prototype.$instanceVar=\"我是实例变量\"; } }; //2：组件声明 main.js import install from \"./plugins/demo.js\"; Vue.use(install); //3:组件使用 Plugins.vue ...省略部分 添加实例方法/属性测试 {{ instanceVar }} mounted(){ console.log(this.$instanceVar); this.instanceVar=this.$instanceVar; //this.instanceVar=this.$instanceFunction(20); } 三、通过混入 mixin 方法添加一些组件选项; 混入mixin作用： 将混入对象的方法/数据对象合并到改组件本身的方法/数据上；若存在同名的方法，则首先调用混入对象，再调用组件本身方法，若存在同名数据对象，则使用组件的数据对象 混入分为局部混入和全局混入，一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。请谨慎使用全局混入，尽可能使用局部混入。 1. 局部混入 此处借用官方的例子选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 若存在同名方法则优先调用混入对象的方法。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 ```js var mixin = { data: function() { return { message: \"hello\", foo: \"abc\" }; }, created: function() { console.log(\"混入对象的钩子被调用\"); }, methods:{ demo1(){ console.log(\"混入demo1\"); }, demo2(){ console.log(\"混入demo2\"); } } }; export default { mixins: [mixin], data: function() { return { message: \"goodbye\", bar: \"def\" }; }, created: function() { console.log('组件钩子被调用') console.log(this.$data); //混入对象的钩子被调用 //组件钩子被调用 // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } }, methods:{ demo1(){ console.log(\"组件demo1\"); } } }; #### 2. 全局混入 为全局Vue实例混入一个created方法，在每一个实例调用本身的created之前都会首先调用混入的created。 **通常我们可以使用全局混入对Vue实例注入统一处理统计**。 ```js // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({ created: function () { //console.log(\"相信我，这个Log会在每一个Vue实例created之前调用\"); var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: 'hello! mrgao' }) // => \"hello!\" 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show等)，Vue 也允许注册自定义指令。 参考官方文档：自定义指令 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 //D.vue export default { data() { return { message: \"我是demo\" }; } }; //main.js Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) 结果为： name: \"demo\" value: \"我是demo\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 2. 添加过滤器 //1：编写过滤器 currency.js const digitsRE = /(\\d{3})(?=\\d)/g export function currency (value, currency, decimals) { value = parseFloat(value) if (!isFinite(value) || (!value && value !== 0)) return '' currency = currency != null ? currency : '$' decimals = decimals != null ? decimals : 2 var stringified = Math.abs(value).toFixed(decimals) var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified var i = _int.length % 3 var head = i > 0 ? (_int.slice(0, i) + (_int.length > 3 ? ',' : '')) : '' var _float = decimals ? stringified.slice(-1 - decimals) : '' var sign = value 单价:{{ product.price | currency }} 上述已经简单讲解了Vue插件开发的四种方式，最后一种方式，也就是将上述四种组合在一个install方法中即可。 文章实例请见：examples目录。 欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-04-25 22:23:14 "}}