{"./":{"url":"./","title":"简介","keywords":"","body":" 是否感谢大家来到我的个人博客，俗话说“好记性不如烂笔头”，在互联网高速发展的今天，主动学习成为一个必备技能。个人主要从事Mendix，Vue，Android开发的相关工作，由于最近工作的原因Android接触较少，请大家见谅。 此文主要分为六大板块，分别介绍了个人的一些开源工具，以及Vue,Javascript,Mendix等开发；同时提供了一些常用插件开发技巧和开发中资源的收集和整理。 我的开源项目(欢迎star) 1. luckly_recyclerview 2. luckly_popup_window 3. Vue+iView开发基础包 4. 个人Github移动客户端 oView 基于F2的移动端图表库 1. 快速开始 2. 图表Chart 3. 图表构建 饼状图 柱状图 折线图 雷达图 散点图和气泡图 面积图 Vue开发 1. Vue父组件使用scoped无法修改子组件样式 2. Vue使用render函数渲染组件 3. Vue中插件开发的四种方式 2. Vue监听路由变化之数据刷新 轻量化平台Mendix 1. Mendix环境搭建 2. Mendix使用Java 3. 组件开发 1) 环境准备 2) 开发组件之注意事项 3) Vue开发Mendix组件模板 4) 组件进阶-详细API 5) 组件进阶-常用API 4. Mendix后台程序环境搭建 5. 如何使用Mendix创建REST服务 6. Mendix后台程序环境搭建 7. Mendix教程（11篇文章） Android开发 其他及工具 VsCode插件开发 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/open/luckly_recyclerview.html":{"url":"article/open/luckly_recyclerview.html","title":"1. luckly_recyclerview","keywords":"","body":"一、部分方法介绍9、设置上拉加载和下拉刷新在不同的状态10、设置是否空白视图和错误视图点击刷新11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦)12、 局部刷新二、如何实现分组1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP);2、重写Adapter继承基类BaseGroupAdapter3、常用的几个方法三、具体如何使用请看例子 简介：使用RecyclerView封装headerview,footerView,并实现上拉加载更多，下拉刷新，分组功能(添加上拉加载和下拉刷新设置背景) 界面可能有点丑，&#x1F601;，但是是为了展示所有效果，请大家见谅。（所有东西都是可自己设置的哦）&#x1F60A; 效果图： 如何获取: 第一步：在项目的build.gradle中添加 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 第二步：添加依赖 dependencies { compile 'com.github.mrgaogang:luckly_recyclerview:v2.3.0' } 目录 一、部分方法介绍 1、设置加载更多的监听事件 2、设置下拉刷新监听事件 3、添加分割线 4、添加错误视图 5、添加空视图 6、添加headerView 7、设置下拉刷新进度条的颜色和字体的颜色 8、设置监听事件 9、设置上拉加载和下拉刷新在不同的状态 10、设置是否空白视图和错误视图点击刷新 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 12、 局部刷新 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 3、常用的几个方法 三、具体如何使用请看例子 一、部分方法介绍 1、设置加载更多的监听事件 mLRecyclerView.setLoadMoreListener(this); 并重写onLoadMore()方法。 2、设置下拉刷新监听事件 mLRecyclerView.setOnRefreshListener(this); 并重写onRefresh()方法。 3、添加分割线 已经封装好了线性布局的分割线和网格式布局的分割线、流式布局的分割线。 //线性布局 mLRecyclerView.addLinearDivider(LRecyclerView.VERTICAL_LIST); //网格式布局 mLRecyclerView.addGridDivider(); //可以指定颜色和宽度 addGridDivider(int color, int dividerHeight) addLinearDivider(int oritation, int color, int lineWidth) 4、添加错误视图 当网络连接失败等情况的时候，需要显示错误视图。 //添加错误的View mLRecyclerView.setErrorView(R.layout.error_view); //添加错误的View View error = LayoutInflater.from(this).inflate(R.layout.view_error, null, false); mLRecyclerView.setErrorView(error); 使用getErrorView()得到错误视图。 5、添加空视图 当数据为空的时候，需要显示。 //添加空的View mLRecyclerView.setEmptyView(R.layout.empty_view); //添加空的View View empty = LayoutInflater.from(this).inflate(R.layout.view_empty, null, false); mLRecyclerView.setEmptyView(error); 使用getErrorView()得到空视图。 6、添加headerView //添加headerView mLRecyclerView.addHeaderView(R.layout.header_view); //添加headerView，需要设置父类为mLRecyclerView View headerView = LayoutInflater.from(this).inflate(R.layout.header_view, mLRecyclerView, false); mLRecyclerView.addHeaderView(headerView); //得到所有headerView视图。 List getHeaderViews(); //得到所有headerView的个数。 int getHeaderViewCount(); 7、设置下拉刷新进度条的颜色和字体的颜色 //改变下方加载进度的字体颜色 mLRecyclerView.setLoadingTextColor(Color.BLUE); //改变下方加载进度条的颜色 mLRecyclerView.setLoadingProgressColor(Color.BLUE); //修改下拉刷新颜色 mLRecyclerView.setRefreshColor(getResources().getColor(R.color.colorAccent)); 8、设置监听事件 //设置点击事件，注意此处返回的position是不包括headerView和不包括下拉加载的视图的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(int position) { //position为数据的位置 Log.i(TAG,\"点击--->\"+position); } @Override public void onItemLongClick(int position) { Log.i(TAG,\"长按--->\"+position); } }); 9、设置上拉加载和下拉刷新在不同的状态 @Override public void onLoadMore() { //设置处于正在加载状态 mLRecyclerView.setLoading(); new Handler().postDelayed(new Runnable() { @Override public void run() { int count = dataAdapter.getItemCount() + 1; if (count strings = new ArrayList<>(); for (int i = count - 1; i @Override public void onRefresh() { mLRecyclerView.setRefreshEnable(true); new Handler().postDelayed(new Runnable() { @Override public void run() { dataAdapter.clearAll(); List strings = new ArrayList<>(); for (int i = 0; i 10、设置是否空白视图和错误视图点击刷新 mLRecyclerView.setOnClickEmptyOrErrorToRefresh(true); 11、可设置下拉刷新和上拉加载的背景图片(可用于广告的放置哦) 注意: 如果在初始化的时候 直接设置了背景图片可不用刷新adapter。 如果通过网络获取到背景图片之后可以使用如下方法设置背景，但是需要添加一步：notifyItemChanged() //设置下拉刷新的背景图片（可放广告图片哦） mLRecyclerView.setRefreshBackground(getResources().getDrawable(R.drawable.headerback)); //设置上拉加载部分设置背景图片（也可放广告哦） mLRecyclerView.setFooterBackground(getResources().getDrawable(R.drawable.footerback)); //如果通过网络获取的footer图片，则需要调用以下：（如果是设置刷新部分的背景直接调用setRefreshBackground） mLRecyclerView.getOriginalRecyclerView().getAdapter() .notifyItemChanged(mLRecyclerView.getOriginalRecyclerView().getAdapter().getItemCount() - 1); 12、 局部刷新 注意：使用局部刷新时要加上offset /* * 关于position: * 1、在自定义Adapter的时候 position是自己定义的数据0-length-1 * * * */ //设置点击事件，注意此处返回的position是不包括headerView 不包括下拉刷新的 mLRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //此处返回的position为数据的position，不包括 添加的头部和下拉刷新 Log.i(TAG, \"点击--->\" + position); //在进行局部刷新的时候 一定要记得加上offsetcount,偏移量；使用局部刷新记得notifyItemChanged第二个参数不要为空 dataAdapter.notifyItemChanged(position+mLRecyclerView.getOffsetCount(), \">>>>>>刷新\"); } @Override public void onItemLongClick(View view, int position) { TextView textView = (TextView) view.findViewById(R.id.item); textView.setText(\"长按\" + position); Log.i(TAG, \"长按--->\" + position); } }); 二、如何实现分组 1、luckRecyclerView.setRecyclerViewType(LucklyRecyclerView.GROUP); 2、重写Adapter继承基类BaseGroupAdapter 需要重写的几个方法： /** * 第一层的数量 * * @return */ public abstract int getParentCount(); /** * 每一个parent下的child的数量 * * @param parentPosition * @return */ public abstract int getChildCountForParent(int parentPosition); public abstract A onCreateParentViewHolder(ViewGroup parent, int viewType); public abstract B onCreateChildViewHolder(ViewGroup parent, int viewType); public abstract void onBindParentViewHolder(A holder, int position); /** * 分别是hoder,parent的位置（全局的位置） * child在parent中的index(不是position) * * @param holder * @param parentPosition * @param childIndexForParent */ public abstract void onBindChildViewHolder(B holder, int parentPosition, int childIndexForParent); 在使用点击事件的时候要注意判断是否为Parent： luckRecyclerView.setOnItemClickListener(new LucklyRecyclerView.OnItemClickListener() { @Override public void onItemClick(View rootView, int position) { if (mGroupAdapter.isParentView(position)){ mGroupAdapter.showChild(rootView); }else { Toast.makeText(getApplicationContext(),\"点击了第\"+mGroupAdapter.getParentIndexFromChild(position)+\"个parent的\"+mGroupAdapter.getChildIndexForParent(position),Toast.LENGTH_SHORT).show(); } } @Override public void onItemLongClick(View rootView, int position) { } }); 3、常用的几个方法 1、获取child在parent下的index mGroupAdapter.getChildIndexForParent(position); 2、获取parent的index mGroupAdapter.getParentIndexFromChild(position); 3、判断当前position是否为parentView mGroupAdapter.isParentView(position); 三、具体如何使用请看例子 LucklyRecyclerView 欢迎关注我的微信公众号： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/open/luckly_popup_window.html":{"url":"article/open/luckly_popup_window.html","title":"2. luckly_popup_window","keywords":"","body":"引用包 常用的方法1、添加数据2、设置LucklyPopupWindow的宽度（必须设置）3、给每一个Item添加分割线4、设置背景颜色5、设置PopupWindow显示时Activity其余部分显示灰色程度6、设置字体的颜色和大小7、设置图片不显示以及设置图片大小8、添加监听事件9、设置箭头的宽,高,圆角矩形的半径10、在某个View下/上显示（自动判断上下）11、模仿ios底部弹窗LucklyPopouWindow的使用方法。 简介：Android开发使用PupopWindow在指定View的上下左右动态显示菜单列表，模仿IOS底部弹窗列表。 欢迎大家Star&#x1F62F; Github地址 PupopWindow动态获取显示的位置，并添加指示箭头 效果图 目录: 1、添加数据 2、设置LucklyPopupWindow的宽度（必须设置） 3、给每一个Item添加分割线 4、设置背景颜色 5、设置PopupWindow显示时Activity其余部分显示灰色程度 6、设置字体的颜色和大小 7、设置图片不显示以及设置图片大小 8、添加监听事件 9、设置箭头的宽,高,圆角矩形的半径 10、在某个View下/上显示（自动判断上下） 11、模仿ios底部弹窗 引用包 Step 1.在根 build.gradle中添加如下依赖 allprojects { repositories { ... maven { url 'https://jitpack.io' } } } Step 2. 在build.gradle中添加如下依赖 dependencies { compile 'com.github.mrgaogang:luckly_popup_window:v1.4.1' } 常用的方法 1、添加数据 添加数据的时候，内容和图片的个数应该相同；如果不需要添加图片的话，那么使用第一个和第四个方法，传递的Bitmap=null即可。 void setData(DataBeans[] strings); void setData(String[] data, int[] images); void setData(String[] data, Bitmap[] images); void setData(List list); 2、设置LucklyPopupWindow的宽度（必须设置） LucklyPopupWindow的宽度（必须设置);设置的单位是dp。 void setWidth(int widthDp); 3、给每一个Item添加分割线 默认的情况是没有分割线的。需要调用以下方法。 //可以自己添加RecyclerView的分割线 addItemDecoration(RecyclerView.ItemDecoration itemDecoration); //使用内部封装好了的分割线，传入的参数分别是：方向，颜色，分割线的宽 addItemDecoration(int oritation, int color, int lineHeight); 4、设置背景颜色 也就是设置三角形和矩形框的背景颜色 setBackgroundColor(int backgroundColor); 5、设置PopupWindow显示时Activity其余部分显示灰色程度 取值范围0.0 setDarkBackgroundDegree(float darkBackgroundDegree); 6、设置字体的颜色和大小 setTextColor(int textColor); setTextSize(int textSize)； 7、设置图片不显示以及设置图片大小 setImageDisable(boolean imageDisable); setImageSize(int widthDp,int heightDp); 8、添加监听事件 void setOnItemClickListener(LucklyPopopWindow.OnItemClickListener onItemClickListener); 9、设置箭头的宽,高,圆角矩形的半径 void setTriangleWidth(int triangleWidth); void setTrianleHeight(int trianleHeight); void setRadius(int radius); 10、在某个View下/上显示（自动判断上下） 注意：这个方法必须最后调用。 void showAtLocation(View parentView, View positionView); 11、模仿ios底部弹窗 mLucklyPopopWindow.showInBottom(getWindow().getDecorView()); LucklyPopouWindow的使用方法。 请见: https://github.com/MrGaoGang/luckly_popup_window 欢迎Star mLucklyPopopWindow = new LucklyPopopWindow(this); //给popupWindow添加数据 mLucklyPopopWindow.setData(getResources().getStringArray(R.array.popupArray), new int[]{R.mipmap.add, R.mipmap.delete, R.mipmap.modify, R.mipmap.update}); mAdapter.setOnItemClickListener(new RecyclerAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { //必须设置宽度 mLucklyPopopWindow.setWidth(150); //监听事件 mLucklyPopopWindow.setOnItemClickListener(new LucklyPopopWindow.OnItemClickListener() { @Override public void onItemClick(int position) { Toast.makeText(MainActivity.this, \"点击的位置\" + position, Toast.LENGTH_SHORT).show(); mLucklyPopopWindow.dismiss(); } }); //添加分割线(可选) mLucklyPopopWindow.addItemDecoration(LucklyPopopWindow.VERTICAL,Color.GRAY,1); //设置image不显示(可选) // mLucklyPopopWindow.setImageDisable(true); //设置image的大小(可选) mLucklyPopopWindow.setImageSize(20,20); //显示popopWindow mLucklyPopopWindow.showAtLocation(getWindow().getDecorView(), view); } }); Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/open/vue_template.html":{"url":"article/open/vue_template.html","title":"3. Vue+iView开发基础包","keywords":"","body":"如何使用此lucky_vue_template模板？目录结构 简介:由Vue2.0+Webpack4.0+iView3.0+Vuex+Router搭建的Vue开发模板 如何使用此lucky_vue_template模板？ Github地址(lucky_vue_template) $ npm install -g vue-cli $ vue init mrgaogang/lucky_vue_template my-project $ cd my-project $ npm install $ npm run dev 此脚手架配套vscode插件: 查看插件 项目地址:https://github.com/MrGaoGang/lucky_vue_template 目录结构 |-- lucky_vue |-- babel.config.js//babel配置 |-- index.css//全局css样式 |-- index.html |-- package-lock.json |-- package.json |-- webpack.base.config.js//webpack打包基础配置 |-- webpack.dev.config.js//本地环境打包配置 |-- webpack.prod.config.js//生产打包配置 |-- dist//打包生产目录 | |-- index.html | |-- css | |-- fonts | |-- img | |-- js |-- src |-- App.vue |-- main.js//单页面入口 |-- modules.js |-- components//子组件 | |-- Home.vue |-- plugins//一些插件 | |-- iview.js |-- router//页面路由统一配置 | |-- index.js |-- server//所有服务请求 | |-- fetch.js//封装的网络请求 | |-- index.js | |-- api | | |-- index.js//一些api常量 | |-- modules//请求模块化 | |-- home.js |-- store//状态管理 |-- index.js |-- modules//状态管理模块化 |-- home.js Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/":{"url":"article/oview/","title":"1. 快速开始","keywords":"","body":"NPM安装oView特性 oView Vue.js移动端图表库 oView是基于 蚂蚁金服F2图表库的二次封装，以便于Vue.js开发者在移动端和PC端更好进行图表的展示。 NPM安装 npm install oview --save 推荐使用npm安装，享受安装依赖包带来的便利，同时也建议使用个人开发Vue项目使用的 Vue SPA 模板;当然Vue官方提供的cli模板固然优秀，但是由于加重了学习成本，所以对有webpack开发经验的同学使用此模板，可尽快入手。 oView特性 1、oview支持哪些图？ 目前oview支持：柱状图，饼状图，面积图，散点图，气泡图，面积图，折线图 ，雷达图，自定义图 2、图表配置简单 如果您只需要，配置简单的图形，只需要传递数据，和坐标轴即可。 oview图表色彩鲜艳 色彩主要使用F2官方建议色彩，如需自定义色彩可使用:color=\"yourColors\"传入即可。（后续会详细讲解） Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/Chart.html":{"url":"article/oview/Chart.html","title":"2. 图表Chart","keywords":"","body":"1、oview如何开发一个图表？2、o-chart各个字段介绍data（数据源）col-defs (数据源字段配置)custom-render（自定义渲染图表）legend (图例)tooltip (提示信息)chart-config (图表配置)width/heightbackgroundColorscale 在开发之前，我想您应该知道关于图表的一些简单概念。一般情况下，F2 的图表包含坐标轴（Axis）、几何标记（Geometry）、提示信息（Tooltip）、图例（Legend）等。Axis,Tooltip,Legend等术语作用请见：官方文档 1、oview如何开发一个图表？ 其中由o-chart和o-line/o-pie/等组成。 一个o-chart有且只能有一个图表子节点 2、o-chart各个字段介绍 希望您能静下心来，花5分钟时间简单了解一下，o-chart各个字段的作用。o-chart主要作用是配置图表的公用属性,抽离不同图形公用方法，并根据类型不同，而渲染不同图形。 data（数据源） 是否必须:True 参数类型:Array 描述:图表的数据源 默认：[] col-defs (数据源字段配置) 是否必须:False 参数类型:Object 描述:对上述提供的数据源中每个字段进行配置 默认：{} 一个示例: //以折线图为例 //data部分 normaColConfig: { //对每个字段配置 //正常的折线图每一个字段的配置 value: { tickCount: 5, //坐标点的个数 min: 0 }, date: { type: \"timeCat\", //时间类型 range: [0, 1], tickCount: 3 //坐标点的个数 } }, 详细配置说明 custom-render（自定义渲染图表） 是否必须:False 参数类型:枚举，null, \"prevent\", \"extra\" 选项中的某个 描述:是否自定义渲染图表。 null:不自定义渲染 prevent:完全阻止组件渲染，完全由自己在回调方法中：灌数据，渲染图表等等(一般情况不建议使用此选项); extra: 自己在iview渲染的图表基础上，添加自定义操作。（建议使用此选项） 默认：null 说明：如果 custom-render为prevent或者extra则需要在o-chart部分添加@on-render监听。示例请见：雷达图示例 //onRender的入参为 onRender({ chart }) { } legend (图例) 是否必须:False 参数类型:Object 描述:图例 默认：{disable:true,fieldName:x轴} 说明: 图例分为两个部分 数据字段名称，配置信息, { fieldName:\"\",//数据字段的名称，默认是以X轴显示图例 disable:true,//是否显示图例，如果设置为true，则图例不可显示，若此字段不提供或者为false，则显示图例 ...其他参数 } 其他参数: 图例的配置信息，支持的属性如下： position: String 设置图例的显示位置，可设置的值为：'top'、'right'、'bottom'、'left'，分别表示上、右、下、左。默认为 top。 align: String 当 position 为 'top'，'bottom' 时生效，用于设置水平方向上图例的对齐方式，可设置的值为：'left'、'center'、'right' ，默认为 'left' ，左对齐。 left（默认） center right verticalAlign: String 当 position 为 'left'、'right' 时生效，用于设置垂直方向上图例的对齐方式，可设置的值为：'top'、'middle'、'bottom'，默认为 'middle'，居中对齐。 middle（默认） top bottom itemWidth: Number/'auto' 用于设置每个图例项的宽度，默认为 'auto'，即使用 F2 默认的图例布局计算 itemWidth。如果 itemWidth 为 null，则会根据每个图例项自身的宽度计算，另外用户也可以自己设置 itemWidth 的数值。 showTitle: Boolean 是否显示图例标题，默认值为 false，即不展示。 titleStyle: Object 图例标题的显示样式设置，详见绘图属性。 titleStyle: { textAlign: 'center', // 文本对齐方向，可取值为： start middle end fill: '#404040', // 文本的颜色 fontSize: 12, // 文本大小 fontWeight: 'bold', // 文本粗细 textBaseline: 'top' // 文本基准线，可取 top middle bottom，默认为middle } offsetX: Number 图例 x 方向的整体偏移值，数值类型，数值单位为 'px'，默认值为 0。 offsetY: Number 图例 Y 方向的整体偏移值，数值类型，数值单位为 'px'，默认值为 0。 titleGap: Number 其他详细配置请见:Legend配置 tooltip (提示信息) 是否必须:False 参数类型:Object 描述:提示信息 默认：{disable:true} 说明: 下面列出常用的tooltip配置，在某些情况需要获取到chart实例来进行操作的话，请使用自定义render:custom-render='extra'。tooltip自定义实例 和 tooltip普通使用实例 { disable:true,//是否显示提示信息，如果设置为true，则提示信息不可显示，若此字段不提供或者为false，则显示提示信息 // 其他配置信息 alwaysShow: false, // 当移出触发区域，是否仍显示提示框内容，默认为 false，移出触发区域 tooltip 消失，设置为 true 可以保证一直显示提示框内容 offsetX: 0, // x 方向的偏移 offsetY: 0, // y 方向的偏移 triggerOn: [ 'touchstart', 'touchmove' ], // tooltip 出现的触发行为，可自定义，用法同 legend 的 triggerOn triggerOff: 'touchend', // 消失的触发行为，可自定义 showTitle: false, // 是否展示标题，默认不展示 showCrosshairs: false, // 是否显示辅助线，点图、路径图、线图、面积图默认展示 crosshairsStyle: { stroke: 'rgba(0, 0, 0, 0.25)', lineWidth: 2 }, // 配置辅助线的样式 showTooltipMarker: true, // 是否显示 tooltipMarker tooltipMarkerStyle: { fill: '#fff' // 设置 tooltipMarker 的样式 }, background: { radius: 2, fill: '#1890FF', padding: [ 6, 10 ] }, // tooltip 内容框的背景样式 titleStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'top' }, // tooltip 标题的文本样式配置，showTitle 为 false 时不生效 nameStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'middle' }, // tooltip name 项的文本样式配置 valueStyle: { fontSize: 24, fill: '#fff', textAlign: 'start', textBaseline: 'middle' }, // tooltip value 项的文本样式配置 showItemMarker: true, // 是否展示每条记录项前面的 marker itemMarkerStyle: { radius: 7, symbol: 'circle', lineWidth: 2, stroke: '#fff' }, // 每条记录项前面的 marker 的样式配置 custom: {Boolean}, // 是否自定义 tooltip 提示框 onShow(obj) { // obj: { x, y, title, items } }, // tooltip 显示时的回调函数 onHide(obj) { // obj: { x, y, title, items } }, // tooltip 隐藏时的回调函数 onChange(obj) { // obj: { x, y, title, items } }, // tooltip 内容发生改变时的回调函数 crosshairsType: {String}, // 辅助线的种类 showXTip: {Boolean}, // 是否展示 X 轴的辅助信息 showYTip: {Boolean}, // 是否展示 Y 轴的辅助信息 xTip: {Object}/{Function}, // X 轴辅助信息的文本样式 yTip: {Object}/{Function, // Y 轴辅助信息的文本样式 xTipBackground: {Object}, // X 轴辅助信息的背景框样式 yTipBackground: {Object}, // Y 轴辅助信息的背景框样式 snap: {Boolean} // 是否将辅助线准确定位至数据点 } chart-config (图表配置) 是否必须:False 参数类型:Object 描述:图表样式的配置，比如给图表添加内外边距(padding: [ 0, 10, 40, 100 ] // 分别设置上、右、下、左边距)，给画布添加边距:appendPadding。所以chart-config应该为:{padding:[ 0, 10, 40, 100 ],appendPadding:[20,10,30,12]} 默认：{} width/height 是否必须:False 参数类型:Integer 描述:图表的宽度和高度 默认：图表宽度，默认为:屏幕宽度；图表高度，默认为:300 backgroundColor 是否必须:False 参数类型:String 描述:图表背景颜色 默认：#ffffff (白色) scale 是否必须:False 参数类型:Object 描述:度量 Scale，是数据空间到图形空间的转换桥梁，负责原始数据到 [0, 1] 区间数值的相互转换工作。针对不同的数据类型对应不同类型的度量。 默认：{} 说明：示例请见面积图 文档详情说明 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart_specific.html":{"url":"article/oview/chart_specific.html","title":"3. 图表构建","keywords":"","body":"position (坐标轴)adjust(数据调整)axis (多个坐标轴具体配置)colors (颜色)colorFieldanimate (动画)chartStyle（图表样式）size（数据图形大小）此文内容：各类图表公用配置属性 阅读此文，大概需要5分钟。相信您已经知晓构建一个图表的基础步骤： 上一篇文章讲述了o-chart的配置，如果您没有查阅图表Chart，请先移步查看。这边文章主要讲述各个图表具体实现配置。目前oview支持的所有图表类型有： 饼状图 柱状图 折线图 雷达图 散点图和气泡图 面积图 下面将对，各类图表公用配置属性进行简单介绍，主要包括:position(坐标轴) , axis(多个坐标轴具体配置) , colors(颜色) , animate(动画),chartStyle(图表样式）, size（数据图形大小） position (坐标轴) 是否必须:True 参数类型:String 说明: 配置x,y坐标轴，示例:position=\"date*value\"，其中date为x轴,value为y轴。饼状图较为特殊，需传position=\"name*percent\"名字和百分比，其中percent为数据结构中必有字段 示例: adjust(数据调整) 是否必须:False 参数类型:Object 默认值:{type:'stack'} 说明:声明几何标记对象的数据调整方式，可用于绘制层叠图、分组图等。支持单一的数据调整方式也支持各种数据调整方式的组合。支持的调整类型包括：'stack', 'dodge' axis (多个坐标轴具体配置) 是否必须:False 参数类型:Array 注意：如使用axis，请必须上fieldName配置项,表示对某个坐标轴的具体配置 说明: 多单个或者多个坐标轴，镜像详细配置,配置坐标轴的文本(label)，轴线(line)，刻度线(tickLine)，网格线(grid)。详细配置文档 示例: //以雷达图具体配置（此例子对两个坐标轴的文本和网格线进行配置） normaAxis: [ { fieldName: \"score\",//注意fieldName为必传项，表示对某个坐标轴的具体配置 label: function label(text, index, total) { if (index === total - 1) { return null; } return { top: true }; }, grid: { lineDash: null, type: \"arc\" // 弧线网格 } }, { fieldName: \"item\", grid: { lineDash: null } } ], colors (颜色) 是否必须:False 参数类型:Array 说明: 默认值为[\"#1890FF\",\"#13C2C2\",\"#2FC25B\",\"#FACC14\",\"#F04864\",\"#8543E0\"]，如需要图表显示为单个颜色，请传入一个值即可 colorField 是否必须:False 参数类型:String 说明: 为哪个坐标轴设置颜色 animate (动画) 是否必须:False 参数类型:Object 说明:给x，y轴设置动画。详细文档 //data部分 animate: { //可以配置动效哦 appear: { animation: \"groupWaveIn\", delay: 500 //延迟500s } }, chartStyle（图表样式） 是否必须:False 参数类型:Object 说明: 为图表设置样式。 示例: size（数据图形大小） 是否必须:False 参数类型:Object 说明:常用于散点图、气泡图。 将数据值映射到图形的大小上的方法。详细文档 注意：fieldName字段为必传项，表示对那个坐标轴的配置。且 不同图形的 size 的含义有所差别： point 图形的 size 影响点的半径大小； line, area, path 中的 size 影响线的粗细； interval 的 size 影响柱状图的宽度。 此处暂时只支持，回调的方式。 示例: { fieldName: \"z\",// callback: function(z) { return [10, 40]; } } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/pie.html":{"url":"article/oview/chart/pie.html","title":"饼状图","keywords":"","body":"一、 饼状图基础构建二、饼状图额外配置coord (坐标系)pieLabel(绘制饼图文本) 饼状图扫码预览 一、 饼状图基础构建 公用配置信息 没错构建一个饼状图就是如此简单，必须提供的数据有:data和position。 如果您需要显示提示信息/图例那么就需要配置:tooltip和:legend。 data的数据结构为:[{name:\"item\",percent:0.3},{name:\"item2\",percent:0.7}] 样例源码 说明: 坐标轴percent为必传项。 公用配置信息已在前文提及，请查阅 二、饼状图额外配置 coord (坐标系) 是否必须:False 参数类型:Object 描述:坐标系 默认：{ coordType: \"polar\",options: {transposed: true // 坐标系翻转}} 说明: 图例分为两个部分 数据字段名称，配置信息, coordType：有两种类型，1：笛卡尔坐标系(rect)；2：极坐标系（polar） options为配置信息，不同的坐标系配置不同。 直角坐标系 属性名 类型 解释 start Object 坐标系的起始点，F2 图表的坐标系原点位于左下角。 end Object 坐标系右上角的画布坐标。 transposed Boolean 是否发生转置，true 表示发生了转置。 isRect Boolean 是否是直角坐标系，直角坐标系下为 true。 极坐标系 属性名 类型 解释 startAngle Number 极坐标的起始角度，弧度制。 endAngle Number 极坐标的结束角度，弧度制。 innerRadius Number 绘制环图时，设置内部空心半径，相对值，0 至 1 范围。 radius Number 设置圆的半径，相对值，0 至 1 范围。 isPolar Boolean 判断是否是极坐标，极坐标下为 true。 transposed Boolean 是否发生转置，true 表示发生了转置。 center Object 极坐标的圆心所在的画布坐标。 circleRadius Number 极坐标的半径值。 pieLabel(绘制饼图文本) 是否必须:False 参数类型:Object 描述:PieLabel 是一个用于绘制饼图文本的插件。详细文档 示例: { sidePadding: 30, activeShape: true, label1: function(data) { //第一个标签 return { text: data.name, fill: \"#343434\", fontWeight: \"bold\" }; }, label2: function(data) { //第二个标签 //如果不需要刻意删除label2 return { text: data.percent * 100 + \"%\", fill: \"#999\" }; }, onClick: function(ev) { //点击之后显示 var data = ev.data; if (data) { ev.chart.guide().clear(); ev.chart.guide().html({ position: [\"50%\", \"50%\"], html: '\\n ' + data.name + '\\n ' + data.percent * 100 + \"%\\n \" }); ev.chart.repaint(); // $('#title').text(data.type); // $('#money').text(data.money); } } }; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/histo.html":{"url":"article/oview/chart/histo.html","title":"柱状图","keywords":"","body":"一、 柱状图基础构建二、柱状图额外配置coord (坐标系) 柱状图扫码预览 一、 柱状图基础构建 普通的柱状图 构建柱状图，必须提供的数据有:data和position。 如果您需要显示提示信息/图例那么就需要配置:tooltip和:legend。 data的数据结构为:[[{ year: \"1951 年\", sales: 38 }, { year: \"1952 年\", sales: 52 }] 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的柱状图，分组柱状图，层叠柱状图，区间柱状图，基础条形图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请查阅样例源码 ，查看具体配置,具体配置信息和作用已在前文和样例中注明，请查阅。 二、柱状图额外配置 公用配置信息 coord (坐标系) 是否必须:False 参数类型:Object 描述:坐标系 默认：{ coordType: \"rect\",options: {transposed: false // 坐标系不翻转}}，默认使用极坐标系的方式 说明: 图例分为两个部分 数据字段名称，配置信息, coordType：有两种类型，1：笛卡尔坐标系(rect)；2：极坐标系（polar） options为配置信息，不同的坐标系配置不同。 直角坐标系 属性名 类型 解释 start Object 坐标系的起始点，F2 图表的坐标系原点位于左下角。 end Object 坐标系右上角的画布坐标。 transposed Boolean 是否发生转置，true 表示发生了转置。 isRect Boolean 是否是直角坐标系，直角坐标系下为 true。 极坐标系 属性名 类型 解释 startAngle Number 极坐标的起始角度，弧度制。 endAngle Number 极坐标的结束角度，弧度制。 innerRadius Number 绘制环图时，设置内部空心半径，相对值，0 至 1 范围。 radius Number 设置圆的半径，相对值，0 至 1 范围。 isPolar Boolean 判断是否是极坐标，极坐标下为 true。 transposed Boolean 是否发生转置，true 表示发生了转置。 center Object 极坐标的圆心所在的画布坐标。 circleRadius Number 极坐标的半径值。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/line.html":{"url":"article/oview/chart/line.html","title":"折线图","keywords":"","body":"一、 折线图基础构建二、折线图额外配置type (显示类型)shape (线段形状)showNulls(是否显示空值)isMutiLine（是否存在多条线段）isArea (区域面积图的配置) 折线图扫码预览 一、 折线图基础构建 光滑的的折线图 这是一个光滑折线图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置，tooltip:显示提示信息, axis:坐标系配置, shape:设置线段类型，shape可选为'line', 'smooth', 'dash' 具体配置，请见下文 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的折线图，光滑的的折线图，带点的折线图，光滑的带点折线图，层叠的带点光滑折线图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请查阅样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、折线图额外配置 公用配置信息 type (显示类型) 是否必须:False 参数类型:枚举['line','point']中的二选一 默认：line 说明:显示类型，以线段显示还是使用带点折线图显示 shape (线段形状) 是否必须:False 参数类型:见下 默认:line 说明:只支持接收一个参数，指定几何图像对象绘制的形状。根据上述设置的type不同，可以设置不同的shape形状 (type)类型 shape 类型 解释 point 'circle', 'hollowCircle', 'rect' 默认为 'circle' line 'line', 'smooth', 'dash' dash：虚线，smooth： 平滑线 showNulls(是否显示空值) 是否必须:False 参数类型:Boolean 默认：False 说明:是否显示空值，如果为True，则折线图遇到空值，则是不连续线段。 isMutiLine（是否存在多条线段） 是否必须:False 参数类型:Boolean 默认：False 说明:是否存在多条线段，如果为True，则是则会显示多条线段，demo请见区域面积图-层叠面积图。 isArea (区域面积图的配置) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示区域面积图 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/radar.html":{"url":"article/oview/chart/radar.html","title":"雷达图","keywords":"","body":"一、 雷达图基础构建二、雷达图额外配置isArea (以区域方式显示)customDefine (是否自定义显示) 雷达图扫码预览 一、 雷达图基础构建 普通的雷达图 这是一个光滑雷达图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置，legend:显示图例, axis:坐标系配置, color-field:对数据中的那个字段显示颜色 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有普通的雷达图，雷达面积图，自定义图标-雷达图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请看样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、雷达图额外配置 公用配置信息 isArea (以区域方式显示) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示为雷达面积图。 customDefine (是否自定义显示) 是否必须:False 参数类型:Boolean 默认：False 说明:是否自定义显示各个图表的logo. Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/point.html":{"url":"article/oview/chart/point.html","title":"散点图和气泡图","keywords":"","body":"一、 散点图基础构建二、散点图额外配置shape(散点图的形状) 散点图扫码预览 一、 散点图基础构建 散点图 这是一个光滑散点图的案例，其中包括的配置项， 必须有的是data和position; col-defs：对提供的每个数据进行配置， legend:显示图例, axis:坐标系配置, color-field:对数据中的那个字段显示颜色 说明: 坐标轴position为必传项。 公用配置信息已在前文提及，请查阅 样例中有散点图和气泡图其不同之处在于对每一项的配置不同而已，如您需要实现其中的某一部分请看样例源码 ，查看具体配置,具体配置信息和作用已在前文和下文中注明，请查阅。 二、散点图额外配置 公用配置信息 shape(散点图的形状) 是否必须:False 参数类型:枚举 ['circle', 'hollowCircle', 'rect' ] 中的一个 默认:circle 说明:只支持接收一个参数，指定几何图像对象绘制的形状 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/oview/chart/area.html":{"url":"article/oview/chart/area.html","title":"面积图","keywords":"","body":"isMutiLine（是否存在多条线段）isArea (区域面积图的配置) 区域面积图扫码预览 如果您仔细查看了，区域面积图和折线图，您会发现，二者其实并无巨大差异，区域面积图是基于折线图进行的改造。主要额外使用到了以下两个属性: isMutiLine（是否存在多条线段） 是否必须:False 参数类型:Boolean 默认：False 说明:是否存在多条线段，如果为True，则是则会显示多条线段，demo请见区域面积图-层叠面积图。 isArea (区域面积图的配置) 是否必须:False 参数类型:Boolean 默认：False 说明:是否以区域方式显示，如果为True则显示区域面积图 所以，详细配置请见折线图 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/":{"url":"article/vue/","title":"一、Vue","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue父组件使用scoped无法修改子组件样式.html":{"url":"article/vue/Vue父组件使用scoped无法修改子组件样式.html","title":"1. Vue父组件使用scoped无法修改子组件样式","keywords":"","body":"1、部分全局方法2、深选择器 在Vue开发中我们难免会引用各种组件和样式；有时候样式不符合业务需求；则需要对指定的dom进行样式的修改；如果我们在vue中使用了scoped， 则无法在父组件中修改子组件的样式。下面介绍几种修改样式的方法 1、部分全局方法 /**在全局样式中修改要覆盖的样式**/ /**本地样式**/ 2、深选择器 .parentclass >>> .childClass{ } /**或者使用**/ .parentclass /deep/ .childClass{ } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue使用render函数渲染组件.html":{"url":"article/vue/Vue使用render函数渲染组件.html","title":"2. Vue使用render函数渲染组件","keywords":"","body":"一、Render 函数参数详解二、样例：如何给表格组件添加表头筛选此文源码案例:欢迎Star 目录 一、Render 函数参数详解 二、样例：如何给表格组件添加表头筛选 Vue 组件的开发有几种方式：单文件组件，使用 render 函数渲染，使用 template。 在大多数的情况下，Vue 可以使用单文件/template 的方式来创建页面；然而在有一些情况我们需要使用 JavaScript 的编程能力，比如使用第三方框架时，想要自定义某个功能；这个时候就可以使用到 render 函数。 本文将使用 iView table 为例，通过 render 函数添加可搜索的表头筛选。 一、Render 函数参数详解 //一个简单的例子：渲染一个p标签，内容为 '我是p标签的内容' new Vue({ render: createElement => createElement(\"p\", \"我是p标签的内容\") }); 其实 createElement()还有更强大的参数: // @returns {VNode} createElement( // {String | Object | Function} // 一个 HTML 标签字符串，组件选项对象，或者 // 解析上述任何一种的一个 async 异步函数。必需参数。 \"div\", // {Object} // 一个包含模板相关属性的数据对象, // 你可以在 template 中使用这些特性。可选参数。 { // (详情见下一节) }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [ \"先写一些文字\", createElement(\"h1\", \"一则头条\"), createElement(MyComponent, { props: { someProp: \"foobar\" } }) ] ); createElement(obj,{},[]) 参数详解: 第一个参数为渲染成哪个节点，接受 String,Object,Function 三种类型； 如果是 String,比如是 div，那么表示此标签将会渲染成 div 标签；String 渲染成普通的 html 标签 如果是 Object，比如是一个 Vue 的组件:TableFilter，那么表示此标签将会渲染一个组件。通常我们在单文件组件中使用的时候是 import {Table} from \"iview\";然后在 template 中引用此标签；而使用 render 则需要使用 createElement 方式创建一个。 如果是 Function，则可以根据自己的业务逻辑动态觉得是渲染成普通的 html 标签还是 Vue 组件。 2) 第二个参数接受 一个对象{}类型的数据。其主要作用类似于组件中对某一个节点设置各种 bind 属性：设置样式 style，设置事件 on，设置类 class，设置自定义的命令，设置普通的 html 属性，设置传递参数 props 等等。 有一点要注意：正如在模板语法中，v-bind:class 和 v-bind:style，会被特别对待一样，在 VNode 数据对象中，下列属性名是级别最高的字段。该对象也允许你绑定普通的 HTML 特性，就像 DOM 属性一样，比如 innerHTML (这会取代 v-html 指令)。 { // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: { color: 'red', fontSize: '14px' }, // 普通的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on`，当子组件使用$emit()方式发生，使用on接收 // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // 作用域插槽格式 // { name: props => VNode | Array } scopedSlots: { default: props => createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true } 你会发现使用 render 函数没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：比如 props: ['value'], render: function (createElement) { var self = this return createElement('input', { domProps: { value: self.value }, on: { input: function (event) { self.$emit('input', event.target.value) } } }) } 第三个参数为列表类型的数据，表示当前渲染组件的有哪些子组件。 render(createElement=> return createElement( 'div', { }, // {String | Array} // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成， // 也可以使用字符串来生成“文本虚拟节点”。可选参数。 [// '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, { props: { someProp: 'foobar' } }) ] )) 注意：子组件中的每一项（VNodes）都必须是唯一的;意味着，下面的 render function 是无效的： render: function (createElement) { var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ]) } 二、样例：如何给表格组件添加表头筛选 效果图: iview的默认table组件不支持 表头输入框筛选，官方地址 此处默认您有了一定的vue开发基础。 套用iview官方的例子： //显示表格的例子 import { Table ,Button,Icon,Modal} from \"iview\"; import Vue from \"vue\"; export default { components: { Table }, data() { return { columns7: [ { title: \"Name\", key: \"name\", //使用render函数自定义列显示效果：文本加粗 render: (h, params) => { return h(\"div\", [//使用render渲染一个div标签 h(Icon, {//使用render渲染一个iview的组件 props: {//传递参数 type: \"person\" } }), h(\"strong\", params.row.name)//文字加粗 ]); } }, { title: \"Age\", key: \"age\" }, { title: \"Address\", key: \"address\" }, { title: \"Action\", key: \"action\", width: 150, align: \"center\", render: (h, params) => { return h(\"div\", [//渲染一个div标签 h( Button,//在div标签下渲染一个iview组件 { props: {//传递参数 type: \"primary\", size: \"small\" }, style: {//设置样式 marginRight: \"5px\" }, on: {//监听$emit事件 click: () => { this.show(params.index); } } }, \"View\" ), h( Button, { props: { type: \"error\", size: \"small\" }, on: { click: () => { this.remove(params.index); } } }, \"Delete\" ) ]); } } ], data6: [ { name: \"John Brown\", age: 18, address: \"New York No. 1 Lake Park\" }, { name: \"Jim Green\", age: 24, address: \"London No. 1 Lake Park\" }, { name: \"Joe Black\", age: 30, address: \"Sydney No. 1 Lake Park\" }, { name: \"Jon Snow\", age: 26, address: \"Ottawa No. 2 Lake Park\" } ] }; }, methods: { show(index) { this.$Modal.info({ title: \"User Info\", content: `Name：${this.data6[index].name}Age：${ this.data6[index].age }Address：${this.data6[index].address}` }); }, remove(index) { this.data6.splice(index, 1); } }, mounted(){ //modal注入 Vue.prototype.$Modal=Modal; } }; 由于table组件表头筛选不支持输入框筛选，那么我们就必须的自己绘制。 思路如下： 找到表头所在的节点 在表头节点后添加一个自定义筛选的div节点； 使用render函数渲染一个下拉输入的单文件组件 mounted(){ //modal注入 Vue.prototype.$Modal=Modal; //等dom元素渲染完成之后渲染筛选 this.$nextTick(()=>{ this.renderHeaderFilter(); }) } methods:{ //添加头部筛选 renderHeaderFilter(){ let allHeader =document.querySelectorAll(\".ivu-table-header .ivu-table-cell\"); console.log(allHeader); allHeader.forEach((element)=>{ let createNew=document.createElement(\"div\"); createNew.classList.add(\"vue-header-filter\"); element.appendChild(createNew); new Vue({ render(h){ return h(TableHeaderFilter,{ props:{} }) } }).$mount(createNew); }) } } 最后实现的效果为: 此文源码案例:欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue中插件开发的四种方式.html":{"url":"article/vue/Vue中插件开发的四种方式.html","title":"3. Vue中插件开发的四种方式","keywords":"","body":"阅读前必读一、添加全局方法和属性二、给Vue实例添加方法和属性三、通过混入 mixin 方法添加一些组件选项;四、添加全局资源：指令，过滤器等为什么要开发插件？ 插件是对Vue功能上的补充，比如可以设置页面全局共享属性，方法等。 目录 阅读前必读 一、添加全局方法和属性 二、给Vue实例添加方法和属性 三、通过混入 mixin 方法添加一些组件选项; 1. 局部混入 2. 全局混入 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 2. 添加过滤器 依据官方文档插件开发说明，插件开发有四种方式。 添加全局方法或者属性; 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 通过全局 mixin 方法添加一些组件选项; 添加全局资源：指令/过滤器/过渡等; 一个库，提供自己的 API，同时提供上面提到的一个或多个功能， 阅读前必读 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象. 比如： export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } 开发插件时，给Vue/Vue实例添加方法或者属性时，建议命名方式使用$开头，这样就不会存在和插件命名冲突。如果冲突了则优先使用组件属性/方法。 一、添加全局方法和属性 作用: 添加全局方法和属性，所有组件都可共享方法和属性，当某个组件更新了共享属性，那么其他组件也会同步更新。并非是组件实例之间的数据共享。 //1:编写组件 export default{ install:function (Vue,options) { Vue.$globalFunction=function (num) { return 2*num; }; Vue.$globalVariable=\"我是mrgao\"; } } //2:声明组件，注入组件 import install from \"./plugins/demo.js\"; Vue.use(install); //3：组件样例 {{ formatNumber }} import Vue from \"vue\"; export default { data() { return { gloablFunc: \"\" }; }, computed: { formatNumber: function() { //调用全局共享方法 return Vue.$globalFunction(this.gloablFunc); } } }; 二、给Vue实例添加方法和属性 方式:使用Vue.prototype的方式给Vue实例添加方法和属性 注意点：使用Vue.prototype的方式添加的属性是不会在各个实例之间数据共享的。 比如A实例修改了某属性，则B实例使用此属性时不会是A修改的值。 //1：组件编写 demo.js export default { install: function(Vue, options) { Vue.prototype.$instanceFunction = function(num) { return 3 * num; }; Vue.prototype.$instanceVar=\"我是实例变量\"; } }; //2：组件声明 main.js import install from \"./plugins/demo.js\"; Vue.use(install); //3:组件使用 Plugins.vue ...省略部分 添加实例方法/属性测试 {{ instanceVar }} mounted(){ console.log(this.$instanceVar); this.instanceVar=this.$instanceVar; //this.instanceVar=this.$instanceFunction(20); } 三、通过混入 mixin 方法添加一些组件选项; 混入mixin作用： 将混入对象的方法/数据对象合并到改组件本身的方法/数据上；若存在同名的方法，则首先调用混入对象，再调用组件本身方法，若存在同名数据对象，则使用组件的数据对象 混入分为局部混入和全局混入，一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。请谨慎使用全局混入，尽可能使用局部混入。 1. 局部混入 此处借用官方的例子选项合并 当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。比如，数据对象在内部会进行递归合并，在和组件的数据发生冲突时以组件数据优先。 若存在同名方法则优先调用混入对象的方法。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 var mixin = { data: function() { return { message: \"hello\", foo: \"abc\" }; }, created: function() { console.log(\"混入对象的钩子被调用\"); }, methods:{ demo1(){ console.log(\"混入demo1\"); }, demo2(){ console.log(\"混入demo2\"); } } }; export default { mixins: [mixin], data: function() { return { message: \"goodbye\", bar: \"def\" }; }, created: function() { console.log('组件钩子被调用') console.log(this.$data); //混入对象的钩子被调用 //组件钩子被调用 // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" } }, methods:{ demo1(){ console.log(\"组件demo1\"); } } }; 2. 全局混入 为全局Vue实例混入一个created方法，在每一个实例调用本身的created之前都会首先调用混入的created。 通常我们可以使用全局混入对Vue实例注入统一处理统计。 // 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin({ created: function () { //console.log(\"相信我，这个Log会在每一个Vue实例created之前调用\"); var myOption = this.$options.myOption if (myOption) { console.log(myOption) } } }) new Vue({ myOption: 'hello! mrgao' }) // => \"hello!\" 四、添加全局资源：指令，过滤器等 1. 添加自定义指令 除了核心功能默认内置的指令 (v-model 和 v-show等)，Vue 也允许注册自定义指令。 参考官方文档：自定义指令 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\"1 + 1\" 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 //D.vue export default { data() { return { message: \"我是demo\" }; } }; //main.js Vue.directive('demo', { bind: function (el, binding, vnode) { var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '' + 'value: ' + s(binding.value) + '' + 'expression: ' + s(binding.expression) + '' + 'argument: ' + s(binding.arg) + '' + 'modifiers: ' + s(binding.modifiers) + '' + 'vnode keys: ' + Object.keys(vnode).join(', ') } }) 结果为： name: \"demo\" value: \"我是demo\" expression: \"message\" argument: \"foo\" modifiers: {\"a\":true,\"b\":true} vnode keys: tag, data, children, text, elm, ns, context, fnContext, fnOptions, fnScopeId, key, componentOptions, componentInstance, parent, raw, isStatic, isRootInsert, isComment, isCloned, isOnce, asyncFactory, asyncMeta, isAsyncPlaceholder 2. 添加过滤器 //1：编写过滤器 currency.js const digitsRE = /(\\d{3})(?=\\d)/g export function currency (value, currency, decimals) { value = parseFloat(value) if (!isFinite(value) || (!value && value !== 0)) return '' currency = currency != null ? currency : '$' decimals = decimals != null ? decimals : 2 var stringified = Math.abs(value).toFixed(decimals) var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified var i = _int.length % 3 var head = i > 0 ? (_int.slice(0, i) + (_int.length > 3 ? ',' : '')) : '' var _float = decimals ? stringified.slice(-1 - decimals) : '' var sign = value 单价:{{ product.price | currency }} 上述已经简单讲解了Vue插件开发的四种方式，最后一种方式，也就是将上述四种组合在一个install方法中即可。 文章实例请见：examples目录。 欢迎Star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/vue/Vue路由变化页面没有刷新解决办法.html":{"url":"article/vue/Vue路由变化页面没有刷新解决办法.html","title":"4. Vue路由变化页面没有刷新","keywords":"","body":" 在Vue使用router开发单页面过程中，我们会遇到多次进入同一页面，页面没有刷新的情况。 一个例子： 有一个列表页面和详情页面，当点击列表的每一项，显示详情。你会发现，如果我们单纯的使用this.$router.push({path:\"/detail\",query:{id:\"your id\",another:\"asasaas\"}})，跳转到详情页面，详情页面的数据并没有发生变化。 解决办法: 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) $route 对象： export default{ ... watch: { '$route' (to, from) { // 对路由变化作出响应... if(to.path==\"/detail\"){ this.initData(); } } } } 或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫： {{id}} {{another}} export default { data() { return { id: \"\", another: \"\" }; }, methods: { initData(to) { let query = to.query; console.log(\"传递过来的数据\", query,to); this.id = query.id; this.another = query.another; } }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` this.initData(to); next(); }, mounted(){ this.initData(this.$route); } }; Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/javascript/":{"url":"article/javascript/","title":"二、JavaScript","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:34:27 "},"article/javascript/new_A和A的区别.html":{"url":"article/javascript/new_A和A的区别.html","title":"4. new A()和A()的区别","keywords":"","body":"function Me(name,age,job){ this.name = name; this.age = age; this.job = job; } //请问这以下两种实例化对象方式有什么区别呢？ var mefun1 = new Me('fei','20','it'); var mefun2 = Me('fei','20','it'); 第一种是构造函数式，即通过new运算符调用构造函数Function来创建函数 第二种不是实例化，只是调用函数把返回值赋给变量。 JavaScript 中并没有真正的类，但JavaScript 中有构造函数和new 运算符。构造函数用来给实例对象初始化属性和值。任何JavaScript 函数都可以用做构造函数，构造函数必须使用new 运算符作为前缀来创建新的实例。 new 运算符改变了函数的执行上下文，同时改变了return 语句的行为。实际上，使用new和构造函数很类似于传统的实现了类的语言: // 实例化一个Me var alice = new Me('alice', 18, 'Coder'); // 检查这个实例 assert( alice instanceof Me ); 构造函数的命名通常使用驼峰命名法，首字母大写，以此和普通的函数区分开来，这是一种习惯用法。 // 不要这么做! Me('alice', 18, 'Coder'); //=> undefined 这个函数只会返回undefined，并且执行上下文是window（全局）对象，无意间创建了3个全局变量name,age,job。调用构造函数时不要丢掉new 关键字。 当使用new 关键字来调用构造函数时，执行上下文从全局对象（window）变成一个空的上下文，这个上下文代表了新生成的实例。 因此，this 关键字指向当前创建的实例。尽管理解起来有些绕，实际上其他语言内置类机制的实现也是如此。 默认情况下，如果你的构造函数中没有返回任何内容，就会返回this——当前的上下文。 要不然就返回任意非原始类型的值. 转载：javascript中使用new与不使用实例化对象的区别 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:33:19 "},"article/javascript/Javascript的变量提升和函数提升.html":{"url":"article/javascript/Javascript的变量提升和函数提升.html","title":"5. Javascript的变量提升和函数提升","keywords":"","body":"Javascript的变量提升和函数提升一、变量提升二、函数提升参考:Javascript的变量提升和函数提升 在JavaScript执行代码的过程中是一段一段从上往下执行代码。执行代码之前是有一个预处理过程的，比如变量的提升和函数提升。 一、变量提升 通常我们会遇到如下的代码: console.log(a); //输出结果:undefined var a=\"mr gao\"; console.log(a);//输出结果:mr gao function demo(){ console.log(a);//输出结果:undefined var a=\"demo\"; console.log(a);//输出结果:demo } demo(); 其实javascript在预处理过程时，会将声明的变量提升至对应作用域的顶端；所以上述的代码类似于: var a; //变量提升，如果当前作用域有相同的变量名，则会被提升至同一位置。 console.log(a); //输出结果:undefined a=\"mr gao\"; console.log(a);//输出结果:mr gao function demo(){ var a; console.log(a);//输出结果:undefined a=\"demo\"; console.log(a);//输出结果:demo } demo(); 二、函数提升 在搞懂函数提升之前先要了解函数声明的几种方式: //1:函数声明方式 function funName(){ } //2:函数表达式 } var funName=function(){ } //3:函数对象方式 var funcName=new Function(); 只有函数声明方式采用函数作用域的提升 例子： （1）变量提升 demo();//结果为:undefined var age=20;//这个变量的声明会提升到变量使用之前 function demo() { console.log(age);//undefined var age=30; } //代码解析过程为 var age; function demo() { var age; console.log(age); age=30; } demo(); age=20; （2）相同函数名变量提升 function demo(){ console.log(\"我是第一个函数啊\") } demo(); function demo(){ console.log(\"我是第二个函数啊\") } demo(); //执行结果为:我是第二个函数啊 我是第二个函数啊 //执行过程为: function demo(){//第一个demo函数提升至作用域顶端，第二个同名demo函数也提升至顶端，覆盖第一个demo函数 console.log(\"我是第二个函数啊\") } demo()//调用第一个demo函数 demo()//调用第二个demo函数 （3）函数名和变量名冲突：函数名优先级高(函数优先) console.log(demo); var demo=\"我是变量\"; function demo (){ console.log(\"我是函数\"); } //输出结果为: ƒ demo(){ console.log(\"我是函数\"); } 参考: JavaScript 解析器、预解析、变量提升、函数提升 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/Javascript对闭包的理解.html":{"url":"article/javascript/Javascript对闭包的理解.html","title":"6. Javascript对闭包的理解","keywords":"","body":"闭包的定义常见的闭包闭包的用途闭包的缺点MDN 闭包 闭包的定义 闭包是指有权访问另一个函数作用域中的变量的函数 --《JavaScript高级程序设计》 闭包是函数和声明该函数的词法环境的组合。 -- 《MDN》 Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。 而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。 当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 常见的闭包 function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); myFunc(); //使用匿名函数 function makeAdder(x) { return function(y) {//匿名函数的闭包内部的this位windows，请见最后闭包的缺点 return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 闭包的用途 1. 保护变量的安全-实现JS私有属性和私有方法 利用闭包可以读取函数内部的变量，变量在函数外部不能直接读取到，从而达到保护变量安全的作用。因为私有方法在函数内部都能被访问到，从而实现了私有属性和方法的共享。 常见的模块模式就是利用闭包的这种特性建立的 var Counter = (function() { //私有属性 var privateCounter = 0; //私有方法 function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } } })(); console.log(privateCounter); //privateCounter is not defined console.log(Counter.value()); // 0 Counter.increment(); Counter.increment(); console.log(Counter.value()); // 2 Counter.decrement(); console.log(Counter.value()); // 1 在jQuery框架的私有方法和变量也是这么设计的 var $ = jQuery = function(){ return jQuery.fn.init(); } jQuery.fn = jQuery.prototype = { init:function(){ return this; //this指向jQuery.prototype }, length: 1, size: function(){ return this.length; } } console.log($().size()); // 1 2. 将处理结果缓存 var mult = (function(){ var cache = {}; var calculate = function(){ var a = 1; for(vari=0,l=arguments.length;i 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 理解了闭包的原理我们发现闭包的这些用途都是利用了闭包保存了当前函数的活动对象的特点， 这样闭包函数在作用域之外被调用时依然能够访问其创建时的作用域 闭包的缺点 闭包将函数的活动对象维持在内存中，过度使用闭包会导致内存占用过多，所以在使用完后需要将保存在内存中的活动对象解除引用； 闭包只能取得外部函数中任何变量的最后一个值，在使用循环且返回的函数中带有循环变量时会得到错误结果；(这就是为什么循环对节点绑定事件无效的原因) 当返回的函数为匿名函数时，注意匿名函数中的this指的是window对象。 参考:对JavaScript中闭包的理解 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/对Object.create和类式继承的理解.html":{"url":"article/javascript/对Object.create和类式继承的理解.html","title":"7. 对Object.create和类式继承的理解","keywords":"","body":"对类式继承的理解对Object.create()的理解对类式继承的理解 疑问1？实现类式继承时为啥是 B.prototype = new A(); 而不是 B.prototype = A or B.prototype = A.prototype？ proto 与 prototype 的区别prototype是类(构造函数)才有的!! proto是对象拥有的! 因为函数也是对象, 所有函数也有proto.proto是为了实现继承, prototype是为了定义一些公用属性和方法. var b = new B(); // 解释:那么 b.__proto__ == B.prototype == A A.__proto__ == Function.prototype Function.prototype.__proto__ == Object.prototype Object.prototype.__proto__ == null //所以通过__proto__永远找不到A.prototype, 所以 B 不能继承 A 疑问2? 这里为啥是 B.prototype = new A(); 而不是B.prototype == A.prototype 继承的目的 1. 复用父类方法 2. 有权添加/重写父的方法但继承决不允许改变父的方法和属性, 对于父子是只读的.//所以 B.prototype == A.prototype使得两者成为一体, 一旦修改 全部都修改了, 所以不行 //而 B.prototype == new A() //假设 var a = new A()那么向上链起来:B.protype == a var b = new B(); b.__proto__ == B.prototype == a a.__proto__ == A.prototype // 这一步也证明B继承了A B.prototype.xxx= function() {} 这里添加的xxx方法只是改变了a而已(一个局部变量),不会影响到A.prototype 对Object.create()的理解 Object.create()的作用：Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 简单理解为：创建一个新的对象，来实现原型链的继承。 Polyfill的实现 Object.create=function(proto){ function F() {} F.prototype = proto; return new F(); } //demo var prototype = Object.create(superType.prototype); // 创建对象 prototype.constructor = subType; // 增强对象 subType.prototype = prototype; // 指定对象 使用Object.create()方式实现原型链集成，其构造函数没有继承。这就是为什么你会发现在使用寄生式组合集成时使用Object.create()之后还需要 指定构造函数。 看了前面的类式继承的理解，再来看Object的polyfill实现，为什么要使用一个中转函数来实现原型链的集成。 如果直接使用 subType.prototype=new superType();会将superType的构造函数也会继承；这就违背了Object.create()的定义：实现原型链的集成 如果使用subType.prototype=supertype.prototype;实现原型链集成，会导致对subType.prototype原型链的修改影响到supertype的原型链。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-10 22:25:51 "},"article/javascript/Object.create和New的区别.html":{"url":"article/javascript/Object.create和New的区别.html","title":"8. Object.create()和New的区别","keywords":"","body":"Object.create()的polyfill实现NewNew和Object.create()的区别 引用官方的一句话：Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的proto。 Object.create(proto, [propertiesObject]) proto 新创建对象的原型对象。 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性） 对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 Object.create()的polyfill实现 方法内部定义一个新的空对象obj 将obj.proto的对象指向传入的参数proto 将传入的对象属性复制到obj并且返回obj if (typeof Object.create !== \"function\") { Object.create = function (proto, propertiesObject) { if (typeof proto !== 'object' && typeof proto !== 'function') { throw new TypeError('Object prototype may only be an Object: ' + proto); } else if (proto === null) { throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\"); } if (typeof propertiesObject != 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\"); //核心是下面的代码 function F() {} F.prototype = proto; return new F(); }; } New 语法： new constructor ( [aguments] ) MDN文档 由此我们可以看出，实际new创建对象，就是调用构造函数来实例化，在调用构造函数的时候会执行以下操作： 创建一个新的对象 将新对象执行原型操作，指向构造函数的原型 将this绑定到新对象上（可以使用 call 或者 apply 强制转换执行环境） 构造函数返回的对象就是实例化的结果，如果构造函数没有显示返回一个对象，则返回新的对象 New的polyfill实现 function _new_ (){ var obj = {}, Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === 'object' ? ret : obj; } New和Object.create()的区别 比较 new Object.create 构造函数 保留原构造函数属性 丢失原构造函数属性(这就是为什么使用寄生式组合时需要重新设置构造函数) 原型链 原构造函数prototype属性 原构造函数/（对象）本身 作用对象 function function和object 参考： New 和 Object.create()的区别 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:33:34 "},"article/javascript/Javascript柯里化和偏函数实现.html":{"url":"article/javascript/Javascript柯里化和偏函数实现.html","title":"9. Javascript柯里化和偏函数实现","keywords":"","body":"第二种手动结束偏函数什么是函数柯里化 只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。用公式表示就是我们要做的事情其实是 ```js fn(a,b,c,d)=>fn(a)(b)(c)(d)； fn(a,b,c,d)=>fn(a，b)(c)(d)； fn(a,b,c,d)=>fn(a)(b，c，d)； ...... 再或者这样： fn(a,b,c,d)=>fn(a)(b)(c)(d)()； fn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()； 但不是这样：(下面为偏函数) fn(a,b,c,d)=>fn(a)； fn(a,b,c,d)=>fn(a，b)； ### 第一种方式：按照参数个数自动结束 ```js fn(a,b,c,d)=>fn(a)(b)(c)(d)； fn(a,b,c,d)=>fn(a，b)(c)(d)； fn(a,b,c,d)=>fn(a)(b，c，d)； 代码实现 const curry = (fn, ...arg) => { let all = arg || [], length = fn.length; return (...rest) => { let _args = all.slice(0); //拷贝新的all，避免改动公有的all属性，导致多次调用_args.length出错 _args.push(...rest); if (_args.length 第二种手动结束 fn(a,b,c,d)=>fn(a)(b)(c)(d)()； fn(a,b,c,d)=>fn(a)；fn(b)；fn(c)；fn(d)；fn()； const curry=function(fn,...args){ let all=args||[]; let argsLen=fn.length; return function(...argsIn){ let _args=all.slice(0); _args.push(argsIn); if(argsIn.length===0){ all=[]; fn.apply(this,_args); }else{ curry.call(this,fn,..._args); } } } //测试 let test = curry(function(...rest) { let args = rest.map(val => val * 10); console.log(args); }) test(2); test(2); test(3); test(); test(5); test(); test(2)(2)(2)(3)(4)(5)(6)(); test(2, 3, 4, 5, 6, 7)(); 偏函数 fn(a,b,c,d)=>fn(a)； fn(a,b,c,d)=>fn(a,b)； function part(fn, ...arg) { let all = arg || []; return (...rest) => { let args = all.slice(0); args.push(...rest); return fn.apply(this, args) } } function add(a = 0, b = 0, c = 0) { console.log(a + b + c); } let addPart = part(add); addPart(9); //9 addPart(9, 11);//20 参考：js高阶函数应用—函数柯里化和反柯里化 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/JavaScript中改变this指向有几种方式.html":{"url":"article/javascript/JavaScript中改变this指向有几种方式.html","title":"10. JavaScript中改变this指向有几种方式","keywords":"","body":"JavaScript中改变this指向有几种方式丢失的this this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window JavaScript中改变this指向有几种方式 this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。 （1）作为函数名调用 当函数不作为对象的属性被调用时候，也就是我们所说的普通函数方式，此时的this总是指向全局的对象。在浏览器的js里面，这个全局对象是window对象。 ```js function a(){ var author = \"lry\"; console.log(this.author); //undefined console.log(this); //Window } a(); //其实这是相当于 window.a() //或者 window.name = \"globalName\"; var myObject = { name: \"louis\", getName: function () { return this.name; } } var getName = myObject.getName; console.log(getName()); // \"globalName\" （2）**作为对象方法调用** > 函数作为对象中的一个属性，成为该对象的一个方法，this指向该对象 ```js var o = { author:\"lry\", fn:function(){ console.log(this.author); //lry } } o.fn(); //this => o （3）使用构造函数调用 使用new调用的函数，则其中this将会被绑定到那个新构造的对象。（首先new关键字会创建一个空的对象，然后会自动调用一个函数方法(apply...)，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代） 除了宿主提供的一些内置函数，大部分js函数都可以当成构造器使用，构造器的外表看起来和普通的函数没有什么区别，他们的区别在于调用方式，当使用new运算符调用函数的时候，该函数总是返回一个对象，通常情况下，构造器里面的this就是指向返回的这个对象。 function Fn() { this.author = \"lry\" } var o = new Fn(); console.log(o.author); //lry （4）apply或call,bind调用  自行改变this指向，函数this指向apply或call方法调用时的第一个参数 var o = { author:\"lry\", fn:function(){ console.log(this.author); //lry } } var b = o.fn; b.call(o); //或者 b.apply(o) var o = { a:10, b:{ a:20, fn:function(){ console.log(this.a); //20 } } } o.b.fn(); 这里的this为什么不是指向o？如果按照上面的理论，最终this指向的是调用它的对象，因为 如果一个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。看下面例子：虽然对象b中没有属性a，但this仍然指向的是它的上一级对象b var o = { a:10, b:{ //a:20, fn:function(){ console.log(this.a); //undefined } } } o.b.fn(); 特殊情况： var o = { a:10, b:{ a:20, fn:function(){ console.log(this.a); //undefined console.log(this); //window } } } var c = o.b.fn; c(); 丢失的this 下面看一个经常遇到的问题： var obj = { myName: \"louis\", getName: function () { return this.name; } } console.log(obj.getName()); // louis; var getName2 = obj.getName; console.log(getName2()) // undefined 当调用obj.getName时，getName方法是作为obj对象的属性被调用的，根据上文提到的规律，此时的this指向obj对象，所以obj.getName()输出'louis'。 当用另外一个变量getName2来引用obj.getName，并且调用getName2时， 此时是普通函数调用方式，this是指向全局window的，window上面并没有挂载任何属性所以程序的执行结果是undefined。 再看另一个例子，document.getElementById这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同prototype.js等一些框架所做过的事情: var getId = function (id) { return document.getElementById(id); }; getId('div1'); 我们也许思考过为什么不能用下面这种更简单的方式 var getId = document.getElementById; getId( 'div1' ); 现在不妨花1分钟时间，让这段代码在浏览器中运行一次 我是一个div var getId = document.getElementById; getId( 'div1' ); 在chrome friefox IE10 中执行过后就会发现，这段代码抛出一个异常,这是因为很多引擎的document.getElementById 方法的内部实现中需要用到this，这个this本来被期望指向document，当getElementById方法作为document对象的属性被调用时，方法内部的this确实是指向document的。 但是当getId来引用document,getElementById之后，再调用getId，此时就成了普通的函数调用了，函数内部的this指向了window，而不是原来的document。 我们可以尝试利用apply把document当做this传递给getId函数，修正 this指向问题。 ```js document.getElementById = (function(func){ return function(){ return func.apply(document,arguments); } })(document.getElementById); var getId = document.getElementById; var div = getId('div1'); alert(div.id); ``` 参考：深入学习js之——this Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/Javascript的call和apply和bind方法.html":{"url":"article/javascript/Javascript的call和apply和bind方法.html","title":"11. Javascript的call和apply和bind方法","keywords":"","body":"call/apply方法第一个参数解释:借肉的人，call/apply的使用场景文章参考 在JavaScript中call、apply、bind是Function 对象自带的三个方法，这三个方法的主要作用是改变函数中的 this 指向，从而可以达到接花移木的效果。 call、apply、bind方法的共同点和区别：apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文（函数的每次调用都会拥有一个特殊值——本次调用的上下文（context）——这就是this关键字的值。）；apply 、 call 、bind 三者都可以利用后续参数传参； 区别：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 一个例子： //有刀没肉 function peopleOne(name,name2){ var knife=\"西瓜刀\"; console.log(name,name2,\"使用\",knife,\"切\",this.meat); }; //有肉，没刀 var peo={ meat:\"五花肉\" }; //让peopleOne的上下文对象为peo，这样peo就可以调用peopleOne()方法使用刀去切肉了 peopleOne.call(peo,'mrgao','mrwho'); //mrgao mrwho 使用 西瓜刀 吃 五花肉 peopleOne.apply(peo,['mrgao','mrwho']); //mrgao mrwho 使用 西瓜刀 吃 五花肉 call()和apply()的作用是: 借别人的方法(刀)吃自己的肉。：允许在一个对象（a）上调用该对象没有定义的方法(b)，并且这个方法(b)中可以访问该对象(a)中的属性。 其中call()和apply()的不同点为：入参的方式不同，call接受多个参数，而apply接收两个参数，其中第二个参数为一个数组列表 call/apply方法第一个参数解释:借肉的人， 不传，或者传null,undefined， 函数中的 this 指向 window 对象，传递另一个函数的函数名，函数中的 this 指向这个函数的引用，传递字符串、数值或布尔类型等基础类型，函数中的 this 指向其对应的包装对象，如 String、Number、Boolean，传递一个对象，函数中的 this 指向这个对象。 call/apply的使用场景 1、继承 function Product(name, price) { this.name = name; this.price = price; } function Food(name, price) { //Food使用了Product方法，这样Product中的上下文为Food， //所以Food会添加name和price属性 Product.call(this, name, price); this.category = 'food'; } console.log(new Food('cheese', 5).name); // 结果: \"cheese\" 2、借刀切肉/移花接木 参考：深入理解call、apply、bind（改变函数中的this指向） 在javascript中有很多类数组对象；，这些对象像数组一样存储着每一个元素，但它没有操作数组的方法，而我们可以通过call 将数组的某些方法移接到ArrayLike 对象，从而达到操作其元素的目的 function test(){ console.log(typeof(arguments)); //输出Object ，arguments //检测arguments是否是Array的实例 console.log(arguments instanceof Array); //输出 false console.log(Array.isArray(arguments)); //输出 false //判断arguments是否有forEach的方法 console.log(arguments.forEach); //输出 undefined //将数组中的forEach方法应用到arguments上 Array.prototype.forEach.call(arguments, function(item){console.log(item); //输出 1 2 3 4 5 }); //因为forEach的入参为一个函数，所以第二个参数应该为一个函数 } test(1,2,3,4,5); 文章参考 深入理解call、apply、bind（改变函数中的this指向） 详解call()，apply()和bind() 官方地址MDN Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-09 21:28:38 "},"article/javascript/Javascript的bind的polyfill的理解.html":{"url":"article/javascript/Javascript的bind的polyfill的理解.html","title":"12. Javascript的bind的polyfill的理解","keywords":"","body":"bind函数polyfill的理解bind函数polyfill的理解 bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 一个例子 function bFun(){ this.d=10; return this.a; } var func=bFun.bind({a:20}); func();//20 new func();//bFun {d:10} ，使用new 构造函数 方式创建，this指向为对象实例，而不是传入的{a:20} Polyfill if (!Function.prototype.bind) { Function.prototype.bind = function(oThis) {//oThis为需要绑定的对象也就是上例中的{a:20} // this为上例中的bFun，要求必须为函数类型 if (typeof this !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } //将bind函数传入的参数从第1个(index从0开始)开始转换成数组，因为第0个为传入的绑定对象。arguments为类数组 var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {}, fBound = function() { // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用 // 由于使用new 方式创建的对象，this指向为对象的实例，此处判断如果使用new方式创建那么this应该为对象实例的this // 否则使用上下文绑定为传入的对象 return fToBind.apply(this instanceof fBound ? this : oThis, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 // 函数的参数：应该为bind时传入的参数+调用生成的函数时传入的参数和 aArgs.concat(Array.prototype.slice.call(arguments))); }; // 维护原型关系 if (this.prototype) { // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; } // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; }; } 其中如下代码作用和fBound.prototype=Object.create(this.prototype)作用一样， 效果为：生成的新函数(func)应该继承于原有函数(bFun)原型链 ```js fNOP = function() {}, if (this.prototype) { fNOP.prototype = this.prototype; } fBound.prototype = new fNOP(); ``` Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-10 22:25:51 "},"article/javascript/Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6.html":{"url":"article/javascript/Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6.html","title":"13. Javascript模块化发展AMD,CMD,CommonJS,UMD,ES6","keywords":"","body":"CommonJS 模块化AMD模块化特点优缺点AMD的库requireJS的使用CMD模块化特点CMD & AMD间的区别sea.js的使用UMD 模块化ES6模块化特点ES6 模块与 CommonJS 模块的差异使用示例 前端模块化的发展大致有如下：IIFE,CommonJS,AMD,CMD,UMD,Es6 Module 模块化的好处 避免命名冲突(减少命名空间污染) 更好的分离, 按需加载 更高复用性 高可维护性 CommonJS 模块化 CommonJS是服务器端模块的规范，commonJS用同步的方式加载模块, Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。核心思想是通过 require方法来同步地加载依赖的其他模块，通过 module.exports 导出需要暴露的接口。 特点 1、根据CommonJS规范，一个单独的文件就是一个模块。 2、每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 3、模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; 4、dirname代表当前模块文件所在的文件夹路径，filename代表当前模块文件所在的文件夹路径+文件名; 5、require（同步加载）基本功能：读取并执行一个JS文件，然后返回该模块的exports对象，如果没有发现指定模块会报错; 6、模块内的exports：为了方便，node为每个模块提供一个exports变量，其指向module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给exports对象添加方法，PS：不能直接赋值（因为这样就切断了exports和module.exports的联系）; // 定义模块math.js var basicNum = 0; function add(a, b) { return a + b; } module.exports = { //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum } // 引用自定义的模块时，参数包含路径，可省略.js var math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径 var http = require('http'); http.createService(...).listen(3000); AMD模块化 AMD 是RequireJs在推广过程中对模块化定义的规范化产出。（异步模块）AMD 规范主要是为了解决针对浏览器环境的模块化问题。 特点 AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。 AMD 推崇依赖前置、提前执行; 由于依赖的模块是异步加载的，那么函数执行的时机为所有模块都加载完成了才执行。如果某个模块加载比较耗时，建议采用全局依赖的形式去加载顶层模块。 requirejs 模块的加载顺序是不固定的，但执行顺序是固定的，按依赖声明的先后顺序执行. 优缺点 AMD 的优点 可在不转换代码的情况下直接在浏览器中运行 可加载多个依赖 代码可运行在浏览器环境和 Node.js 环境下 AMD 的缺点 JavaScript 运行环境没有原生支持 AMD，需要先导入实现了 AMD 的库后才能正常使用。 由于依赖前置，那么及时在回调函数中没有使用依赖的模块，模块还是会被加载。 AMD的库 requireJS curl requireJS的使用 使用requireJS:用require.config()指定引用路径等，用define()定义模块，用require()加载模块。 ```js //首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。 / 网页中引入require.js及main.js / / main.js 入口文件/主模块 / // 首先用config()指定各模块路径和引用名 require.config({ baseUrl: \"js/lib\", paths: { \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", } }); // 执行基本操作 require([\"jquery\",\"underscore\"],function($,_){ // some code here }); > 引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。 ```js // 定义math.js模块 define(function () { var basicNum = 0; var add = function (x, y) { return x + y; }; return { add: add, basicNum :basicNum }; }); // 定义一个依赖underscore.js的模块 define(['underscore'],function(_){ var classify = function(list){ _.countBy(list,function(num){ return num > 30 ? 'old' : 'young'; }) }; return { classify :classify }; }) // 引用模块，将模块放在[]内,模块的加载是异步，只有两者都加载完成才调用回调函数 require(['jquery', 'math'],function($, math){ var sum = math.add(10,20); $(\"#sum\").html(sum); }); CMD模块化 CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 特点 依赖就近，延时执行 CMD是按需加载依赖，在用到那个模块再去require CMD & AMD间的区别 AMD依赖前置，在定义模块时就声明其所要依赖的模块 CMD是按需加载依赖，在用到那个模块再去require AMD在使用前就准备好，CMD是用到了再去准备模块 AMD CMD 定义module时对依赖的处理 推崇依赖前置，在定义的时候就要声明其依赖的模块 推崇就近依赖，只有在用到这个module的时候才去require 加载方式 async async 执行module的方式 加载module完成后就会执行该module，所有module都加载执行完成后会进入require的回调函数，执行主逻辑。依赖的执行顺序和书写的顺序不一定一致，谁先下载完谁先执行，但是主逻辑 一定在所有的依赖加载完成后才执行(有点类似Promise.all)。 加载完某个依赖后并不执行，只是下载而已。在所有的module加载完成后进入主逻辑，遇到require语句的时候才会执行对应的module。module的执行顺序和书写的顺序是完全一致的。 /** AMD写法 **/ define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } }); /** CMD写法 **/ define(function(require, exports, module) { var a = require('./a'); //在需要时申明 a.doSomething(); if (false) { var b = require('./b'); b.doSomething(); } }); /** sea.js **/ // 定义模块 math.js define(function(require, exports, module) { var $ = require('jquery.js'); var add = function(a,b){ return a+b; } exports.add = add; }); // 加载模块 seajs.use(['math.js'], function(math){ var sum = math.add(1+2); }); sea.js的使用 sea.js 引入sea.js的库 如何变成模块？ - define - 如何调用模块？ -exports -sea.js.use 如何依赖模块？ -require define(function (require,exports,module) { //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports }) UMD 模块化 UMD是AMD和CommonJS和 全局对象(Global Object)的融合 AMD模块以浏览器第一的原则发展，异步加载模块。 CommonJS模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。 这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。 UMD先判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。然后判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。 (function (root, factory) { if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['b'], factory); } else if (typeof module === 'object' && module.exports) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(require('b')); } else { // Browser globals (root is window) root.returnExports = factory(root.b); } }(typeof self !== 'undefined' ? self : this, function (b) { // Use b in some fashion. // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return {}; })); ES6模块化 ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义，作为浏览器和服务器通用的模块解决方案它可以取代我们之前提到的 AMD ，CMD , UMD ,CommonJS。 关于 ES6 的 Module 相信大家每天的工作中都会用到，对于使用上有疑问可以看看 ES6 Module 入门，阮一峰; 特点 ES6模块导入的变量(其实应该叫常量更准确)具有以下特点： 变量提升、相当于被Object.freeze()包装过一样、import/export只能在顶级作用域 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 ES6模块区别于CommonJS的运行时加载，import 命令会被JavaScript引擎静态分析，优先于模块内的其他内容执行(类似于函数声明优先于其他语句那样)， 也就是说在文件的任何位置import引入模块都会被提前到文件顶部。 ES6的模块 自动开启严格模式，即使没有写'use strict'; 运行一个包含import声明的模块时，被引入的模块先导入并加载，然后根据依赖关系，每个模块的内容会使用深度优先的原则进行遍历。跳过已经执行过的模块，避免依赖循环 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成 使用示例 import { prop } from 'app'; //从app中导入prop import { prop as newProp } from 'app'; // 功能和上面一样，不过是将导入的prop重命名为newProp import App from 'App'; // 导入App的default import * as App from 'App'; // 导入App的所有属性到App对象中 export const variable = 'value'; // 导出一个名为variable的常量 export {variable as newVar}; // 和import 的重命名类似，将variable作为newVar导出 export default variable = 'value'; // 将variable作为默认导出 export {variable as default}; // 和上面的写法基本一样 export {variable} from 'module'; // 导出module的variable ，该模块中无法访问 export {variable as newVar} from 'module'; // 下面的自己看 不解释了 export {variable as newVar} from 'module'; export * from 'module'; 参考: 前端开发之模块化开发中的规范讲解--commonjs、AMD、CMD、ES6 前端模块化：CommonJS,AMD,CMD,ES6 AMD, CMD, CommonJS和UMD Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-07-10 22:25:51 "},"article/mendix/":{"url":"article/mendix/","title":"三、轻量化平台Mendix","keywords":"","body":"一、什么是Mendix二、Mendix可以做什么三、Mendix的优点四、Mendix的缺点五、部分学习资料 以下所有文件均是原创，如需转载请注明作者和链接地址。 一、什么是Mendix Mendix是一个轻量化开发工具，我们可以写较少的代码来快速构建一个应用（网站/app）；其实所谓的构建一个APP，其原理也是一个h5界面，也是运行在安全浏览器中。 使用Mendix之后，我们不需要太多的去关心前端和后台代码如何实现，而更多的是关系系统的业务和逻辑。 使用Mendix，不需要你自己写后台程序，不需要你写h5界面，一切只需要托拉拽即可。（构建应用从未如此之快）； 二、Mendix可以做什么 “大部分的网站都可以做”。 也许上面这句话说的优点夸张，但是mendix的底层是使用Java编写，也会使用h5；所以h5能做的它都能做。 当然啦，前提是大家要对其有一定的熟悉度哦！ 三、Mendix的优点 写少量的代码 快速构建并上线一个应用（目前我所在的项目：1周上线一个应用） Mendix适合做公司内部各自权限管理系统（Mendix有非常完善的权限管理机制）； Mendix适合不太懂编程的同学 Mendix构建一个网站只需要托拉拽，当然也可自己写样式或者写h5。 可自己编写java/h5到mendix中，甚至将其他的js库引入直接使用。 Mendix组件开发可以使用Vue/React等框架 代码编写流程化，清晰化。（举个例子） （ if判断（菱形），查询数据库数据（retrieve lis of ）） 等等..... 四、Mendix的缺点 不太适合高并发网站（但是可将前后台分离，Mendix只负责前端界面展示，） 对性能要求非常高的同学，可能mendix做稍有欠缺； 五、部分学习资料 由于mendix目前只在国外流行，故学习资料大部分都是英文文档； 1. Mendix官网 https://gettingstarted.mendixcloud.com/index3.html 里面有100多个module，如果你学习完了，你就是大牛了。 2. mendix组件中关于mx.data的api:https://apidocs.mendix.com/7/client/mx.data.html 一些api文档，我希望大家鞥看看。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/env.html":{"url":"article/mendix/env.html","title":"1. Mendix环境搭建","keywords":"","body":"一、Mendix安装教程二、新建一个项目 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、主要内容：介绍Mendix的安装教程和如何简单构建一个应用 2、适用人群：初学者； 3、浏览时间：有点点长哦； Mendix开发主要有两种方式，一种为网页版，一种是客户端；本文推荐使用客户端安装并开发。 一、Mendix安装教程 在安装Mendix之前，最好使用公司的账号在mendix官网注册一个账号，否则在启动客户端时需要验证邮箱；官网注册地址：https://signup.mendix.com/link/signup/?source=direct 1、Mendix安装额外的文件 mendix的安装主要有以下几个文件： Microsoft .NET Framework 4.6.2 地址：https://www.microsoft.com/net/download/thank-you/net462 Microsoft Visual C++ 2010 SP1 Redistributable Package Microsoft Visual C++ 2013 Redistributable Package Java Development Kit 1.8 地址：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html Mendix客户端 地址：https://appstore.home.mendix.com/link/modelers/ （最好下载最新的哦，访问可能有点慢） 记得在安装mendix客户端前安装上述四个文件，并将Java路径设置到系统变量中去哦。 2、安装客户端 在开始构建应用程序之前，需要在计算机上安装Mendix Desktop Modeler。请按照以下步骤安装Mendix Desktop Modeler： 打开下载的Mendix Modeler可执行文件。它的名字如下：Mendix-7.XX-Setup。 单击下一步。 选择我接受许可协议中的条款，然后单击下一步。 选择要安装到的文件夹，然后单击“ 下一步”。 输入要使用的开始菜单快捷方式文件夹，然后单击“ 下一步”。 选中“ 桌面”选项以在桌面上创建Modeler的快捷方式，然后单击“ 下一步”。 单击“ 安装”以在计算机上安装Modeler。 选中Launch Mendix 7.XX并单击Finish完成安装并启动Modeler。 以上是有关安装Mendix Desktop Modeler的方法。 二、新建一个项目 1、创建空项目 2、一些简单概念的介绍 在mendix中简单的界面构建以及数据库的创建只是需要简单的拖拽即可。但是又几个概念得提前缕清一下。 微流（Microflow）：类似于Java中的方法，又入参，出参，可在里面做循环，判断等等； 界面（Page）:页面的实现；使用客户端右侧，已经写好的组件拖拽到Page中即可迅速构建h5界面。 实体（在Domin Model中）：在mendix中有两种实体。持久化实体也就是数据库中的表；非持久化实体：Java中的类。 持久化实体： 非持久化实体： 3、一个视频教程 由于无法上传较长视频，所以请需要观看的同学点击以下链接观看： Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/javaaction.html":{"url":"article/mendix/javaaction.html","title":"2. Mendix使用Java","keywords":"","body":"JavaAction使用注意事项一、数据的添加 以下所有文件均是原创，如需转载请注明作者和链接地址。 此文demo地址：https://github.com/mrgaogang/mendix 日常开发中我们难免会有一些情况是无法使用微流实现的，此时需要我们使用Java原生的能力:JavaAction；此文主要介绍如何JavaAction对数据库的数据进行增删改查和使用action执行微流。 目录: 数据添加； 数据删除； 数据修改； 数据查询； 使用Action执行微流； JavaAction使用注意事项 JavaAction使用有几个注意点： executeAction()是mendix默认调用的方法，且我们只能在//BEGIN 和//END之间编写Java代码。 public java.util.List executeAction() throws Exception { // BEGIN USER CODE //此处是你的代码 // END USER CODE } 如果你有大量的代码需要编写请在类的末尾以下两个分隔符之间编写 // BEGIN EXTRA CODE // END EXTRA CODE 一、数据的添加 数据的创建可以使用Core.instantiate创建一个空的对象，也可直接new 出空对象；数据的提交可以使用obj.commit()可以使用Core.commit() public IMendixObject executeAction() throws Exception { // BEGIN USER CODE //第一种方式使用 IMendxObject创建数据 // IMendixObject ob= Core.instantiate(getContext(),\"Demo.User\"); // ob.setValue(getContext(),\"UserName\",UserName); // ob.setValue(getContext(),\"Password\",Password); // ob.setValue(getContext(),\"Age\",Age); // Core.commit(getContext(),ob); //第二种方式直接创建对象 User us=new User(getContext()); us.setUserName(UserName); us.setPassword(Password); us.setAge(Age); //提交数据到数据库 us.commit(getContext()); //也可以使用以下方式 //Core.commit(getContext(),us.getMendixObject()); return us.getMendixObject(); // END USER CODE } 二、数据的删除 数据的删除可以使用obj.delete()也可使用Core.delete() public java.lang.Boolean executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE //可以直接使用obj.delete ParameterParameter1.delete(getContext()); return true; // 也可以使用Core.delete的方式删除数据 //return Core.delete(getContext(),ParameterParameter1.getMendixObject()); // END USER CODE } 三、数据的修改 数据的修改和数据的提交类似，只是在action将数据修改后重新提交。 @Override public IMendixObject executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE ParameterParameter1.setUserName(\"===>我修改啦\"); ParameterParameter1.setPassword(\"我修改了密码\"); ParameterParameter1.setAge(200L); Core.commit(getContext(),ParameterParameter1.getMendixObject()); return ParameterParameter1.getMendixObject(); // END USER CODE } 四、查询数据 数据的查询主要使用以下几种方式 Core.retrieveXPathQuery() Core.retrieveXPathQueryAggregate() Core. retrieveId() Core. retrieveIdAsync() 其中XPath查询数据需要在前方加上// ；但是在mendix客户端编写xpath（比如在datagrid查询数据使用xpath）时 不需要加上//。 //Demo.User 检索所有用户。 //Demo.User[UserName='mrgao'] 检索名为'mrgao'的所有用户。 avg(//Demo.User[Age >10 ]/Age) 检索所有用户年龄大于10岁的 年龄平均数。 其中XPath可用的函数有： avg、count、max、min、sum、contains、starts-with、ends-with、not、true、false @Override public java.util.List executeAction() throws Exception { // BEGIN USER CODE List list=Core.retrieveXPathQuery(getContext(),\"//Demo.User\"); return list; // END USER CODE } 五、执行微流 微流的执行科分为同步执行execute()和异步执行executeAsyn()；此例子主要以同步执行为例； 微流执行时参数的传递主要使用Map的方式，且Key必须要和参数入参名称相同； 如果传入的是Object类型，则需要转化成mendixobject； 微流执行完成可获取到其返回的参数； public java.lang.String executeAction() throws Exception { this.ParameterParameter1 = __ParameterParameter1 == null ? null : demo.proxies.User.initialize(getContext(), __ParameterParameter1); // BEGIN USER CODE Map map=new HashMap<>(); //记得转换成mendixobject,且Map的key需要和微流入参的名称一样 map.put(\"User\",ParameterParameter1.getMendixObject()); map.put(\"other\",other); //执行微流，mf为微流，map则为需要执行微流的入参 String result=Core.execute(getContext(),mf,map); return result; // END USER CODE } 如果还想了解更多相关Core的知识，请访问官方API ：Mendix官方CoreAPI 以及IMendixObject的API :IMendixObject官方API Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widget.html":{"url":"article/mendix/widget.html","title":"3. 组件开发","keywords":"","body":"Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/开发组件前工具的准备.html":{"url":"article/mendix/widgets/开发组件前工具的准备.html","title":"1) 环境准备","keywords":"","body":"环境依赖Mendix组件开发打包工具gulp和grunt的比较：环境依赖 一、设置npm镜像为淘宝镜像 npm config set registry https://registry.npm.taobao.org 二、 安装Node.js到本地，然后执行以下命令 npm install yo grunt-cli generator-mendix -g 三、执行jshint进行grunt语法检查插件 npm install grunt-contrib-jshint --save-dev 四、在任意地方建一个目录，并进入此文件夹，执行 Yo mendix //注意在安装的时候要记得选择Grunt方式不要选择Gulp；接下来的选择AppStoreWidgetBiolerplate,from Github的方式 // 执行完之后会在目录中创建一个Gruntfile.js文件；打开JS文件，将里面的mpks->files->dest->TEST_WIDGETS_FOLDER替换成自己的mendix 工程目录的widgets目录即可。 然后在当前组件目录(有Gruntfile.js的目录)执行 grunt watch //该命令会自动的监听组件工程文件的修改，会自动打包到mendix工程目录下 Mendix组件开发打包工具gulp和grunt的比较： gulp优点： 不需要设置项目目录，在test目录下即可测试。 若只更新了组件的js代码，可直接在浏览器强制刷新界面，不需要重启mendix工程。 编译速度更快。 grunt优缺点： 虽说可直接打包到项目工程目录widgets下，但是尽可能不要直接在业务工程下测试组件（因为项目大之后启动会慢）； 每次测试都需要重启Mendix工程。 一、下载并安装Node.js 下载地址：https://nodejs.org/en/ 二、设置npm镜像 npm config set registry https://registry.npm.taobao.org 三、运行yo命令 运行 npm install -g yo generator-mendix命令 检查yo是否安装成功:yo --version 四、安装gulp npm install -g gulp-cli 五、请在空目录下运行 yo mendix 并设置组件的名称，选择Gulp编译，并创建一个AppStoreWidgetBoilerplate。 六、如何使用Gulp测试组件 1、使用VsCode编辑器打开组件根目录 2、在VSCode中新建终端并运行 gulp命令，每次保存，gulp会自动将组件打包 并在dist目录下生成.mpk文件； mpk文件是组件最终的文件，如果您已经开发完成组件， 可以将.mpk文件复制到项目工程目录下的widgets目录下， 并在mendix客户端中按F4刷新项目目录。 3、如果想测试组件的功能，可以将项目根目录下的mpr文件拷贝到组件test目录下， 并且删除Test.mpr文件，如果项目中使用到了其他组件，请一并拷贝到test/widgets目录下。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/Vue_Mendix.html":{"url":"article/mendix/widgets/Vue_Mendix.html","title":"3) Vue开发Mendix组件模板","keywords":"","body":"使用Vue开发Mendix组件模板1. 安装git和zip2. 如何使用致谢 组件开发有很多中方式，比如使用React/Vue或者使用符合AMD规范的库；其实mendix官网开发的组件是使用的dojo开发。 如果有同学没有学习过Vue/React开发，但是对原生Javascript有一定了解的话，请移步开发一个简单组件需要的步骤和组件开发引入外部符合AMD规范的库存在的问题。我想在以上可以找到答案。 本文不详细解释如何使用Vue开发一个页面，如果您有使用Vue开发Mendix组件的需求， 那么请直接点击下载Mendix组件开发之Vue基础包。 使用基础包开发会减少您的开发周期，如果基础包有什么问题请联系我gaogangwork@qq.com。 使用Vue开发Mendix组件模板 English 如果你对mendix组件开发基础知识还不了解的话，请先移步个人博客-mendix组件开发专题 由于mendix只在Windows中有客户端，所以必须在windows中国使用此模板。 使用步骤如下： 1. 安装git和zip 第一步: 建议你使用git命令行来构建组件。git下载地址是 点击这里下载; 第二步: 安装 zip and bzip2 点击去这里下载zip和bzip2 我下载的是“zip-3.0-bin.zip” 和 “zip.exe” ， “bzip2-1.0.5-bin.zip” 和 “bzip2.dll” /bin/.exe 记住：将zip.exe文件和bzip2.dll文件拷贝到git安装目录下 2. 如何使用 第一步: 下载这个模板或者 git clone https://github.com/MrGaoGang/mendix_vue_template 第二步: 打开组件开发根目录 第三步:运行如下命令 npm install npm run build 如果你想打生产包的组件的话，请修改webpack.config.js的文件 mode: \"development\", // Change the mode do \"production\" before you go live! Don't forget! plugins: [ // Change the plugin do \"production\" before you go live! Don't forget! new webpack.DefinePlugin({ 'process.env': { NODE_ENV: '\"development\"' // change to \"production\" when publishing your Mendix widget } }), 致谢 十分感谢 https://intonovi.com 封装了基础模板，其Github地址为here；本项目是基于此模板进行的优化和改良。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/详细API.html":{"url":"article/mendix/widgets/详细API.html","title":"4) 组件进阶-详细API","keywords":"","body":"一、组件开发mx.ui 界面设计二、组件开发mx.session获取三、组件开发数据获取mx.data四、组件开发mx.sever服务调用五、组件开发解析器mx.parse 首先对大家说一声抱歉，最近工作任务较为繁重，所以文章没有及时的更新；以下是最近几天加班总结和翻译出来的mendix，组件开发api文档。希望有同学能理解每一个对应API的作用。 一、组件开发mx.ui 界面设计 主要内容： 页面回退； 弹出框显示； 进度条显示与隐藏； 异常/信息/警告等显示； 组件重新加载； 表单打开； 微流操作中进度条显示； 文章地址： http://note.youdao.com/noteshare?id=1a91eb6560f8de4b0ffc9033b6c147d8 二、组件开发mx.session获取 主要内容： 组件中获取当前用户； 获取当前用户的GUID; 获取当前用户名； 获取当前用户的角色； 文章地址： http://note.youdao.com/noteshare?id=fe4218dce9aa1c7a1a4765e44f07c13c 三、组件开发数据获取mx.data 主要内容： 数据的创建； 数据的删除； 数据的查询； 数据的修改； 数据的监听； 文件保存 文章地址： http://note.youdao.com/noteshare?id=ab8c90ea1e44ffa6509c44568e0df8d5 四、组件开发mx.sever服务调用 主要内容： 服务的调用； 缓存查询 文章地址： http://note.youdao.com/noteshare?id=af24d16c2b8ff7229a368ffa1f69d318 五、组件开发解析器mx.parse 主要内容： 属性格式化； 值格式化； 值解析； 文章地址： http://note.youdao.com/noteshare?id=9e5210978d7789439e79f3c8bbffbc88 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/widgets/常用API.html":{"url":"article/mendix/widgets/常用API.html","title":"5) 组件进阶-常用API","keywords":"","body":"一、常用的API（五）查询管理关系的数据（六）创建一个上下文二、组件开发XML文档（一）property配置（二）两个例子 原生前端API主要有一下几个： 1、mx.ui/mx.data/mx.server/mx.session : 链接 2、mendix ：链接 3、mxui : 链接 一、常用的API (一) 从实体中获取/创建/删除数据 mx.data.get({ xpath: \"//System.User\", filter: { sort: [[\"Name\", \"asc\"]], offset: 0, amount: 10 }, callback: function(objs) { console.log(\"Received \" + objs.length + \" MxObjects\"); } }); mx.data.create({ entity: \"MyFirstModule.Cat\", callback: function(obj) { console.log(\"Object created on server\"); }, error: function(e) { console.error(\"Could not commit object:\", e); } }) mx.data.remove({ guids: [ \"123456\", \"45678\" ], callback: function() { console.log(\"Objects removed\"); }, error: function(e) { console.log(\"Could not remove objects:\", e); } }); （二）执行微流 mx.ui.action(\"微流的名称\",{ context:上下文, progress: \"modal\", progressMsg:\"进度条消息\", callback: function(result) { console.log(\"Engine started: \" + result); } }) mx.data.action({ params: { applyto: \"selection\" actionname: \"微流\", guids: [ \"281530811285515\", \"281530811285506\"]//需要传递的参数 }, callback: function(obj) { // expect single MxObject alert(obj.get(\"manufacturer\")); }, error: function(error) { alert(error.message); } }); （三）打开页面 /** 请见：https://apidocs.mendix.com/7/client/mendix_lib_MxContext.html */ //上下文如何获取? var _context=mendix.lib.MxContext(); _context.setTrackEntity(你需要传递的实体) //或者使用_context.setTrackId(你需要传递的guid) mx.ui.openForm(\"页面\",{ location: \"content/popup/modal\", context:_context, callback: function(form) { console.log(form.id); } }) （四）监听实体值得变化 //监听某个实体的变化 var subscription = mx.data.subscribe({ guid: \"123213\", callback: function(guid) { console.log(\"Object with guid \" + guid + \" changed\"); } }); mx.data.unsubscribe(subscription); //监听实体某个属性的变化 var subscription = mx.data.subscribe({ guid: \"123213\", attr: \"Name\", callback: function(guid, attr, value) { console.log(\"Object with guid \" + guid + \" had its attribute \" + attr + \" change to \" + value); } }); mx.data.unsubscribe(subscription); //监听整个实体的变化 // Subscribe to changes in a class var subscription = mx.data.subscribe({ entity: \"System.User\", callback: function(entity) { console.log(\"Update on entity \" + entity); } }); mx.data.unsubscribe(subscription); （五）查询管理关系的数据 //多对一关系，路径要指定到关联关系实体的字段 obj.fetch(\"Demo.Test/Test_Test2/test2Attr\",function(data){ //成功回调数据，返回的是一条数据 },function(){ }); //多对对一关系，路径要指定到关联关系实体，不能是字段 obj.fetch(\"Demo.Test/Test_Test3\",function(data){ //成功回调数据，返回的是一个列表数据 },function(){ }); （六）创建一个上下文 详情请见:组件开发上下文 var context=mendix.lib.MxContext(); context.setTrackEntity(你的obj) 二、组件开发XML文档 （一）property配置 1、配置的类型有： //页面 //微流 2、其他配置项 isList=\"\" //是否为列表配置，只有当type=\"object\"的时候有效 entityProperty=\"配置实体的key\" //执行微流时入参的实体，注意此处的Key为相对位置； //也即是如果这个key所在的property和你配置的property在同一层级， //那么就直接使用实体的key，要是此propery比实体的property深一层， //那么此处就要写: ../实体的key allowNonPersistableEntities=\"false\"//是否允许非持久化实体 isPath=\"no\"//是否可通过关联取数据 parameterIsList=\"false/true\"//微流的入参是否为List的形式 multiline=\"false\"//当type=\"string\"的时候是否支持多行 defaultValue=\"\"//默认值 required=\"false/true\"//此配置项是否必须配置 isDefault=\"false\"//是否默认 （二）两个例子 1、枚举选择，实际在读取的时候是按照key 名称 分类 描述 弹窗 当前页面 2、实体配置 名称 分类 描述 3、微流配置（接受list方式的入参） 名称 分类 描述 或者 //上述的returnType的type可以有 4、选择实体的属性 名称 分类 描述 //所有可能的类型有: 5、选择实体的属性 //所选择的属性为某个实体下面的属性 名称 分类 描述 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/Mendix后台程序环境搭建.html":{"url":"article/mendix/Mendix后台程序环境搭建.html","title":"4. Mendix后台程序环境搭建","keywords":"","body":"一、Docker的安装二、Docker Compose安装三、Mendix环境搭建四、启动成功五、Mendix后台环境搭建注意事项 以下所有文件均是原创，如需转载请注明作者和链接地址。 目录： 一、Docker的安装 二、Docker Compose安装 三、Mendix环境搭建 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 2、登录时为何使用Administor无法登录 3、docker-compose-mysql字段简要介绍 4 、访问地址为何过总是报错502 当在Mendix Desktop上编写完成项目，此时需要打包发布；首先请在客户端 -->Project-->Create Deployement Project； Mendix后台程序需要运行在Docker环境下，此文主要介绍mendix如何在centos下运行。 打包环境必须为生产环境： Mendix程序需要运行需要的环境限制： 在Centos7.3及以上版本,且Docker 要求 CentOS 系统的内核版本高于 3.10； 由于Mendix运行的Docker compose版本为1.22,所以请安装Docker 17.06.2。 一、Docker的安装 1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。 通过 uname -r 命令查看你当前的内核版本 $ uname -r 2、使用 root 权限登录 Centos。确保 yum 包更新到最新。 $ sudo yum update 3、卸载旧版本(如果安装过旧版本的话) $ sudo yum remove docker docker-common docker-selinux docker-engine 4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 $ sudo yum install -y yum-utils device-mapper-persistent-data lvm2 5、设置yum源 $ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 6、可以查看所有仓库中所有docker版本，并选择特定版本安装 $ yum list docker-ce --showduplicates | sort -r 7、安装docker $ sudo yum install docker-ce-17.06.2 #安装的是最新稳定版17.06.2 8、启动并加入开机启动 $ sudo systemctl start docker $ sudo systemctl enable docker 9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了) $ docker version 二、Docker Compose安装 在安装Docker Compose之前请确定已经安装了python-pip。 python-pip安装教程请见此文 https://blog.csdn.net/yulei_qq/article/details/52984334 安装好pip之后，就可以安装Docker-Compose了. 在linunx终端执行：pip install docker-compose. 检查docker-compose是否安装成功： 三、Mendix环境搭建 Mendix运行在docker中，其开源环境请见:https://github.com/mendix/docker-mendix-buildpack。 开源地址的Readme.md文件有如下介绍： 简单介绍： get-sample：得到一个Mendix应用程序，并将其解压到build目录下； buid-image：创建Mendix运行，需要的镜像； run-container：启动容器。 1、请将您之前打包好的mda文件上传到服务器 scp xxx.mda root@ip地址:/usr/local/mendix/app (xxx：自己的工程名；mendix/app是自己创建的目录) 2、复制项目并切换目录 git clone https://github.com/mendix/docker-mendix-buildpack cd docker-mendix-buildpack 3、将sample的apk替换成自己的apk 替换成： 4、启动容器 运行make run-container 正常情况下容器会被启动，这样就可以通过url地址访问自己的应用程序。但是在启动时总会遇到各种问题。 四、启动成功 五、Mendix后台环境搭建注意事项 1、端口是否已被占用 由于在配置文件中配置了docker的8080映射到服务器的80端口，以及8090映射到81端口；所以请确认服务器的这两个端口是否已被占用（如果已经被占用：可修改此处的配置文件） 如果修改成其他的端口，请记修改Dockerfile配置文件中的nginx端口：否则程序不会允许 3、登录时为何使用Administor无法登录 mendix客户端的administor账户是在测试环境使用的； 如果程序发布到服务器， 则需要登录的账户为：MxAdmin 密码为：docker-compose-mysql中的ADMIN_PASSWORD字段 4、docker-compose-mysql字段简要介绍 mendixapp: image:为docker镜像； ADMIN_PASSWORLD:使用MxAdmin账户登录系统的密码； DATABASE_ENDPOINT：应用的数据库地址，最后一个mendix为创建的mendix数据库； ports：docker端口和服务器端口的映射关系，如果服务器的端口已被占用，则需要修改映射的端口； db： MYSQL_DATABASE=mendix //mendix数据库名 MYSQL_USER：mendix数据库的用户 MYSQL_PASSWORD：mendix数据库的密码 MYSQL_ROOT_PASSWORD=root //数据库最高权限密码（当然账号也为root） ports：docker中数据库端口和服务器端口的映射关系。 5、访问地址为何过总是报错502 哪些情况出现502: 访问次数过多； 3个小时左右会自动停止； 之所以一直报错502的最根本原因是没有向Mendix购买license；没有license 最多只能在线10个用户，且系统每隔3小时左右关闭。所以需要向Mendix购买License。 停止了，可重启容器 重新部署包，则需要先关闭mysql容器，再使用make run-container。 Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/获取配置信息,使用java创建Rest服务.html":{"url":"article/mendix/获取配置信息,使用java创建Rest服务.html","title":"6. 使用Java创建Rest服务","keywords":"","body":" 以下所有文件均是原创，如需转载请注明作者和链接地址。 1、如何读取resource下的配置文件信息 假设resource目录下的文明为properties文件； //第一步：获取配置文件目录: File resourcePath=Core.getConfiguration().getResourcesPath(); //第二步：读取对应配置文件，此处可以根据环境的不同读取不同的配置文件 File configFile=new File(resourcePath,\"config.properties\"); Properties prop = new Properties(); //第三步：读取属性文件到Properties中 InputStream in = new BufferedInputStream (new FileInputStream(configFile)); prop.load(in); ///加载属性列表 Iterator it=prop.stringPropertyNames().iterator(); while(it.hasNext()){ String key=it.next(); System.out.println(key+\":\"+prop.getProperty(key)); } in.close(); 2、如何获取Cookie String cookies=\"\"; Cookie[] cook=this.context().getRuntimeRequest().get().getHttpServletRequest().getCookies(); for(Cookie c:cook){ cookies+=c.getName()+\"=\"+c.getValue()+\";\"; } 3、如何在java中打Log private static ILogNode log=Core.getLogger(\"mylogname\"); 4、如何在mendix启动之前做一下预处理？ 只需要在Project》Settings》Runtime》After Startup中调用即可。 5、自定义Rest服务 常常使用mendix自带的Rest服务无法满足我们的需求，那么怎么自定义Rest服务呢？自定义Rest服务只需要继承RequestHandler即可。 //第一步：继承RequestHandler，并实现processRequest方法 public class ArticleService extends RequestHandler { @Override protected void processRequest(IMxRuntimeRequest iMxRuntimeRequest, IMxRuntimeResponse iMxRuntimeResponse, String path) throws Exception { } } //第二步：在启动整个mendix的时候，调用一个Javaaction，在此Action中进行Rest服务注册。 public java.lang.Boolean executeAction() throws Exception { // BEGIN USER CODE //throw new com.mendix.systemwideinterfaces.MendixRuntimeException(\"Java action was not implemented\"); // 注册自定义服务 Core.addRequestHandler(\"my/rest\",new ArticleService()); return true; // END USER CODE } Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/mendix/一些功能的实现.html":{"url":"article/mendix/一些功能的实现.html","title":"7. Mendix教程（11篇文章）","keywords":"","body":" 由于文章较多，此处列举一些常实现的mendix功能和大家分享。以下所有文件均是原创，如需转载请注明作者和链接地址。 一、基础公共包功能一览 基础公共包功能一览 二、使用dojo开发mendix组件你必须知道的 dijit.register你必须知道的 dojo.aspect模块你必须知道的 dom-construct 三、开发者与非开发者如何定制化datagrid的样式 定制化datagrid 四、Excel中大量字段如何高效构建Entity Excel中大量字段如何高效构建Entity 五、Mendix实现级联选择 Mendix实现级联选择 六、Mendix导出数据到Excel（基础使用） Mendix导出数据到Excel（基础使用) 七、Mendix如何一键导出数据到Excel的多个Sheet Mendix如何一键导出数据到Excel的多个Sheet 八、Mendix监控实现方案（使用自带端口） Mendix监控实现方案（使用自带端口） 九、Mendix使用队列异步处理大量数据 Mendix使用队列异步处理大量数据 十、Mendix使用Excel导入数据 Mendix使用Excel导入数据 十一、DataGrid数据从微流获取，并实现自定义Search DataGrid数据从微流获取，并实现自定义Search Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "},"article/other/vscode.html":{"url":"article/other/vscode.html","title":"VsCode插件开发","keywords":"","body":"一、环境搭建二、package.json 配置三、contributes介绍四、常用 API五、环境 简介：本文将会教会大家如何一步步开发Vscode插件。 插件地址 luck_npm 欢迎star 此插件的主要功能是方面使用 npm install,npm run dev,npm run build 命令；搭配 vue 脚手架 Vue+webpack+vuex+router更加舒适哦 效果图： 一、环境搭建 1、npm install -g yo generator-code 安装脚手架; 2、yo code 创建项目 本人选择的是：javascript 创建好之后系统会自动生成一个 package.json 和 extension.js 文件； 二、package.json 配置 { \"name\": \"lucky-npm\", //插件名称 \"displayName\": \"lucky npm\", \"description\": \"\", \"version\": \"1.0.1\", \"publisher\": \"mrgao\", \"engines\": { \"vscode\": \"^1.32.0\" }, \"repository\": { \"type\": \"git\", \"url\": \"git+https://github.com/MrGaoGang/lucky_start.git\" }, \"categories\": [ //分类 \"Other\" ], \"icon\": \"icon/logo.png\", //logo \"activationEvents\": [ //激活方式 \"workspaceContains:package.json\", \"onCommand:lucky.gao.extension.install\", \"onCommand:lucky.gao.extension.start_dev\", \"onCommand:lucky.gao.extension.build_pro\" ], \"main\": \"./extension.js\", //入口文件 \"contributes\": { \"snippets\": [ //自定义一些代码模板（可以尝试输入fetch） { \"language\": \"javascript\", \"path\": \"./src/snippet/snippet.json\" } ], \"views\": { //视图 \"explorer\": [ { //在资源管理器中的视图，id为mrgao_luckys，名字为LUCKY NPM \"id\": \"mrgao_luckys\", \"name\": \"LUCKY NPM\" } ] }, \"commands\": [ //有哪些命令 { \"command\": \"lucky.gao.extension.install\", \"title\": \"安装依赖(install)\" }, { \"command\": \"lucky.gao.extension.start_dev\", \"title\": \"启动测试环境(dev)\" }, { \"command\": \"lucky.gao.extension.build_pro\", \"title\": \"构建生产版本(pro)\" } ], \"menus\": { //菜单，是否右键显示菜单，其中group为分类, \"editor/context\": [ { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.install\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.start_dev\", \"group\": \"6_luck\" }, { \"when\": \"editorFocus\", \"command\": \"lucky.gao.extension.build_pro\", \"group\": \"6_luck\" } ] } }, \"scripts\": { \"postinstall\": \"node ./node_modules/vscode/bin/install\", \"test\": \"node ./node_modules/vscode/bin/test\" }, \"devDependencies\": { \"typescript\": \"^3.3.1\", \"vscode\": \"^1.1.28\", \"eslint\": \"^5.13.0\", \"@types/node\": \"^10.12.21\", \"@types/mocha\": \"^2.2.42\" } } 1. activationEvents 介绍 激活插件的方式 onLanguage 激活 发出此激活事件，只要解析为某种语言的文件被打开，就会激活感兴趣的扩展。 \"activationEvents\"：[ \" onLanguage：python \" ] 可以使用数组中的单独 onLanguage 条目声明多种语言 activationEvents。 \"activationEvents\"：[ \" onLanguage：json \", \" onLanguage：markdown \", \" onLanguage：typescript \" ] onCommand 加载方式 发出此激活事件，并且只要调用命令，就会激活当前扩展： \" activationEvents \"：[ \" onCommand：extension.sayHello \" ] onDebug 加载方式 并在启动调试会话之前激活当前扩展： \" activationEvents \"：[ \" onDebug \" ] onDebugInitialConfigurations onDebugResolve 这是两个更细粒度的 onDebug 激活事件： onDebugInitialConfigurations 在调用 provideDebugConfigurations 方法之前触发 DebugConfigurationProvider。 onDebugResolve:type 在调用指定类型的 resolveDebugConfiguration 方法之前触发 DebugConfigurationProvider。 经验法则：如果调试扩展的激活是轻量级的，请使用 onDebug。如果它是重量级的，则使用 onDebugInitialConfigurations 和/或 onDebugResolve 取决于是否 DebugConfigurationProvider 实施相应的方法 provideDebugConfigurations 和/或 resolveDebugConfiguration。有关这些方法的更多详细信息，请参阅使用 DebugConfigurationProvider。 workspaceContains 激活方式 每当打开文件夹并且文件夹包含至少一个与 模式匹配的文件时，就会激活此激活事件并激活当前扩展。 \" activationEvents \"：[ \" workspaceContains：** /。editorconfig \" ] onFileSystem 激活方式 发出此激活事件，只要读取特定方案中的文件或文件夹，就会激活感兴趣的扩展。这通常是 file-scheme，但是对于自定义文件系统提供程序，有更多的方案可以实现，例如 ftp 或 ssh。 \" activationEvents \"：[ \" onFileSystem：sftp \" ] onView 激活方式 发出此激活事件，只要展开指定 ID 的视图，就会激活当前扩展： \" activationEvents \"：[ \" onView：nodeDependencies \" ] onUri 激活方式 发出此激活事件，只要打开该扩展的系统范围的 Uri，就会激活感兴趣的扩展。Uri 计划固定为 vscode 或 vscode-insiders。Uri 权限必须是扩展的标识符。Uri 的其余部分是任意的。 \" activationEvents \"：[ \" onUri \" ] 如果 vscode.git 扩展名定义 onUri 为激活事件，则会在以下任何一个 Uris 中打开它： vscode://vscode.git/init vscode://vscode.git/clone?url=https%3A%2F%2Fgithub.com%2FMicrosoft%2Fvscode-vsce.git vscode-insiders://vscode.git/init （对于 VS Code Insiders） onWebviewPanel 激活方式 每当 VS Code 需要使用匹配恢复 webview 时，将发出此激活事件并激活当前扩展 viewType。 例如，onWebviewPanel 的声明如下： \" activationEvents \"：[ \" onWebviewPanel：catCoding \" ] 当 VS Code 需要使用 viewType 恢复 webview 时，将导致扩展被激活：catCoding。viewType 在调用中设置 window.createWebviewPanel，您需要有另一个激活事件（例如，onCommand）来初始激活您的扩展并创建 webview。 * 激活方式 该*激活事件发出后，每当 VS 代码启动感兴趣的扩展将被激活。为确保良好的最终用户体验，请仅在您的用户使用其他激活事件组合时才在扩展中使用此激活事件。 \" activationEvents \"：[ \" * \" ] 三、contributes介绍 详情请见 contributes介绍 四、常用 API 这里主要介绍一下 extension 中的一些常用命令。官方 API 请见: vscode api 1. 命令 命令注册 //注册命令 vscode.commands.registerCommand('lucky.hello', () => { }); //注册之后必须在package.json中配置: { \"contributes\": { \"commands\": [{ \"command\": \"lucky.hello\", \"title\": \"Hello World\" }] } } // 命令执行 //vscode.open为vscode自带命令（也可以使用自己的命令），可以用来打开一个页面 vscode.commands.executeCommand( \"vscode.open\", vscode.Uri.parse(`https://code.visualstudio.com/updates/`) ); 获取所有命令 vscode.commands.getCommands(false); //会返回所有命令 接收一个参数:是否显示系统自带的内部命令,此处Wiefalse 2. 显示 vscode.window.showInformationMessage(\"我是info信息！\"); vscode.window.showErrorMessage(\"我是错误信息！\"); vscode.window.setStatusBarMessage(\"设置状态栏的消息\"); //带回调的提示 vscode.window .showInformationMessage(\"是否要做什么.....？\", \"是\", \"否\", \"不再提示\") .then(result => { if (result === \"是\") { } else if (result === \"不再提示\") { // 其它操作 } }); 3. window 创建一个终端并输入命令 let terminalA = vscode.window.createTerminal({ name: \"我是终端的名字\" }); terminalA.show(true); terminalA.sendText(\"npm start\"); //输入命令 显示一个输入框，让用户输入一个字符串 /** * 打开输入框以询问用户输入。 undefined如果输入框被取消（例如按ESC），则返回值。否则，返回的值将是用户键入的字符串，如果用户没有输入任何内容，则返回值为空，但是单击\"确定\"将输入框解除。 * */ const result = vscode.window.showInputBox({ prompt: \"请输入版本号，\", value: \"默认值\", placeHolder: \"提示\", valueSelection: [len, len] }); result.then(inputValue => { // 是按下ESC键 if (typeof _versionName === \"undefined\") return; //按下enter键 }); 创建树状视图 vscode.window.registerTreeDataProvider('viewId', treeProvider); //viewId对应package.json中id \"contributes\": { \"views\": { \"explorer\": [ { \"id\": \"viewId\", \"name\": \"NPM Tools\" } ] }, } //treeProvider请见此插件源码。 打开文档 vscode.workspace.openTextDocument(vscode.Uri.file(\"文件路径)).then( document => vscode.window.showTextDocument(document) ) 五、环境 vscode.env.appName //当前编辑器的名称 vscode.env.appRoot //打开的根目录 vscode.env.language //用户的语言环境 插件地址 欢迎star Copyright © gaogang 2019 all right reserved，powered by Gitbook文章修订时间： 2019-06-30 08:40:27 "}}